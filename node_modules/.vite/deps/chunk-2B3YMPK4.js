import {
  TYPED_ARRAYS,
  VtkDataTypes,
  add,
  areMatricesEqual,
  clampVector,
  createUninitializedBounds,
  cross,
  degreesFromRadians,
  determinant2x2,
  distance2BetweenPoints,
  dot,
  get,
  getArray,
  hsv2rgb,
  invertMatrix,
  isNan,
  isPowerOfTwo,
  macro,
  macro$1,
  moveToProtected,
  multiplyAccumulate,
  nearestPowerOfTwo,
  newInstance,
  newTypedArray,
  norm,
  normalize,
  normalize2D,
  obj,
  radiansFromDegrees,
  require_fast_deep_equal,
  round,
  roundVector,
  set,
  setGet,
  solveLinearSystem,
  subtract,
  uninitializeBounds,
  vtk,
  vtkDataArray$1,
  vtkErrorMacro,
  vtkMath
} from "./chunk-CTNZCI6N.js";
import {
  __export,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js
var import_fast_deep_equal = __toESM(require_fast_deep_equal(), 1);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/Constants.js
var Wrap = {
  CLAMP_TO_EDGE: 0,
  REPEAT: 1,
  MIRRORED_REPEAT: 2
};
var Filter = {
  NEAREST: 0,
  LINEAR: 1,
  NEAREST_MIPMAP_NEAREST: 2,
  NEAREST_MIPMAP_LINEAR: 3,
  LINEAR_MIPMAP_NEAREST: 4,
  LINEAR_MIPMAP_LINEAR: 5
};
var Constants = {
  Wrap,
  Filter
};

// node_modules/@kitware/vtk.js/Common/Core/HalfFloat.js
var floatView = new Float32Array(1);
var int32View = new Int32Array(floatView.buffer);
function toHalf(val) {
  floatView[0] = val;
  const x = int32View[0];
  let bits = x >> 16 & 32768;
  let m = x >> 12 & 2047;
  const e = x >> 23 & 255;
  if (e < 103) {
    return bits;
  }
  if (e > 142) {
    bits |= 31744;
    bits |= (e === 255 ? 0 : 1) && x & 8388607;
    return bits;
  }
  if (e < 113) {
    m |= 2048;
    bits |= (m >> 114 - e) + (m >> 113 - e & 1);
    return bits;
  }
  bits |= e - 112 << 10 | m >> 1;
  bits += m & 1;
  return bits;
}
function fromHalf(h) {
  const s = (h & 32768) >> 15;
  const e = (h & 31744) >> 10;
  const f = h & 1023;
  if (e === 0) {
    return (s ? -1 : 1) * 2 ** -14 * (f / 2 ** 10);
  }
  if (e === 31) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }
  return (s ? -1 : 1) * 2 ** (e - 15) * (1 + f / 2 ** 10);
}
var HalfFloat = {
  fromHalf,
  toHalf
};

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNode.js
var {
  vtkErrorMacro: vtkErrorMacro2
} = macro;
var PASS_TYPES = ["Build", "Render"];
function vtkViewNode(publicAPI, model) {
  model.classHierarchy.push("vtkViewNode");
  function moveChild(child, toIndex) {
    for (let i = 0; i < model.children.length; ++i) {
      const childIndex = (toIndex + 1 + i) % model.children.length;
      if (model.children[childIndex] === child) {
        model.children[childIndex] = model.children[toIndex];
        model.children[toIndex] = child;
        return true;
      }
    }
    return false;
  }
  publicAPI.build = (prepass) => {
  };
  publicAPI.render = (prepass) => {
  };
  publicAPI.traverse = (renderPass) => {
    const passTraversal = renderPass.getTraverseOperation();
    const fn = publicAPI[passTraversal];
    if (fn) {
      fn(renderPass);
      return;
    }
    publicAPI.apply(renderPass, true);
    for (let index2 = 0; index2 < model.children.length; index2++) {
      model.children[index2].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.apply = (renderPass, prepass) => {
    const customRenderPass = publicAPI[renderPass.getOperation()];
    if (customRenderPass) {
      customRenderPass(prepass, renderPass);
    }
  };
  publicAPI.getViewNodeFor = function(dataObject) {
    let hint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (hint && hint.renderable === dataObject) {
      return hint;
    }
    if (model.renderable === dataObject) {
      return publicAPI;
    }
    for (let index2 = 0; index2 < model.children.length; ++index2) {
      const child = model.children[index2];
      const vn = child.getViewNodeFor(dataObject);
      if (vn) {
        return vn;
      }
    }
    return void 0;
  };
  publicAPI.getFirstAncestorOfType = (type) => {
    if (!model._parent) {
      return null;
    }
    if (model._parent.isA(type)) {
      return model._parent;
    }
    return model._parent.getFirstAncestorOfType(type);
  };
  publicAPI.getLastAncestorOfType = (type) => {
    if (!model._parent) {
      return null;
    }
    const lastAncestor = model._parent.getLastAncestorOfType(type);
    if (lastAncestor) {
      return lastAncestor;
    }
    if (model._parent.isA(type)) {
      return model._parent;
    }
    return null;
  };
  publicAPI.addMissingNode = (dobj) => {
    if (!dobj) {
      return void 0;
    }
    const result = model._renderableChildMap.get(dobj);
    if (result !== void 0) {
      result.setVisited(true);
      return result;
    }
    const newNode = publicAPI.createViewNode(dobj);
    if (newNode) {
      newNode.setParent(publicAPI);
      newNode.setVisited(true);
      model._renderableChildMap.set(dobj, newNode);
      model.children.push(newNode);
      return newNode;
    }
    return void 0;
  };
  publicAPI.addMissingNodes = function(dataObjs) {
    let enforceOrder = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!dataObjs || !dataObjs.length) {
      return;
    }
    let nextIndex;
    for (let index2 = 0; index2 < dataObjs.length; ++index2) {
      const dobj = dataObjs[index2];
      const node = publicAPI.addMissingNode(dobj);
      if (enforceOrder && node !== void 0) {
        if (nextIndex === void 0) {
          nextIndex = model.children.lastIndexOf(node);
        } else if (model.children[nextIndex] !== node) {
          moveChild(model.children, node);
        }
        nextIndex++;
      }
    }
  };
  publicAPI.addMissingChildren = (children) => {
    if (!children || !children.length) {
      return;
    }
    for (let index2 = 0; index2 < children.length; ++index2) {
      const child = children[index2];
      const cindex = model.children.indexOf(child);
      if (cindex === -1) {
        child.setParent(publicAPI);
        model.children.push(child);
        const childRenderable = child.getRenderable();
        if (childRenderable) {
          model._renderableChildMap.set(childRenderable, child);
        }
      }
      child.setVisited(true);
    }
  };
  publicAPI.removeNode = (child) => {
    const childIdx = model.children.findIndex((x) => x === child);
    if (childIdx < 0) {
      return false;
    }
    const renderable = child.getRenderable();
    if (renderable) {
      model._renderableChildMap.delete(renderable);
    }
    child.delete();
    model.children.splice(childIdx, 1);
    return true;
  };
  publicAPI.prepareNodes = () => {
    for (let index2 = 0; index2 < model.children.length; ++index2) {
      model.children[index2].setVisited(false);
    }
  };
  publicAPI.setVisited = (val) => {
    model.visited = val;
  };
  publicAPI.removeUnusedNodes = () => {
    let visitedCount = 0;
    for (let index2 = 0; index2 < model.children.length; ++index2) {
      const child = model.children[index2];
      const visited = child.getVisited();
      if (visited) {
        model.children[visitedCount++] = child;
        child.setVisited(false);
      } else {
        const renderable = child.getRenderable();
        if (renderable) {
          model._renderableChildMap.delete(renderable);
        }
        child.delete();
      }
    }
    model.children.length = visitedCount;
  };
  publicAPI.createViewNode = (dataObj) => {
    if (!model.myFactory) {
      vtkErrorMacro2("Cannot create view nodes without my own factory");
      return null;
    }
    const ret = model.myFactory.createNode(dataObj);
    if (ret) {
      ret.setRenderable(dataObj);
    }
    return ret;
  };
  const parentDelete = publicAPI.delete;
  publicAPI.delete = () => {
    for (let i = 0; i < model.children.length; i++) {
      model.children[i].delete();
    }
    parentDelete();
  };
}
var DEFAULT_VALUES = {
  // _parent: null,
  renderable: null,
  myFactory: null,
  children: [],
  visited: false
};
function extend(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  macro.obj(publicAPI, model);
  macro.event(publicAPI, model, "event");
  model._renderableChildMap = /* @__PURE__ */ new Map();
  macro.get(publicAPI, model, ["visited"]);
  macro.setGet(publicAPI, model, ["_parent", "renderable", "myFactory"]);
  macro.getArray(publicAPI, model, ["children"]);
  macro.moveToProtected(publicAPI, model, ["parent"]);
  vtkViewNode(publicAPI, model);
}
var newInstance2 = macro.newInstance(extend, "vtkViewNode");
var vtkViewNode$1 = {
  newInstance: newInstance2,
  extend,
  PASS_TYPES
};

// node_modules/@kitware/vtk.js/Rendering/SceneGraph/ViewNodeFactory.js
function vtkViewNodeFactory(publicAPI, model) {
  if (!model.overrides) {
    model.overrides = {};
  }
  model.classHierarchy.push("vtkViewNodeFactory");
  publicAPI.createNode = (dataObject) => {
    if (dataObject.isDeleted()) {
      return null;
    }
    let cpt = 0;
    let className = dataObject.getClassName(cpt++);
    let isObject = false;
    const keys = Object.keys(model.overrides);
    while (className && !isObject) {
      if (keys.indexOf(className) !== -1) {
        isObject = true;
      } else {
        className = dataObject.getClassName(cpt++);
      }
    }
    if (!isObject) {
      return null;
    }
    const vn = model.overrides[className]();
    vn.setMyFactory(publicAPI);
    return vn;
  };
}
var DEFAULT_VALUES2 = {
  // overrides: {},
};
function extend2(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES2, initialValues);
  macro.obj(publicAPI, model);
  vtkViewNodeFactory(publicAPI, model);
}
var newInstance3 = macro.newInstance(extend2, "vtkViewNodeFactory");
var vtkViewNodeFactory$1 = {
  newInstance: newInstance3,
  extend: extend2
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ViewNodeFactory.js
var CLASS_MAPPING = /* @__PURE__ */ Object.create(null);
function registerOverride(className, fn) {
  CLASS_MAPPING[className] = fn;
}
function vtkOpenGLViewNodeFactory(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLViewNodeFactory");
}
var DEFAULT_VALUES3 = {};
function extend3(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES3, initialValues);
  model.overrides = CLASS_MAPPING;
  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
  vtkOpenGLViewNodeFactory(publicAPI, model);
}
var newInstance4 = macro.newInstance(extend3, "vtkOpenGLViewNodeFactory");
var vtkViewNodeFactory2 = {
  newInstance: newInstance4,
  extend: extend3
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture/supportsNorm16Linear.js
function supportsNorm16Linear() {
  try {
    const canvasSize = 4;
    const texWidth = 2;
    const texHeight = 1;
    const texData = new Int16Array([0, 2 ** 15 - 1]);
    const pixelToCheck = [1, 1];
    const canvas = document.createElement("canvas");
    canvas.width = canvasSize;
    canvas.height = canvasSize;
    const gl = canvas.getContext("webgl2");
    if (!gl) {
      return false;
    }
    const ext = gl.getExtension("EXT_texture_norm16");
    if (!ext) {
      return false;
    }
    const vs = `#version 300 es
    void main() {
      gl_PointSize = ${canvasSize.toFixed(1)};
      gl_Position = vec4(0, 0, 0, 1);
    }
  `;
    const fs = `#version 300 es
    precision highp float;
    precision highp int;
    precision highp sampler2D;

    uniform sampler2D u_image;

    out vec4 color;

    void main() {
        vec4 intColor = texture(u_image, gl_PointCoord.xy);
        color = vec4(vec3(intColor.rrr), 1);
    }
    `;
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, vs);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
      return false;
    }
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, fs);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
      return false;
    }
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      return false;
    }
    const tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.texImage2D(gl.TEXTURE_2D, 0, ext.R16_SNORM_EXT, texWidth, texHeight, 0, gl.RED, gl.SHORT, texData);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.useProgram(program);
    gl.drawArrays(gl.POINTS, 0, 1);
    const pixel = new Uint8Array(4);
    gl.readPixels(pixelToCheck[0], pixelToCheck[1], 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
    const [r, g, b] = pixel;
    const webglLoseContext = gl.getExtension("WEBGL_lose_context");
    if (webglLoseContext) {
      webglLoseContext.loseContext();
    }
    return r === g && g === b && r !== 0;
  } catch (e) {
    return false;
  }
}
var supportsNorm16LinearCache;
function supportsNorm16LinearCached() {
  if (supportsNorm16LinearCache === void 0) {
    supportsNorm16LinearCache = supportsNorm16Linear();
  }
  return supportsNorm16LinearCache;
}

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Texture.js
var {
  Wrap: Wrap2,
  Filter: Filter2
} = Constants;
var {
  VtkDataTypes: VtkDataTypes2
} = vtkDataArray$1;
var {
  vtkDebugMacro,
  vtkErrorMacro: vtkErrorMacro3,
  vtkWarningMacro,
  requiredParam
} = macro$1;
var {
  toHalf: toHalf2
} = HalfFloat;
function vtkOpenGLTexture(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLTexture");
  function getTexParams() {
    return {
      internalFormat: model.internalFormat,
      format: model.format,
      openGLDataType: model.openGLDataType,
      width: model.width,
      height: model.height
    };
  }
  publicAPI.render = function() {
    let renWin = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    if (renWin) {
      model._openGLRenderWindow = renWin;
    } else {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
    }
    model.context = model._openGLRenderWindow.getContext();
    if (model.renderable.getInterpolate()) {
      if (model.generateMipmap) {
        publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
      } else {
        publicAPI.setMinificationFilter(Filter2.LINEAR);
      }
      publicAPI.setMagnificationFilter(Filter2.LINEAR);
    } else {
      publicAPI.setMinificationFilter(Filter2.NEAREST);
      publicAPI.setMagnificationFilter(Filter2.NEAREST);
    }
    if (model.renderable.getRepeat()) {
      publicAPI.setWrapR(Wrap2.REPEAT);
      publicAPI.setWrapS(Wrap2.REPEAT);
      publicAPI.setWrapT(Wrap2.REPEAT);
    }
    if (model.renderable.getInputData()) {
      model.renderable.setImage(null);
    }
    if (!model.handle || model.renderable.getMTime() > model.textureBuildTime.getMTime()) {
      if (model.renderable.getImageBitmap() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        if (model.renderable.getImageBitmap() && model.renderable.getImageLoaded()) {
          publicAPI.create2DFromImageBitmap(model.renderable.getImageBitmap());
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
      }
      if (model.renderable.getImage() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        if (model.renderable.getImage() && model.renderable.getImageLoaded()) {
          publicAPI.create2DFromImage(model.renderable.getImage());
          publicAPI.activate();
          publicAPI.sendParameters();
          model.textureBuildTime.modified();
        }
      }
      if (model.renderable.getCanvas() !== null) {
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        const canvas = model.renderable.getCanvas();
        publicAPI.create2DFromRaw({
          width: canvas.width,
          height: canvas.height,
          numComps: 4,
          dataType: VtkDataTypes2.UNSIGNED_CHAR,
          data: canvas,
          flip: true
        });
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      if (model.renderable.getJsImageData() !== null) {
        const jsid = model.renderable.getJsImageData();
        if (model.renderable.getInterpolate()) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        publicAPI.create2DFromRaw({
          width: jsid.width,
          height: jsid.height,
          numComps: 4,
          dataType: VtkDataTypes2.UNSIGNED_CHAR,
          data: jsid.data,
          flip: true
        });
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
      const input = model.renderable.getInputData(0);
      if (input && input.getPointData().getScalars()) {
        const ext = input.getExtent();
        const inScalars = input.getPointData().getScalars();
        const data = [];
        for (let i = 0; i < model.renderable.getNumberOfInputPorts(); ++i) {
          const indata = model.renderable.getInputData(i);
          const scalars = indata ? indata.getPointData().getScalars().getData() : null;
          if (scalars) {
            data.push(scalars);
          }
        }
        if (model.renderable.getInterpolate() && inScalars.getNumberOfComponents() === 4) {
          model.generateMipmap = true;
          publicAPI.setMinificationFilter(Filter2.LINEAR_MIPMAP_LINEAR);
        }
        if (data.length % 6 === 0) {
          publicAPI.createCubeFromRaw({
            width: ext[1] - ext[0] + 1,
            height: ext[3] - ext[2] + 1,
            numComps: inScalars.getNumberOfComponents(),
            dataType: inScalars.getDataType(),
            data
          });
        } else {
          publicAPI.create2DFromRaw({
            width: ext[1] - ext[0] + 1,
            height: ext[3] - ext[2] + 1,
            numComps: inScalars.getNumberOfComponents(),
            dataType: inScalars.getDataType(),
            data: inScalars.getData()
          });
        }
        publicAPI.activate();
        publicAPI.sendParameters();
        model.textureBuildTime.modified();
      }
    }
    if (model.handle) {
      publicAPI.activate();
    }
  };
  const getNorm16Ext = () => {
    if ((model.minificationFilter === Filter2.LINEAR || model.magnificationFilter === Filter2.LINEAR) && !supportsNorm16LinearCached()) {
      return void 0;
    }
    return model.oglNorm16Ext;
  };
  publicAPI.destroyTexture = () => {
    publicAPI.deactivate();
    if (model.context && model.handle) {
      model.context.deleteTexture(model.handle);
    }
    model._prevTexParams = null;
    model.handle = 0;
    model.numberOfDimensions = 0;
    model.target = 0;
    model.components = 0;
    model.width = 0;
    model.height = 0;
    model.depth = 0;
    publicAPI.resetFormatAndType();
  };
  publicAPI.createTexture = () => {
    if (!model.handle) {
      model.handle = model.context.createTexture();
      if (model.target) {
        model.context.bindTexture(model.target, model.handle);
        model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
        model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
        if (model._openGLRenderWindow.getWebgl2()) {
          model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
        }
        model.context.bindTexture(model.target, null);
      }
    }
  };
  publicAPI.getTextureUnit = () => {
    if (model._openGLRenderWindow) {
      return model._openGLRenderWindow.getTextureUnitForTexture(publicAPI);
    }
    return -1;
  };
  publicAPI.activate = () => {
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.bind();
  };
  publicAPI.deactivate = () => {
    if (model._openGLRenderWindow) {
      model._openGLRenderWindow.deactivateTexture(publicAPI);
    }
  };
  publicAPI.releaseGraphicsResources = (rwin) => {
    if (rwin && model.handle) {
      rwin.activateTexture(publicAPI);
      rwin.deactivateTexture(publicAPI);
      model.context.deleteTexture(model.handle);
      model._prevTexParams = null;
      model.handle = 0;
      model.numberOfDimensions = 0;
      model.target = 0;
      model.internalFormat = 0;
      model.format = 0;
      model.openGLDataType = 0;
      model.components = 0;
      model.width = 0;
      model.height = 0;
      model.depth = 0;
      model.allocatedGPUMemoryInBytes = 0;
    }
    if (model.shaderProgram) {
      model.shaderProgram.releaseGraphicsResources(rwin);
      model.shaderProgram = null;
    }
  };
  publicAPI.bind = () => {
    model.context.bindTexture(model.target, model.handle);
    if (model.autoParameters && publicAPI.getMTime() > model.sendParametersTime.getMTime()) {
      publicAPI.sendParameters();
    }
  };
  publicAPI.isBound = () => {
    let result = false;
    if (model.context && model.handle) {
      let target = 0;
      switch (model.target) {
        case model.context.TEXTURE_2D:
          target = model.context.TEXTURE_BINDING_2D;
          break;
        default:
          vtkWarningMacro("impossible case");
          break;
      }
      const oid = model.context.getIntegerv(target);
      result = oid === model.handle;
    }
    return result;
  };
  publicAPI.sendParameters = () => {
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_S, publicAPI.getOpenGLWrapMode(model.wrapS));
    model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_T, publicAPI.getOpenGLWrapMode(model.wrapT));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_WRAP_R, publicAPI.getOpenGLWrapMode(model.wrapR));
    }
    model.context.texParameteri(model.target, model.context.TEXTURE_MIN_FILTER, publicAPI.getOpenGLFilterMode(model.minificationFilter));
    model.context.texParameteri(model.target, model.context.TEXTURE_MAG_FILTER, publicAPI.getOpenGLFilterMode(model.magnificationFilter));
    if (model._openGLRenderWindow.getWebgl2()) {
      model.context.texParameteri(model.target, model.context.TEXTURE_BASE_LEVEL, model.baseLevel);
      model.context.texParameteri(model.target, model.context.TEXTURE_MAX_LEVEL, model.maxLevel);
    }
    model.sendParametersTime.modified();
  };
  publicAPI.getInternalFormat = (vtktype, numComps) => {
    if (!model._forceInternalFormat) {
      model.internalFormat = publicAPI.getDefaultInternalFormat(vtktype, numComps);
    }
    if (!model.internalFormat) {
      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);
    }
    if ([model.context.R32F, model.context.RG32F, model.context.RGB32F, model.context.RGBA32F].includes(model.internalFormat) && !model.context.getExtension("OES_texture_float_linear")) {
      vtkWarningMacro("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats.");
    }
    return model.internalFormat;
  };
  publicAPI.getDefaultInternalFormat = (vtktype, numComps) => {
    let result = 0;
    result = model._openGLRenderWindow.getDefaultTextureInternalFormat(vtktype, numComps, getNorm16Ext(), publicAPI.useHalfFloat());
    if (result) {
      return result;
    }
    if (!result) {
      vtkDebugMacro("Unsupported internal texture type!");
      vtkDebugMacro(`Unable to find suitable internal format for T=${vtktype} NC= ${numComps}`);
    }
    return result;
  };
  publicAPI.useHalfFloat = () => model.enableUseHalfFloat && model.canUseHalfFloat;
  publicAPI.setInternalFormat = (iFormat) => {
    model._forceInternalFormat = true;
    if (iFormat !== model.internalFormat) {
      model.internalFormat = iFormat;
      publicAPI.modified();
    }
  };
  publicAPI.getFormat = (vtktype, numComps) => {
    model.format = publicAPI.getDefaultFormat(vtktype, numComps);
    return model.format;
  };
  publicAPI.getDefaultFormat = (vtktype, numComps) => {
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (numComps) {
        case 1:
          return model.context.RED;
        case 2:
          return model.context.RG;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    } else {
      switch (numComps) {
        case 1:
          return model.context.LUMINANCE;
        case 2:
          return model.context.LUMINANCE_ALPHA;
        case 3:
          return model.context.RGB;
        case 4:
          return model.context.RGBA;
        default:
          return model.context.RGB;
      }
    }
  };
  publicAPI.resetFormatAndType = () => {
    model._prevTexParams = null;
    model.format = 0;
    model.internalFormat = 0;
    model._forceInternalFormat = false;
    model.openGLDataType = 0;
  };
  publicAPI.getDefaultDataType = (vtkScalarType) => {
    const useHalfFloat = publicAPI.useHalfFloat();
    if (model._openGLRenderWindow.getWebgl2()) {
      switch (vtkScalarType) {
        case VtkDataTypes2.UNSIGNED_CHAR:
          return model.context.UNSIGNED_BYTE;
        case (getNorm16Ext() && !useHalfFloat && VtkDataTypes2.SHORT):
          return model.context.SHORT;
        case (getNorm16Ext() && !useHalfFloat && VtkDataTypes2.UNSIGNED_SHORT):
          return model.context.UNSIGNED_SHORT;
        case (useHalfFloat && VtkDataTypes2.SHORT):
          return model.context.HALF_FLOAT;
        case (useHalfFloat && VtkDataTypes2.UNSIGNED_SHORT):
          return model.context.HALF_FLOAT;
        case VtkDataTypes2.FLOAT:
        case VtkDataTypes2.VOID:
        default:
          return model.context.FLOAT;
      }
    }
    switch (vtkScalarType) {
      case VtkDataTypes2.UNSIGNED_CHAR:
        return model.context.UNSIGNED_BYTE;
      case VtkDataTypes2.FLOAT:
      case VtkDataTypes2.VOID:
      default:
        if (model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
          return model.context.FLOAT;
        }
        {
          const halfFloat = model.context.getExtension("OES_texture_half_float");
          if (halfFloat && model.context.getExtension("OES_texture_half_float_linear")) {
            return halfFloat.HALF_FLOAT_OES;
          }
        }
        return model.context.UNSIGNED_BYTE;
    }
  };
  publicAPI.getOpenGLDataType = function(vtkScalarType) {
    let forceUpdate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    if (!model.openGLDataType || forceUpdate) {
      model.openGLDataType = publicAPI.getDefaultDataType(vtkScalarType);
    }
    return model.openGLDataType;
  };
  publicAPI.getShiftAndScale = () => {
    let shift = 0;
    let scale7 = 1;
    switch (model.openGLDataType) {
      case model.context.BYTE:
        scale7 = 127.5;
        shift = scale7 - 128;
        break;
      case model.context.UNSIGNED_BYTE:
        scale7 = 255;
        shift = 0;
        break;
      case model.context.SHORT:
        scale7 = 32767.5;
        shift = scale7 - 32768;
        break;
      case model.context.UNSIGNED_SHORT:
        scale7 = 65536;
        shift = 0;
        break;
      case model.context.INT:
        scale7 = 21474836475e-1;
        shift = scale7 - 2147483648;
        break;
      case model.context.UNSIGNED_INT:
        scale7 = 4294967295;
        shift = 0;
        break;
      case model.context.FLOAT:
    }
    return {
      shift,
      scale: scale7
    };
  };
  publicAPI.getOpenGLFilterMode = (emode) => {
    switch (emode) {
      case Filter2.NEAREST:
        return model.context.NEAREST;
      case Filter2.LINEAR:
        return model.context.LINEAR;
      case Filter2.NEAREST_MIPMAP_NEAREST:
        return model.context.NEAREST_MIPMAP_NEAREST;
      case Filter2.NEAREST_MIPMAP_LINEAR:
        return model.context.NEAREST_MIPMAP_LINEAR;
      case Filter2.LINEAR_MIPMAP_NEAREST:
        return model.context.LINEAR_MIPMAP_NEAREST;
      case Filter2.LINEAR_MIPMAP_LINEAR:
        return model.context.LINEAR_MIPMAP_LINEAR;
      default:
        return model.context.NEAREST;
    }
  };
  publicAPI.getOpenGLWrapMode = (vtktype) => {
    switch (vtktype) {
      case Wrap2.CLAMP_TO_EDGE:
        return model.context.CLAMP_TO_EDGE;
      case Wrap2.REPEAT:
        return model.context.REPEAT;
      case Wrap2.MIRRORED_REPEAT:
        return model.context.MIRRORED_REPEAT;
      default:
        return model.context.CLAMP_TO_EDGE;
    }
  };
  function getExtentSize(extent2) {
    const [xmin, xmax, ymin, ymax, zmin, zmax] = extent2;
    return [xmax - xmin + 1, ymax - ymin + 1, zmax - zmin + 1];
  }
  function getExtentPixelCount(extent2) {
    const [sx, sy, sz] = getExtentSize(extent2);
    return sx * sy * sz;
  }
  function readExtentIntoArray(data, dataDims, extent2, outArray, outOffset) {
    const [xmin, xmax, ymin, ymax, zmin, zmax] = extent2;
    const [dx, dy] = dataDims;
    const sxy = dx * dy;
    let writeOffset = outOffset;
    for (let zi = zmin; zi <= zmax; zi++) {
      const zOffset = zi * sxy;
      for (let yi = ymin; yi <= ymax; yi++) {
        const zyOffset = zOffset + yi * dx;
        for (let readOffset = zyOffset + xmin, end = zyOffset + xmax; readOffset <= end; readOffset++, writeOffset++) {
          outArray[writeOffset] = data[readOffset];
        }
      }
    }
  }
  function readExtents(data, extents) {
    let typedArrayConstructor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    const constructor = typedArrayConstructor || data.constructor;
    const numPixels = extents.reduce((count2, extent2) => count2 + getExtentPixelCount(extent2), 0);
    const extentPixels = new constructor(numPixels);
    const dataDims = [model.width, model.height, model.depth];
    let writeOffset = 0;
    extents.forEach((extent2) => {
      readExtentIntoArray(data, dataDims, extent2, extentPixels, writeOffset);
      writeOffset += getExtentPixelCount(extent2);
    });
    return extentPixels;
  }
  publicAPI.updateArrayDataTypeForGL = function(dataType, data) {
    let depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    let imageExtents = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
    const pixData = [];
    let pixCount = model.width * model.height * model.components;
    if (depth) {
      pixCount *= model.depth;
    }
    const onlyUpdateExtents = !!imageExtents.length;
    if (dataType !== VtkDataTypes2.FLOAT && model.openGLDataType === model.context.FLOAT) {
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          if (onlyUpdateExtents) {
            pixData.push(readExtents(data[idx], imageExtents, Float32Array));
          } else {
            const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
            pixData.push(new Float32Array(dataArrayToCopy));
          }
        } else {
          pixData.push(null);
        }
      }
    }
    if (dataType !== VtkDataTypes2.UNSIGNED_CHAR && model.openGLDataType === model.context.UNSIGNED_BYTE) {
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          if (onlyUpdateExtents) {
            pixData.push(readExtents(data[idx], imageExtents, Uint8Array));
          } else {
            const dataArrayToCopy = data[idx].length > pixCount ? data[idx].subarray(0, pixCount) : data[idx];
            pixData.push(new Uint8Array(dataArrayToCopy));
          }
        } else {
          pixData.push(null);
        }
      }
    }
    let halfFloat = false;
    if (model._openGLRenderWindow.getWebgl2()) {
      halfFloat = model.openGLDataType === model.context.HALF_FLOAT;
    } else {
      const halfFloatExt = model.context.getExtension("OES_texture_half_float");
      halfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    }
    if (halfFloat) {
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx]) {
          const src = onlyUpdateExtents ? readExtents(data[idx], imageExtents) : data[idx];
          const newArray = new Uint16Array(onlyUpdateExtents ? src.length : pixCount);
          const newArrayLen = newArray.length;
          for (let i = 0; i < newArrayLen; i++) {
            newArray[i] = toHalf2(src[i]);
          }
          pixData.push(newArray);
        } else {
          pixData.push(null);
        }
      }
    }
    if (pixData.length === 0) {
      for (let i = 0; i < data.length; i++) {
        pixData.push(onlyUpdateExtents && data[i] ? readExtents(data[i], imageExtents) : data[i]);
      }
    }
    return pixData;
  };
  function scaleTextureToHighestPowerOfTwo(data) {
    if (model._openGLRenderWindow.getWebgl2()) {
      return data;
    }
    const pixData = [];
    const width = model.width;
    const height = model.height;
    const numComps = model.components;
    if (data && (!isPowerOfTwo(width) || !isPowerOfTwo(height))) {
      const halfFloat = model.context.getExtension("OES_texture_half_float");
      const newWidth = nearestPowerOfTwo(width);
      const newHeight = nearestPowerOfTwo(height);
      const pixCount = newWidth * newHeight * model.components;
      for (let idx = 0; idx < data.length; idx++) {
        if (data[idx] !== null) {
          let newArray = null;
          const jFactor = height / newHeight;
          const iFactor = width / newWidth;
          let usingHalf = false;
          if (model.openGLDataType === model.context.FLOAT) {
            newArray = new Float32Array(pixCount);
          } else if (halfFloat && model.openGLDataType === halfFloat.HALF_FLOAT_OES) {
            newArray = new Uint16Array(pixCount);
            usingHalf = true;
          } else {
            newArray = new Uint8Array(pixCount);
          }
          for (let j = 0; j < newHeight; j++) {
            const joff = j * newWidth * numComps;
            const jidx = j * jFactor;
            let jlow = Math.floor(jidx);
            let jhi = Math.ceil(jidx);
            if (jhi >= height) {
              jhi = height - 1;
            }
            const jmix = jidx - jlow;
            const jmix1 = 1 - jmix;
            jlow = jlow * width * numComps;
            jhi = jhi * width * numComps;
            for (let i = 0; i < newWidth; i++) {
              const ioff = i * numComps;
              const iidx = i * iFactor;
              let ilow = Math.floor(iidx);
              let ihi = Math.ceil(iidx);
              if (ihi >= width) {
                ihi = width - 1;
              }
              const imix = iidx - ilow;
              ilow *= numComps;
              ihi *= numComps;
              for (let c = 0; c < numComps; c++) {
                if (usingHalf) {
                  newArray[joff + ioff + c] = HalfFloat.toHalf(HalfFloat.fromHalf(data[idx][jlow + ilow + c]) * jmix1 * (1 - imix) + HalfFloat.fromHalf(data[idx][jlow + ihi + c]) * jmix1 * imix + HalfFloat.fromHalf(data[idx][jhi + ilow + c]) * jmix * (1 - imix) + HalfFloat.fromHalf(data[idx][jhi + ihi + c]) * jmix * imix);
                } else {
                  newArray[joff + ioff + c] = data[idx][jlow + ilow + c] * jmix1 * (1 - imix) + data[idx][jlow + ihi + c] * jmix1 * imix + data[idx][jhi + ilow + c] * jmix * (1 - imix) + data[idx][jhi + ihi + c] * jmix * imix;
                }
              }
            }
          }
          pixData.push(newArray);
          model.width = newWidth;
          model.height = newHeight;
        } else {
          pixData.push(null);
        }
      }
    }
    if (pixData.length === 0) {
      for (let i = 0; i < data.length; i++) {
        pixData.push(data[i]);
      }
    }
    return pixData;
  }
  function useTexStorage(dataType) {
    var _a;
    if (model._openGLRenderWindow) {
      if (model.resizable || ((_a = model.renderable) == null ? void 0 : _a.getResizable())) {
        return false;
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        const webGLInfo = model._openGLRenderWindow.getGLInformations();
        if (webGLInfo.RENDERER.value.match(/WebKit/gi) && navigator.platform.match(/Mac/gi) && getNorm16Ext() && (dataType === VtkDataTypes2.UNSIGNED_SHORT || dataType === VtkDataTypes2.SHORT)) {
          return false;
        }
        return true;
      }
      return false;
    }
    return false;
  }
  publicAPI.create2DFromRaw = function() {
    let {
      width = requiredParam("width"),
      height = requiredParam("height"),
      numComps = requiredParam("numComps"),
      dataType = requiredParam("dataType"),
      data = requiredParam("data"),
      flip = false
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    publicAPI.getOpenGLDataType(dataType, true);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro3("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    const dataArray = [data];
    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, dataArray);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flip);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (scaledData[0] != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, scaledData[0]);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, scaledData[0]);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    if (flip) {
      model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, false);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };
  publicAPI.createCubeFromRaw = function() {
    let {
      width = requiredParam("width"),
      height = requiredParam("height"),
      numComps = requiredParam("numComps"),
      dataType = requiredParam("dataType"),
      data = requiredParam("data")
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    publicAPI.getOpenGLDataType(dataType);
    publicAPI.getInternalFormat(dataType, numComps);
    publicAPI.getFormat(dataType, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro3("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_CUBE_MAP;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    model.maxLevel = data.length / 6 - 1;
    publicAPI.createTexture();
    publicAPI.bind();
    const pixData = publicAPI.updateArrayDataTypeForGL(dataType, data);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    const invertedData = [];
    let widthLevel = model.width;
    let heightLevel = model.height;
    for (let i = 0; i < scaledData.length; i++) {
      if (i % 6 === 0 && i !== 0) {
        widthLevel /= 2;
        heightLevel /= 2;
      }
      invertedData[i] = newTypedArray(dataType, heightLevel * widthLevel * model.components);
      for (let y = 0; y < heightLevel; ++y) {
        const row1 = y * widthLevel * model.components;
        const row2 = (heightLevel - y - 1) * widthLevel * model.components;
        invertedData[i].set(scaledData[i].slice(row2, row2 + widthLevel * model.components), row1);
      }
    }
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 6, model.internalFormat, model.width, model.height);
    }
    for (let i = 0; i < 6; i++) {
      let j = 0;
      let w = model.width;
      let h = model.height;
      while (w >= 1 && h >= 1) {
        let tempData = null;
        if (j <= model.maxLevel) {
          tempData = invertedData[6 * j + i];
        }
        if (useTexStorage(dataType)) {
          if (tempData != null) {
            model.context.texSubImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, w, h, model.format, model.openGLDataType, tempData);
          }
        } else {
          model.context.texImage2D(model.context.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, model.internalFormat, w, h, 0, model.format, model.openGLDataType, tempData);
        }
        j++;
        w /= 2;
        h /= 2;
      }
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * numComps * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };
  publicAPI.createDepthFromRaw = function() {
    let {
      width = requiredParam("width"),
      height = requiredParam("height"),
      dataType = requiredParam("dataType"),
      data = requiredParam("data")
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    publicAPI.getOpenGLDataType(dataType);
    model.format = model.context.DEPTH_COMPONENT;
    if (model._openGLRenderWindow.getWebgl2()) {
      if (dataType === VtkDataTypes2.FLOAT) {
        model.internalFormat = model.context.DEPTH_COMPONENT32F;
      } else {
        model.internalFormat = model.context.DEPTH_COMPONENT16;
      }
    } else {
      model.internalFormat = model.context.DEPTH_COMPONENT;
    }
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro3("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 1;
    model.width = width;
    model.height = height;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataType)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (data != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, data);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, data);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataType, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };
  publicAPI.create2DFromImage = (image) => {
    publicAPI.getOpenGLDataType(VtkDataTypes2.UNSIGNED_CHAR);
    publicAPI.getInternalFormat(VtkDataTypes2.UNSIGNED_CHAR, 4);
    publicAPI.getFormat(VtkDataTypes2.UNSIGNED_CHAR, 4);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro3("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 4;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    const needNearestPowerOfTwo = !model._openGLRenderWindow.getWebgl2() && (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height));
    let textureSource = image;
    let targetWidth = image.width;
    let targetHeight = image.height;
    let flipY = true;
    const isChrome = window.chrome;
    if (needNearestPowerOfTwo || isChrome) {
      const canvas = new OffscreenCanvas(nearestPowerOfTwo(image.width), nearestPowerOfTwo(image.height));
      targetWidth = canvas.width;
      targetHeight = canvas.height;
      const ctx = canvas.getContext("2d");
      ctx.translate(0, canvas.height);
      ctx.scale(1, -1);
      ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
      textureSource = canvas;
      flipY = false;
    }
    model.width = targetWidth;
    model.height = targetHeight;
    model.context.pixelStorei(model.context.UNPACK_FLIP_Y_WEBGL, flipY);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(VtkDataTypes2.UNSIGNED_CHAR)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, textureSource);
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, textureSource);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes2.UNSIGNED_CHAR, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };
  publicAPI.create2DFromImageBitmap = (imageBitmap) => {
    publicAPI.getOpenGLDataType(VtkDataTypes2.UNSIGNED_CHAR);
    publicAPI.getInternalFormat(VtkDataTypes2.UNSIGNED_CHAR, 4);
    publicAPI.getFormat(VtkDataTypes2.UNSIGNED_CHAR, 4);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro3("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = 4;
    model.depth = 1;
    model.numberOfDimensions = 2;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    model.width = imageBitmap.width;
    model.height = imageBitmap.height;
    if (useTexStorage(VtkDataTypes2.UNSIGNED_CHAR)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, imageBitmap);
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, imageBitmap);
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(VtkDataTypes2.UNSIGNED_CHAR, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };
  function computeScaleOffsets(min4, max4, numComps) {
    const offset = new Array(numComps);
    const scale7 = new Array(numComps);
    for (let c = 0; c < numComps; ++c) {
      offset[c] = min4[c];
      scale7[c] = max4[c] - min4[c] || 1;
    }
    return {
      scale: scale7,
      offset
    };
  }
  function hasExactHalfFloat(offset, scale7) {
    for (let c = 0; c < offset.length; c++) {
      const min4 = offset[c];
      const max4 = scale7[c] + min4;
      if (min4 < -2048 || min4 > 2048 || max4 < -2048 || max4 > 2048) {
        return false;
      }
    }
    return true;
  }
  function setCanUseHalfFloat(dataType, offset, scale7, preferSizeOverAccuracy) {
    publicAPI.getOpenGLDataType(dataType);
    const isExactHalfFloat = hasExactHalfFloat(offset, scale7) || preferSizeOverAccuracy;
    let useHalfFloat = false;
    if (model._openGLRenderWindow.getWebgl2()) {
      const forceHalfFloat = model.openGLDataType === model.context.FLOAT && model.context.getExtension("OES_texture_float_linear") === null && isExactHalfFloat;
      useHalfFloat = forceHalfFloat || model.openGLDataType === model.context.HALF_FLOAT;
    } else {
      const halfFloatExt = model.context.getExtension("OES_texture_half_float");
      useHalfFloat = halfFloatExt && model.openGLDataType === halfFloatExt.HALF_FLOAT_OES;
    }
    model.canUseHalfFloat = useHalfFloat && isExactHalfFloat;
  }
  function processDataArray(dataArray, preferSizeOverAccuracy) {
    const numComps = dataArray.getNumberOfComponents();
    const dataType = dataArray.getDataType();
    const data = dataArray.getData();
    const minArray = new Array(numComps);
    const maxArray = new Array(numComps);
    for (let c = 0; c < numComps; ++c) {
      const [min4, max4] = dataArray.getRange(c);
      minArray[c] = min4;
      maxArray[c] = max4;
    }
    const scaleOffsets = computeScaleOffsets(minArray, maxArray, numComps);
    setCanUseHalfFloat(dataType, scaleOffsets.offset, scaleOffsets.scale, preferSizeOverAccuracy);
    if (!publicAPI.useHalfFloat()) {
      publicAPI.getOpenGLDataType(dataType, true);
    }
    return {
      numComps,
      dataType,
      data,
      scaleOffsets
    };
  }
  publicAPI.create2DFilterableFromRaw = function() {
    let {
      width = requiredParam("width"),
      height = requiredParam("height"),
      numComps = requiredParam("numComps"),
      dataType = requiredParam("dataType"),
      data = requiredParam("data"),
      preferSizeOverAccuracy = false,
      ranges = void 0
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return publicAPI.create2DFilterableFromDataArray({
      width,
      height,
      dataArray: vtkDataArray$1.newInstance({
        numberOfComponents: numComps,
        dataType,
        values: data,
        ranges
      }),
      preferSizeOverAccuracy
    });
  };
  publicAPI.create2DFilterableFromDataArray = function() {
    let {
      width = requiredParam("width"),
      height = requiredParam("height"),
      dataArray = requiredParam("dataArray"),
      preferSizeOverAccuracy = false
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      numComps,
      dataType,
      data
    } = processDataArray(dataArray, preferSizeOverAccuracy);
    publicAPI.create2DFromRaw({
      width,
      height,
      numComps,
      dataType,
      data
    });
  };
  publicAPI.updateVolumeInfoForGL = (dataType, numComps) => {
    var _a, _b;
    let isScalingApplied = false;
    const useHalfFloat = publicAPI.useHalfFloat();
    if (!((_a = model.volumeInfo) == null ? void 0 : _a.scale) || !((_b = model.volumeInfo) == null ? void 0 : _b.offset)) {
      model.volumeInfo = {
        scale: new Array(numComps),
        offset: new Array(numComps)
      };
    }
    for (let c = 0; c < numComps; ++c) {
      model.volumeInfo.scale[c] = 1;
      model.volumeInfo.offset[c] = 0;
    }
    if (getNorm16Ext() && !useHalfFloat && dataType === VtkDataTypes2.SHORT) {
      for (let c = 0; c < numComps; ++c) {
        model.volumeInfo.scale[c] = 32767;
      }
      isScalingApplied = true;
    }
    if (getNorm16Ext() && !useHalfFloat && dataType === VtkDataTypes2.UNSIGNED_SHORT) {
      for (let c = 0; c < numComps; ++c) {
        model.volumeInfo.scale[c] = 65535;
      }
      isScalingApplied = true;
    }
    if (dataType === VtkDataTypes2.UNSIGNED_CHAR) {
      for (let c = 0; c < numComps; ++c) {
        model.volumeInfo.scale[c] = 255;
      }
      isScalingApplied = true;
    }
    if (dataType === VtkDataTypes2.FLOAT || useHalfFloat && (dataType === VtkDataTypes2.SHORT || dataType === VtkDataTypes2.UNSIGNED_SHORT)) {
      isScalingApplied = true;
    }
    return isScalingApplied;
  };
  publicAPI.create3DFromRaw = function() {
    let {
      width = requiredParam("width"),
      height = requiredParam("height"),
      depth = requiredParam("depth"),
      numComps = requiredParam("numComps"),
      dataType = requiredParam("dataType"),
      data = requiredParam("data"),
      updatedExtents = []
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let dataTypeToUse = dataType;
    let dataToUse = data;
    if (!publicAPI.updateVolumeInfoForGL(dataTypeToUse, numComps) && dataToUse) {
      const numPixelsIn = width * height * depth;
      const scaleOffsetsCopy = structuredClone(model.volumeInfo);
      const newArray = new Float32Array(numPixelsIn * numComps);
      model.volumeInfo.offset = scaleOffsetsCopy.offset;
      model.volumeInfo.scale = scaleOffsetsCopy.scale;
      let count2 = 0;
      const scaleInverse = scaleOffsetsCopy.scale.map((s) => 1 / s);
      for (let i = 0; i < numPixelsIn; i++) {
        for (let nc = 0; nc < numComps; nc++) {
          newArray[count2] = (dataToUse[count2] - scaleOffsetsCopy.offset[nc]) * scaleInverse[nc];
          count2++;
        }
      }
      dataTypeToUse = VtkDataTypes2.FLOAT;
      dataToUse = newArray;
    }
    publicAPI.getOpenGLDataType(dataTypeToUse);
    publicAPI.getInternalFormat(dataTypeToUse, numComps);
    publicAPI.getFormat(dataTypeToUse, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro3("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_3D;
    model.components = numComps;
    model.width = width;
    model.height = height;
    model.depth = depth;
    model.numberOfDimensions = 3;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    const hasUpdatedExtents = updatedExtents.length > 0;
    const rebuildEntireTexture = !hasUpdatedExtents || !(0, import_fast_deep_equal.default)(model._prevTexParams, getTexParams());
    const dataArray = [dataToUse];
    const is3DArray = true;
    const pixData = publicAPI.updateArrayDataTypeForGL(dataTypeToUse, dataArray, is3DArray, rebuildEntireTexture ? [] : updatedExtents);
    const scaledData = scaleTextureToHighestPowerOfTwo(pixData);
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (rebuildEntireTexture) {
      if (useTexStorage(dataTypeToUse)) {
        model.context.texStorage3D(model.target, 1, model.internalFormat, model.width, model.height, model.depth);
        if (scaledData[0] != null) {
          model.context.texSubImage3D(model.target, 0, 0, 0, 0, model.width, model.height, model.depth, model.format, model.openGLDataType, scaledData[0]);
        }
      } else {
        model.context.texImage3D(model.target, 0, model.internalFormat, model.width, model.height, model.depth, 0, model.format, model.openGLDataType, scaledData[0]);
      }
      model._prevTexParams = getTexParams();
    } else if (hasUpdatedExtents) {
      const extentPixels = scaledData[0];
      let readOffset = 0;
      for (let i = 0; i < updatedExtents.length; i++) {
        const extent2 = updatedExtents[i];
        const extentSize = getExtentSize(extent2);
        const extentPixelCount = getExtentPixelCount(extent2);
        const textureData = new extentPixels.constructor(extentPixels.buffer, readOffset, extentPixelCount);
        readOffset += textureData.byteLength;
        model.context.texSubImage3D(model.target, 0, extent2[0], extent2[2], extent2[4], extentSize[0], extentSize[1], extentSize[2], model.format, model.openGLDataType, textureData);
      }
    }
    if (model.generateMipmap) {
      model.context.generateMipmap(model.target);
    }
    model.allocatedGPUMemoryInBytes = model.width * model.height * model.depth * model.components * model._openGLRenderWindow.getDefaultTextureByteSize(dataTypeToUse, getNorm16Ext(), publicAPI.useHalfFloat());
    publicAPI.deactivate();
    return true;
  };
  publicAPI.create3DFilterableFromRaw = function() {
    let {
      width = requiredParam("width"),
      height = requiredParam("height"),
      depth = requiredParam("depth"),
      numComps = requiredParam("numComps"),
      dataType = requiredParam("dataType"),
      data = requiredParam("data"),
      preferSizeOverAccuracy = false,
      ranges = void 0,
      updatedExtents = []
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return publicAPI.create3DFilterableFromDataArray({
      width,
      height,
      depth,
      dataArray: vtkDataArray$1.newInstance({
        numberOfComponents: numComps,
        dataType,
        values: data,
        ranges
      }),
      preferSizeOverAccuracy,
      updatedExtents
    });
  };
  publicAPI.create3DFilterableFromDataArray = function() {
    let {
      width = requiredParam("width"),
      height = requiredParam("height"),
      depth = requiredParam("depth"),
      dataArray = requiredParam("dataArray"),
      preferSizeOverAccuracy = false,
      updatedExtents = []
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      numComps,
      dataType,
      data,
      scaleOffsets
    } = processDataArray(dataArray, preferSizeOverAccuracy);
    const offset = [];
    const scale7 = [];
    for (let c = 0; c < numComps; ++c) {
      offset[c] = 0;
      scale7[c] = 1;
    }
    model.volumeInfo = {
      scale: scale7,
      offset,
      dataComputedScale: scaleOffsets.scale,
      dataComputedOffset: scaleOffsets.offset,
      width,
      height,
      depth
    };
    if (model._openGLRenderWindow.getWebgl2()) {
      return publicAPI.create3DFromRaw({
        width,
        height,
        depth,
        numComps,
        dataType,
        data,
        updatedExtents
      });
    }
    const numPixelsIn = width * height * depth;
    const scaleOffsetsCopy = structuredClone(scaleOffsets);
    let volCopyData = (outArray, outIdx2, inValue, smin, smax) => {
      outArray[outIdx2] = inValue;
    };
    let dataTypeToUse = VtkDataTypes2.UNSIGNED_CHAR;
    if (dataType === VtkDataTypes2.UNSIGNED_CHAR) {
      for (let c = 0; c < numComps; ++c) {
        scaleOffsetsCopy.offset[c] = 0;
        scaleOffsetsCopy.scale[c] = 255;
      }
    } else if (model.context.getExtension("OES_texture_float") && model.context.getExtension("OES_texture_float_linear")) {
      dataTypeToUse = VtkDataTypes2.FLOAT;
      volCopyData = (outArray, outIdx2, inValue, soffset, sscale) => {
        outArray[outIdx2] = (inValue - soffset) / sscale;
      };
    } else {
      dataTypeToUse = VtkDataTypes2.UNSIGNED_CHAR;
      volCopyData = (outArray, outIdx2, inValue, soffset, sscale) => {
        outArray[outIdx2] = 255 * (inValue - soffset) / sscale;
      };
    }
    publicAPI.getOpenGLDataType(dataTypeToUse);
    publicAPI.getInternalFormat(dataTypeToUse, numComps);
    publicAPI.getFormat(dataTypeToUse, numComps);
    if (!model.internalFormat || !model.format || !model.openGLDataType) {
      vtkErrorMacro3("Failed to determine texture parameters.");
      return false;
    }
    model.target = model.context.TEXTURE_2D;
    model.components = numComps;
    model.depth = 1;
    model.numberOfDimensions = 2;
    let maxTexDim = model.context.getParameter(model.context.MAX_TEXTURE_SIZE);
    if (maxTexDim > 4096 && (dataTypeToUse === VtkDataTypes2.FLOAT || numComps >= 3)) {
      maxTexDim = 4096;
    }
    let xstride = 1;
    let ystride = 1;
    if (numPixelsIn > maxTexDim * maxTexDim) {
      xstride = Math.ceil(Math.sqrt(numPixelsIn / (maxTexDim * maxTexDim)));
      ystride = xstride;
    }
    let targetWidth = Math.sqrt(numPixelsIn) / xstride;
    targetWidth = nearestPowerOfTwo(targetWidth);
    const xreps = Math.floor(targetWidth * xstride / width);
    const yreps = Math.ceil(depth / xreps);
    const targetHeight = nearestPowerOfTwo(height * yreps / ystride);
    model.width = targetWidth;
    model.height = targetHeight;
    model._openGLRenderWindow.activateTexture(publicAPI);
    publicAPI.createTexture();
    publicAPI.bind();
    model.volumeInfo.xreps = xreps;
    model.volumeInfo.yreps = yreps;
    model.volumeInfo.xstride = xstride;
    model.volumeInfo.ystride = ystride;
    model.volumeInfo.offset = scaleOffsetsCopy.offset;
    model.volumeInfo.scale = scaleOffsetsCopy.scale;
    let newArray;
    const pixCount = targetWidth * targetHeight * numComps;
    if (dataTypeToUse === VtkDataTypes2.FLOAT) {
      newArray = new Float32Array(pixCount);
    } else {
      newArray = new Uint8Array(pixCount);
    }
    let outIdx = 0;
    const tileWidth = Math.floor(width / xstride);
    const tileHeight = Math.floor(height / ystride);
    for (let yRep = 0; yRep < yreps; yRep++) {
      const xrepsThisRow = Math.min(xreps, depth - yRep * xreps);
      const outXContIncr = numComps * (model.width - xrepsThisRow * Math.floor(width / xstride));
      for (let tileY = 0; tileY < tileHeight; tileY++) {
        for (let xRep = 0; xRep < xrepsThisRow; xRep++) {
          const inOffset = numComps * ((yRep * xreps + xRep) * width * height + ystride * tileY * width);
          for (let tileX = 0; tileX < tileWidth; tileX++) {
            for (let nc = 0; nc < numComps; nc++) {
              volCopyData(newArray, outIdx, data[inOffset + xstride * tileX * numComps + nc], scaleOffsetsCopy.offset[nc], scaleOffsetsCopy.scale[nc]);
              outIdx++;
            }
          }
        }
        outIdx += outXContIncr;
      }
    }
    model.context.pixelStorei(model.context.UNPACK_ALIGNMENT, 1);
    if (useTexStorage(dataTypeToUse)) {
      model.context.texStorage2D(model.target, 1, model.internalFormat, model.width, model.height);
      if (newArray != null) {
        model.context.texSubImage2D(model.target, 0, 0, 0, model.width, model.height, model.format, model.openGLDataType, newArray);
      }
    } else {
      model.context.texImage2D(model.target, 0, model.internalFormat, model.width, model.height, 0, model.format, model.openGLDataType, newArray);
    }
    publicAPI.deactivate();
    return true;
  };
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.getMaximumTextureSize = (ctx) => {
    if (ctx && ctx.isCurrent()) {
      return ctx.getIntegerv(ctx.MAX_TEXTURE_SIZE);
    }
    return -1;
  };
  publicAPI.enableUseHalfFloat = (use) => {
    model.enableUseHalfFloat = use;
  };
}
var DEFAULT_VALUES4 = {
  _openGLRenderWindow: null,
  _forceInternalFormat: false,
  _prevTexParams: null,
  context: null,
  handle: 0,
  sendParametersTime: null,
  textureBuildTime: null,
  numberOfDimensions: 0,
  target: 0,
  format: 0,
  openGLDataType: 0,
  components: 0,
  width: 0,
  height: 0,
  depth: 0,
  autoParameters: true,
  wrapS: Wrap2.CLAMP_TO_EDGE,
  wrapT: Wrap2.CLAMP_TO_EDGE,
  wrapR: Wrap2.CLAMP_TO_EDGE,
  minificationFilter: Filter2.NEAREST,
  magnificationFilter: Filter2.NEAREST,
  minLOD: -1e3,
  maxLOD: 1e3,
  baseLevel: 0,
  maxLevel: 1e3,
  generateMipmap: false,
  oglNorm16Ext: null,
  allocatedGPUMemoryInBytes: 0,
  // by default it is enabled
  enableUseHalfFloat: true,
  // but by default we don't know if we can use half float base on the data range
  canUseHalfFloat: false
};
function extend4(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES4, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.sendParametersTime = {};
  obj(model.sendParametersTime, {
    mtime: 0
  });
  model.textureBuildTime = {};
  obj(model.textureBuildTime, {
    mtime: 0
  });
  set(publicAPI, model, ["format", "openGLDataType"]);
  setGet(publicAPI, model, ["keyMatrixTime", "minificationFilter", "magnificationFilter", "wrapS", "wrapT", "wrapR", "generateMipmap", "oglNorm16Ext"]);
  get(publicAPI, model, ["width", "height", "volumeInfo", "components", "handle", "target", "allocatedGPUMemoryInBytes"]);
  moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkOpenGLTexture(publicAPI, model);
}
var newInstance5 = newInstance(extend4, "vtkOpenGLTexture");
var vtkOpenGLTexture$1 = {
  newInstance: newInstance5,
  extend: extend4,
  ...Constants
};
registerOverride("vtkTexture", newInstance5);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Sampler.js
function vtkWebGPUSampler(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUSampler");
  publicAPI.create = function(device) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    model.device = device;
    model.options.addressModeU = options.addressModeU ? options.addressModeU : "clamp-to-edge";
    model.options.addressModeV = options.addressModeV ? options.addressModeV : "clamp-to-edge";
    model.options.addressModeW = options.addressModeW ? options.addressModeW : "clamp-to-edge";
    model.options.magFilter = options.magFilter ? options.magFilter : "nearest";
    model.options.minFilter = options.minFilter ? options.minFilter : "nearest";
    model.options.mipmapFilter = options.mipmapFilter ? options.mipmapFilter : "nearest";
    model.options.label = model.label;
    model.handle = model.device.getHandle().createSampler(model.options);
    model.bindGroupTime.modified();
  };
  publicAPI.getShaderCode = (binding, group2) => {
    const result = `@binding(${binding}) @group(${group2}) var ${model.label}: sampler;`;
    return result;
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: model.handle
    };
    return foo;
  };
}
var DEFAULT_VALUES5 = {
  device: null,
  handle: null,
  label: null,
  options: null
};
function extend5(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES5, initialValues);
  macro.obj(publicAPI, model);
  model.options = {};
  model.bindGroupLayoutEntry = {
    /* eslint-disable no-undef */
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    /* eslint-enable no-undef */
    sampler: {
      // type: 'filtering',
    }
  };
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "handle", "options"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "device", "label"]);
  vtkWebGPUSampler(publicAPI, model);
}
var newInstance6 = macro.newInstance(extend5);
var vtkWebGPUSampler$1 = {
  newInstance: newInstance6,
  extend: extend5
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Types.js
var textureDetails = {
  // 8-bit formats
  r8unorm: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "float"
  },
  r8snorm: {
    numComponents: 1,
    nativeType: Int8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "float"
  },
  r8uint: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "uint"
  },
  r8sint: {
    numComponents: 1,
    nativeType: Int8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "sint"
  },
  // 16-bit formats
  r16uint: {
    numComponents: 1,
    nativeType: Uint16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "uint"
  },
  r16sint: {
    numComponents: 1,
    nativeType: Int16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "sint"
  },
  r16float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 2,
    elementSize: 2,
    sampleType: "float"
  },
  rg8unorm: {
    numComponents: 2,
    nativeType: Uint8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "float"
  },
  rg8snorm: {
    numComponents: 2,
    nativeType: Int8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "float"
  },
  rg8uint: {
    numComponents: 2,
    nativeType: Uint8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "uint"
  },
  rg8sint: {
    numComponents: 2,
    nativeType: Int8Array,
    stride: 2,
    elementSize: 1,
    sampleType: "sint"
  },
  // 32-bit formats
  r32uint: {
    numComponents: 1,
    nativeType: Uint32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "uint"
  },
  r32sint: {
    numComponents: 1,
    nativeType: Int32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "sint"
  },
  r32float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  rg16uint: {
    numComponents: 2,
    nativeType: Uint16Array,
    stride: 4,
    elementSize: 2,
    sampleType: "uint"
  },
  rg16sint: {
    numComponents: 2,
    nativeType: Int16Array,
    stride: 4,
    elementSize: 2,
    sampleType: "sint"
  },
  rg16float: {
    numComponents: 2,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 2,
    sampleType: "float"
  },
  rgba8unorm: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  "rgba8unorm-srgb": {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  rgba8snorm: {
    numComponents: 4,
    nativeType: Int8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  rgba8uint: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "uint"
  },
  rgba8sint: {
    numComponents: 4,
    nativeType: Int8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "sint"
  },
  bgra8unorm: {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  "bgra8unorm-srgb": {
    numComponents: 4,
    nativeType: Uint8Array,
    stride: 4,
    elementSize: 1,
    sampleType: "float"
  },
  // Packed 32-bit formats
  rgb9e5ufloat: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "float"
  },
  rgb10a2unorm: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "float"
  },
  rg11b10ufloat: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 4,
    sampleType: "float"
  },
  // 64-bit formats
  rg32uint: {
    numComponents: 2,
    nativeType: Uint32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "uint"
  },
  rg32sint: {
    numComponents: 2,
    nativeType: Int32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "sint"
  },
  rg32float: {
    numComponents: 2,
    nativeType: Float32Array,
    stride: 8,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  rgba16uint: {
    numComponents: 4,
    nativeType: Uint16Array,
    stride: 8,
    elementSize: 2,
    sampleType: "uint"
  },
  rgba16sint: {
    numComponents: 4,
    nativeType: Int16Array,
    stride: 8,
    elementSize: 2,
    sampleType: "sint"
  },
  rgba16float: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 8,
    elementSize: 2,
    sampleType: "float"
  },
  // 128-bit formats
  rgba32uint: {
    numComponents: 4,
    nativeType: Uint32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "uint"
  },
  rgba32sint: {
    numComponents: 4,
    nativeType: Int32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "sint"
  },
  rgba32float: {
    numComponents: 4,
    nativeType: Float32Array,
    stride: 16,
    elementSize: 4,
    sampleType: "unfilterable-float"
  },
  // Depth and stencil formats
  stencil8: {
    numComponents: 1,
    nativeType: Uint8Array,
    stride: 1,
    elementSize: 1,
    sampleType: "uint"
  },
  depth16unorm: {
    numComponents: 1,
    nativeType: Uint16Array,
    stride: 2,
    elementSize: 2,
    sampleType: "depth"
  },
  depth24plus: {
    numComponents: 1,
    nativeType: Uint32Array,
    stride: 4,
    elementSize: 3,
    sampleType: "depth"
  },
  "depth24plus-stencil8": {
    numComponents: 2,
    nativeType: Uint32Array,
    stride: 4,
    sampleType: "mixed"
  },
  depth32float: {
    numComponents: 1,
    nativeType: Float32Array,
    stride: 4,
    elementSize: 4,
    sampleType: "depth"
  }
};
function getDetailsFromTextureFormat(format2) {
  if (!format2 || format2.length < 6)
    return 0;
  if (format2 in textureDetails === true) {
    return textureDetails[format2];
  }
  vtkErrorMacro(`unknown format ${format2}`);
  return null;
}
function getByteStrideFromBufferFormat(format2) {
  if (!format2 || format2.length < 5)
    return 0;
  let numComp = 1;
  if (format2[format2.length - 2] === "x") {
    numComp = Number(format2[format2.length - 1]);
  }
  const sizeStart = numComp === 1 ? format2.length - 1 : format2.length - 3;
  const num = Number(format2[sizeStart]);
  if (Number.isNaN(num)) {
    vtkErrorMacro(`unknown format ${format2}`);
    return 0;
  }
  const typeSize = 5 - num / 2;
  return numComp * typeSize;
}
function getNumberOfComponentsFromBufferFormat(format2) {
  if (!format2 || format2.length < 5)
    return 0;
  let numComp = 1;
  if (format2[format2.length - 2] === "x") {
    numComp = Number(format2[format2.length - 1]);
  }
  return numComp;
}
function getNativeTypeFromBufferFormat(format2) {
  if (!format2 || format2.length < 5)
    return 0;
  let result;
  if (format2[0] === "f") {
    result = "Float";
  } else if (format2[0] === "s") {
    result = "Int";
  } else if (format2[0] === "u") {
    result = "Uint";
  } else {
    vtkErrorMacro(`unknown format ${format2}`);
    return void 0;
  }
  const base = format2.split("x")[0];
  const num = Number(base[base.length - 1]);
  if (Number.isNaN(num)) {
    vtkErrorMacro(`unknown format ${format2}`);
    return void 0;
  }
  result += 8 * (5 - num / 2);
  result += "Array";
  return result;
}
function getShaderTypeFromBufferFormat(format2) {
  let dataType;
  if (format2[0] === "f" || format2[1] === "n") {
    dataType = "f32";
  } else if (format2[0] === "s" && format2[1] === "i") {
    dataType = "i32";
  } else if (format2[0] === "u" && format2[1] === "i") {
    dataType = "u32";
  } else {
    vtkErrorMacro(`unknown format ${format2}`);
    return void 0;
  }
  let numComp = 1;
  if (format2[format2.length - 2] === "x") {
    numComp = Number(format2[format2.length - 1]);
  }
  if (numComp === 4)
    return `vec4<${dataType}>`;
  if (numComp === 3)
    return `vec3<${dataType}>`;
  if (numComp === 2)
    return `vec2<${dataType}>`;
  return dataType;
}
function getByteStrideFromShaderFormat(format2) {
  if (!format2)
    return 0;
  let numComp = 1;
  if (format2.substring(0, 3) === "vec") {
    numComp = Number(format2[3]);
  } else if (format2.substring(0, 3) === "mat") {
    numComp = format2[3] * format2[5];
  }
  const typeSize = 4;
  return numComp * typeSize;
}
function getNativeTypeFromShaderFormat(format2) {
  if (!format2)
    return void 0;
  if (format2.includes("f32"))
    return "Float32Array";
  if (format2.includes("i32"))
    return "Int32Array";
  if (format2.includes("u32"))
    return "Uint32Array";
  vtkErrorMacro(`unknown format ${format2}`);
  return void 0;
}
var vtkWebGPUTypes = {
  getDetailsFromTextureFormat,
  getByteStrideFromBufferFormat,
  getNumberOfComponentsFromBufferFormat,
  getNativeTypeFromBufferFormat,
  getShaderTypeFromBufferFormat,
  getByteStrideFromShaderFormat,
  getNativeTypeFromShaderFormat
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/TextureView.js
function vtkWebGPUTextureView(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUTextureView");
  publicAPI.create = (texture, options) => {
    model.texture = texture;
    model.options = options;
    model.options.dimension = model.options.dimension || "2d";
    model.options.label = model.label;
    model.textureHandle = texture.getHandle();
    model.handle = model.textureHandle.createView(model.options);
    model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.texture.getFormat());
    model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
  };
  publicAPI.createFromTextureHandle = (textureHandle, options) => {
    model.texture = null;
    model.options = options;
    model.options.dimension = model.options.dimension || "2d";
    model.options.label = model.label;
    model.textureHandle = textureHandle;
    model.handle = model.textureHandle.createView(model.options);
    model.bindGroupLayoutEntry.texture.viewDimension = model.options.dimension;
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(options.format);
    model.bindGroupLayoutEntry.texture.sampleType = tDetails.sampleType;
    model.bindGroupTime.modified();
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: publicAPI.getHandle()
    };
    return foo;
  };
  publicAPI.getShaderCode = (binding, group2) => {
    let ttype = "f32";
    if (model.bindGroupLayoutEntry.texture.sampleType === "sint") {
      ttype = "i32";
    } else if (model.bindGroupLayoutEntry.texture.sampleType === "uint") {
      ttype = "u32";
    }
    let result = `@binding(${binding}) @group(${group2}) var ${model.label}: texture_${model.options.dimension}<${ttype}>;`;
    if (model.bindGroupLayoutEntry.texture.sampleType === "depth") {
      result = `@binding(${binding}) @group(${group2}) var ${model.label}: texture_depth_${model.options.dimension};`;
    }
    return result;
  };
  publicAPI.addSampler = (device, options) => {
    const newSamp = vtkWebGPUSampler$1.newInstance({
      label: `${model.label}Sampler`
    });
    newSamp.create(device, options);
    publicAPI.setSampler(newSamp);
  };
  publicAPI.getBindGroupTime = () => {
    if (model.texture && model.texture.getHandle() !== model.textureHandle) {
      model.textureHandle = model.texture.getHandle();
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupTime.modified();
    }
    return model.bindGroupTime;
  };
  publicAPI.getHandle = () => {
    if (model.texture && model.texture.getHandle() !== model.textureHandle) {
      model.textureHandle = model.texture.getHandle();
      model.handle = model.textureHandle.createView(model.options);
      model.bindGroupTime.modified();
    }
    return model.handle;
  };
}
var DEFAULT_VALUES6 = {
  texture: null,
  handle: null,
  sampler: null,
  label: null
};
function extend6(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES6, initialValues);
  macro.obj(publicAPI, model);
  model.bindGroupLayoutEntry = {
    /* eslint-disable no-undef */
    visibility: GPUShaderStage.VERTEX | GPUShaderStage.FRAGMENT,
    /* eslint-enable no-undef */
    texture: {
      sampleType: "float",
      viewDimension: "2d"
      // multisampled: false,
    }
  };
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "texture"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "label", "sampler"]);
  vtkWebGPUTextureView(publicAPI, model);
}
var newInstance7 = macro.newInstance(extend6);
var vtkWebGPUTextureView$1 = {
  newInstance: newInstance7,
  extend: extend6
};

// node_modules/@kitware/vtk.js/Rendering/Core/Texture.js
function vtkTexture(publicAPI, model) {
  model.classHierarchy.push("vtkTexture");
  publicAPI.imageLoaded = () => {
    model.image.removeEventListener("load", publicAPI.imageLoaded);
    model.imageLoaded = true;
    publicAPI.modified();
  };
  publicAPI.setJsImageData = (imageData) => {
    if (model.jsImageData === imageData) {
      return;
    }
    if (imageData !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.image = null;
      model.canvas = null;
      model.imageBitmap = null;
    }
    model.jsImageData = imageData;
    model.imageLoaded = true;
    publicAPI.modified();
  };
  publicAPI.setImageBitmap = (imageBitmap) => {
    if (model.imageBitmap === imageBitmap) {
      return;
    }
    if (imageBitmap !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.image = null;
      model.canvas = null;
      model.jsImageData = null;
    }
    model.imageBitmap = imageBitmap;
    model.imageLoaded = true;
    publicAPI.modified();
  };
  publicAPI.setCanvas = (canvas) => {
    if (model.canvas === canvas) {
      return;
    }
    if (canvas !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.image = null;
      model.imageBitmap = null;
      model.jsImageData = null;
    }
    model.canvas = canvas;
    publicAPI.modified();
  };
  publicAPI.setImage = (image) => {
    if (model.image === image) {
      return;
    }
    if (image !== null) {
      publicAPI.setInputData(null);
      publicAPI.setInputConnection(null);
      model.canvas = null;
      model.jsImageData = null;
      model.imageBitmap = null;
    }
    model.image = image;
    model.imageLoaded = false;
    if (image.complete) {
      publicAPI.imageLoaded();
    } else {
      image.addEventListener("load", publicAPI.imageLoaded);
    }
    publicAPI.modified();
  };
  publicAPI.getDimensionality = () => {
    let width = 0;
    let height = 0;
    let depth = 1;
    if (publicAPI.getInputData()) {
      const data = publicAPI.getInputData();
      width = data.getDimensions()[0];
      height = data.getDimensions()[1];
      depth = data.getDimensions()[2];
    }
    if (model.jsImageData) {
      width = model.jsImageData.width;
      height = model.jsImageData.height;
    }
    if (model.canvas) {
      width = model.canvas.width;
      height = model.canvas.height;
    }
    if (model.image) {
      width = model.image.width;
      height = model.image.height;
    }
    if (model.imageBitmap) {
      width = model.imageBitmap.width;
      height = model.imageBitmap.height;
    }
    const dimensionality = (width > 1) + (height > 1) + (depth > 1);
    return dimensionality;
  };
  publicAPI.getInputAsJsImageData = () => {
    if (!model.imageLoaded || publicAPI.getInputData())
      return null;
    if (model.jsImageData) {
      return model.jsImageData;
    }
    if (model.imageBitmap) {
      return model.imageBitmap;
    }
    if (model.canvas) {
      const context = model.canvas.getContext("2d");
      const imageData = context.getImageData(0, 0, model.canvas.width, model.canvas.height);
      return imageData;
    }
    if (model.image) {
      const width = model.image.width;
      const height = model.image.height;
      const canvas = new OffscreenCanvas(width, height);
      const context = canvas.getContext("2d");
      context.translate(0, height);
      context.scale(1, -1);
      context.drawImage(model.image, 0, 0, width, height);
      const imageData = context.getImageData(0, 0, width, height);
      return imageData;
    }
    return null;
  };
}
var generateMipmaps = (device, texture, mipLevelCount) => {
  const computeShaderCode = `
    @group(0) @binding(0) var inputTexture: texture_2d<f32>;
    @group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8)
    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let texelCoord = vec2<i32>(global_id.xy);
      let outputSize = textureDimensions(outputTexture);

      if (texelCoord.x >= i32(outputSize.x) || texelCoord.y >= i32(outputSize.y)) {
        return;
      }

      let inputSize = textureDimensions(inputTexture);
      let scale = vec2<f32>(inputSize) / vec2<f32>(outputSize);

      // Compute the floating-point source coordinate
      let srcCoord = (vec2<f32>(texelCoord) + 0.5) * scale - 0.5;

      // Get integer coordinates for the four surrounding texels
      let x0 = i32(floor(srcCoord.x));
      let x1 = min(x0 + 1, i32(inputSize.x) - 1);
      let y0 = i32(floor(srcCoord.y));
      let y1 = min(y0 + 1, i32(inputSize.y) - 1);

      // Compute the weights
      let wx = srcCoord.x - f32(x0);
      let wy = srcCoord.y - f32(y0);

      // Fetch the four texels
      let c00 = textureLoad(inputTexture, vec2<i32>(x0, y0), 0);
      let c10 = textureLoad(inputTexture, vec2<i32>(x1, y0), 0);
      let c01 = textureLoad(inputTexture, vec2<i32>(x0, y1), 0);
      let c11 = textureLoad(inputTexture, vec2<i32>(x1, y1), 0);

      // Bilinear interpolation
      let color = mix(
        mix(c00, c10, wx),
        mix(c01, c11, wx),
        wy
      );

      textureStore(outputTexture, texelCoord, color);
    }
  `;
  const computeShader = device.createShaderModule({
    code: computeShaderCode
  });
  const bindGroupLayout = device.createBindGroupLayout({
    entries: [{
      binding: 0,
      // eslint-disable-next-line no-undef
      visibility: GPUShaderStage.COMPUTE,
      texture: {
        sampleType: "float"
      }
    }, {
      binding: 1,
      // eslint-disable-next-line no-undef
      visibility: GPUShaderStage.COMPUTE,
      storageTexture: {
        format: "rgba8unorm",
        access: "write-only"
      }
    }, {
      binding: 2,
      // eslint-disable-next-line no-undef
      visibility: GPUShaderStage.COMPUTE,
      sampler: {
        type: "filtering"
      }
    }]
  });
  const pipelineLayout = device.createPipelineLayout({
    bindGroupLayouts: [bindGroupLayout]
  });
  const pipeline = device.createComputePipeline({
    label: "ComputeMipmapPipeline",
    layout: pipelineLayout,
    compute: {
      module: computeShader,
      entryPoint: "main"
    }
  });
  const sampler = device.createSampler({
    magFilter: "linear",
    minFilter: "linear"
  });
  for (let mipLevel = 1; mipLevel < mipLevelCount; mipLevel++) {
    const srcView = texture.createView({
      baseMipLevel: mipLevel - 1,
      mipLevelCount: 1
    });
    const dstView = texture.createView({
      baseMipLevel: mipLevel,
      mipLevelCount: 1
    });
    const bindGroup = device.createBindGroup({
      layout: pipeline.getBindGroupLayout(0),
      entries: [{
        binding: 0,
        resource: srcView
      }, {
        binding: 1,
        resource: dstView
      }, {
        binding: 2,
        resource: sampler
      }]
    });
    const commandEncoder = device.createCommandEncoder({
      label: `MipmapGenerateCommandEncoder`
    });
    const computePass = commandEncoder.beginComputePass();
    computePass.setPipeline(pipeline);
    computePass.setBindGroup(0, bindGroup);
    const mipWidth = Math.max(1, texture.width >> mipLevel);
    const mipHeight = Math.max(1, texture.height >> mipLevel);
    const workgroupsX = Math.ceil(mipWidth / 8);
    const workgroupsY = Math.ceil(mipHeight / 8);
    computePass.dispatchWorkgroups(workgroupsX, workgroupsY);
    computePass.end();
    device.queue.submit([commandEncoder.finish()]);
  }
};
var DEFAULT_VALUES7 = {
  image: null,
  canvas: null,
  jsImageData: null,
  imageBitmap: null,
  imageLoaded: false,
  repeat: false,
  interpolate: false,
  edgeClamp: false,
  mipLevel: 0,
  resizable: false
  // must be set at construction time if the texture can be resizable
};
function extend7(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES7, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 6, 0);
  macro.get(publicAPI, model, ["canvas", "image", "jsImageData", "imageBitmap", "imageLoaded", "resizable"]);
  macro.setGet(publicAPI, model, ["repeat", "edgeClamp", "interpolate", "mipLevel"]);
  vtkTexture(publicAPI, model);
}
var newInstance8 = macro.newInstance(extend7, "vtkTexture");
var STATIC = {
  generateMipmaps
};
var vtkTexture$1 = {
  newInstance: newInstance8,
  extend: extend7,
  ...STATIC
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Texture.js
function vtkWebGPUTexture(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUTexture");
  publicAPI.create = (device, options) => {
    model.device = device;
    model.width = options.width;
    model.height = options.height;
    model.depth = options.depth ? options.depth : 1;
    const dimension = model.depth === 1 ? "2d" : "3d";
    model.format = options.format ? options.format : "rgba8unorm";
    model.mipLevel = options.mipLevel ? options.mipLevel : 0;
    model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
    model.handle = model.device.getHandle().createTexture({
      size: [model.width, model.height, model.depth],
      format: model.format,
      // 'rgba8unorm',
      usage: model.usage,
      label: model.label,
      dimension,
      mipLevelCount: model.mipLevel + 1
    });
  };
  publicAPI.assignFromHandle = (device, handle, options) => {
    model.device = device;
    model.handle = handle;
    model.width = options.width;
    model.height = options.height;
    model.depth = options.depth ? options.depth : 1;
    model.format = options.format ? options.format : "rgba8unorm";
    model.usage = options.usage ? options.usage : GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST;
  };
  publicAPI.writeImageData = (req) => {
    let nativeArray = [];
    const _copyImageToTexture = (source) => {
      model.device.getHandle().queue.copyExternalImageToTexture({
        source,
        flipY: req.flip
      }, {
        texture: model.handle,
        premultipliedAlpha: true,
        mipLevel: 0,
        origin: {
          x: 0,
          y: 0,
          z: 0
        }
      }, [source.width, source.height, model.depth]);
      if (publicAPI.getDimensionality() !== 3 && model.mipLevel > 0) {
        vtkTexture$1.generateMipmaps(model.device.getHandle(), model.handle, model.mipLevel + 1);
      }
      model.ready = true;
    };
    if (req.canvas) {
      _copyImageToTexture(req.canvas);
      return;
    }
    if (req.imageBitmap) {
      req.width = req.imageBitmap.width;
      req.height = req.imageBitmap.height;
      req.depth = 1;
      req.format = "rgba8unorm";
      req.flip = true;
      _copyImageToTexture(req.imageBitmap);
      return;
    }
    if (req.jsImageData) {
      req.width = req.jsImageData.width;
      req.height = req.jsImageData.height;
      req.depth = 1;
      req.format = "rgba8unorm";
      req.flip = true;
      _copyImageToTexture(req.jsImageData);
      return;
    }
    if (req.image) {
      req.width = req.image.width;
      req.height = req.image.height;
      req.depth = 1;
      req.format = "rgba8unorm";
      req.flip = true;
      _copyImageToTexture(req.image);
      return;
    }
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
    let bufferBytesPerRow = model.width * tDetails.stride;
    const alignTextureData = (arr, height, depth) => {
      const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === "float";
      const bytesPerElement = arr.BYTES_PER_ELEMENT;
      const inWidthInBytes = arr.length / (height * depth) * bytesPerElement;
      if (!halfFloat && inWidthInBytes % 256 === 0) {
        return [arr, inWidthInBytes];
      }
      const inWidth = inWidthInBytes / bytesPerElement;
      const outBytesPerElement = tDetails.elementSize;
      const outWidthInBytes = 256 * Math.floor((inWidth * outBytesPerElement + 255) / 256);
      const outWidth = outWidthInBytes / outBytesPerElement;
      const outArray = macro.newTypedArray(halfFloat ? "Uint16Array" : arr.constructor.name, outWidth * height * depth);
      const totalRows = height * depth;
      if (halfFloat) {
        for (let v = 0; v < totalRows; v++) {
          const inOffset = v * inWidth;
          const outOffset = v * outWidth;
          for (let i = 0; i < inWidth; i++) {
            outArray[outOffset + i] = HalfFloat.toHalf(arr[inOffset + i]);
          }
        }
      } else if (outWidth === inWidth) {
        outArray.set(arr);
      } else {
        for (let v = 0; v < totalRows; v++) {
          outArray.set(arr.subarray(v * inWidth, (v + 1) * inWidth), v * outWidth);
        }
      }
      return [outArray, outWidthInBytes];
    };
    if (req.nativeArray) {
      nativeArray = req.nativeArray;
    }
    const is3D = publicAPI.getDimensionality() === 3;
    const alignedTextureData = alignTextureData(nativeArray, model.height, is3D ? model.depth : 1);
    bufferBytesPerRow = alignedTextureData[1];
    const data = alignedTextureData[0];
    model.device.getHandle().queue.writeTexture({
      texture: model.handle,
      mipLevel: 0,
      origin: {
        x: 0,
        y: 0,
        z: 0
      }
    }, data, {
      offset: 0,
      bytesPerRow: bufferBytesPerRow,
      rowsPerImage: model.height
    }, {
      width: model.width,
      height: model.height,
      depthOrArrayLayers: is3D ? model.depth : 1
    });
    if (!is3D && model.mipLevel > 0) {
      vtkTexture$1.generateMipmaps(model.device.getHandle(), model.handle, model.mipLevel + 1);
    }
    model.ready = true;
  };
  publicAPI.getScale = () => {
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
    const halfFloat = tDetails.elementSize === 2 && tDetails.sampleType === "float";
    return halfFloat ? 1 : 255;
  };
  publicAPI.getNumberOfComponents = () => {
    const tDetails = vtkWebGPUTypes.getDetailsFromTextureFormat(model.format);
    return tDetails.numComponents;
  };
  publicAPI.getDimensionality = () => {
    let dims = 0;
    if (model.width > 1)
      dims++;
    if (model.height > 1)
      dims++;
    if (model.depth > 1)
      dims++;
    return dims;
  };
  publicAPI.resizeToMatch = (tex) => {
    if (tex.getWidth() !== model.width || tex.getHeight() !== model.height || tex.getDepth() !== model.depth) {
      model.width = tex.getWidth();
      model.height = tex.getHeight();
      model.depth = tex.getDepth();
      model.handle = model.device.getHandle().createTexture({
        size: [model.width, model.height, model.depth],
        format: model.format,
        usage: model.usage,
        label: model.label
      });
    }
  };
  publicAPI.resize = function(width, height) {
    let depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    if (width !== model.width || height !== model.height || depth !== model.depth) {
      model.width = width;
      model.height = height;
      model.depth = depth;
      model.handle = model.device.getHandle().createTexture({
        size: [model.width, model.height, model.depth],
        format: model.format,
        usage: model.usage,
        label: model.label
      });
    }
  };
  publicAPI.createView = function(label) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!options.dimension) {
      options.dimension = model.depth === 1 ? "2d" : "3d";
    }
    const view = vtkWebGPUTextureView$1.newInstance({
      label
    });
    view.create(publicAPI, options);
    return view;
  };
}
var DEFAULT_VALUES8 = {
  device: null,
  handle: null,
  buffer: null,
  ready: false,
  label: null
};
function extend8(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES8, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["handle", "ready", "width", "height", "depth", "format", "usage"]);
  macro.setGet(publicAPI, model, ["device", "label"]);
  vtkWebGPUTexture(publicAPI, model);
}
var newInstance9 = macro.newInstance(extend8);
var vtkWebGPUTexture$1 = {
  newInstance: newInstance9,
  extend: extend8
};

// node_modules/gl-matrix/esm/common.js
var common_exports = {};
__export(common_exports, {
  ARRAY_TYPE: () => ARRAY_TYPE,
  EPSILON: () => EPSILON,
  RANDOM: () => RANDOM,
  equals: () => equals,
  setMatrixArrayType: () => setMatrixArrayType,
  toRadian: () => toRadian
});
var EPSILON = 1e-6;
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
var RANDOM = Math.random;
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
function toRadian(a) {
  return a * degree;
}
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
}
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };

// node_modules/gl-matrix/esm/mat3.js
var mat3_exports = {};
__export(mat3_exports, {
  add: () => add2,
  adjoint: () => adjoint,
  clone: () => clone,
  copy: () => copy,
  create: () => create,
  determinant: () => determinant,
  equals: () => equals2,
  exactEquals: () => exactEquals,
  frob: () => frob,
  fromMat2d: () => fromMat2d,
  fromMat4: () => fromMat4,
  fromQuat: () => fromQuat,
  fromRotation: () => fromRotation,
  fromScaling: () => fromScaling,
  fromTranslation: () => fromTranslation,
  fromValues: () => fromValues,
  identity: () => identity,
  invert: () => invert,
  mul: () => mul,
  multiply: () => multiply,
  multiplyScalar: () => multiplyScalar,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd,
  normalFromMat4: () => normalFromMat4,
  projection: () => projection,
  rotate: () => rotate,
  scale: () => scale,
  set: () => set2,
  str: () => str,
  sub: () => sub,
  subtract: () => subtract2,
  translate: () => translate,
  transpose: () => transpose
});
function create() {
  var out = new ARRAY_TYPE(9);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
function clone(a) {
  var out = new ARRAY_TYPE(9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new ARRAY_TYPE(9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function set2(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function transpose(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }
  return out;
}
function invert(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function adjoint(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
function determinant(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function translate(out, a, v) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], x = v[0], y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
function rotate(out, a, rad) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a10 = a[3], a11 = a[4], a12 = a[5], a20 = a[6], a21 = a[7], a22 = a[8], s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
function scale(out, a, v) {
  var x = v[0], y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  var s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
function fromQuat(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
function normalFromMat4(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
function str(a) {
  return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")";
}
function frob(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
}
function add2(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
function subtract2(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
function multiplyScalarAndAdd(out, a, b, scale7) {
  out[0] = a[0] + b[0] * scale7;
  out[1] = a[1] + b[1] * scale7;
  out[2] = a[2] + b[2] * scale7;
  out[3] = a[3] + b[3] * scale7;
  out[4] = a[4] + b[4] * scale7;
  out[5] = a[5] + b[5] * scale7;
  out[6] = a[6] + b[6] * scale7;
  out[7] = a[7] + b[7] * scale7;
  out[8] = a[8] + b[8] * scale7;
  return out;
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
function equals2(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
}
var mul = multiply;
var sub = subtract2;

// node_modules/gl-matrix/esm/mat4.js
var mat4_exports = {};
__export(mat4_exports, {
  add: () => add3,
  adjoint: () => adjoint2,
  clone: () => clone2,
  copy: () => copy2,
  create: () => create2,
  determinant: () => determinant2,
  equals: () => equals3,
  exactEquals: () => exactEquals2,
  frob: () => frob2,
  fromQuat: () => fromQuat3,
  fromQuat2: () => fromQuat2,
  fromRotation: () => fromRotation2,
  fromRotationTranslation: () => fromRotationTranslation,
  fromRotationTranslationScale: () => fromRotationTranslationScale,
  fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
  fromScaling: () => fromScaling2,
  fromTranslation: () => fromTranslation2,
  fromValues: () => fromValues2,
  fromXRotation: () => fromXRotation,
  fromYRotation: () => fromYRotation,
  fromZRotation: () => fromZRotation,
  frustum: () => frustum,
  getRotation: () => getRotation,
  getScaling: () => getScaling,
  getTranslation: () => getTranslation,
  identity: () => identity2,
  invert: () => invert2,
  lookAt: () => lookAt,
  mul: () => mul2,
  multiply: () => multiply2,
  multiplyScalar: () => multiplyScalar2,
  multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
  ortho: () => ortho,
  orthoNO: () => orthoNO,
  orthoZO: () => orthoZO,
  perspective: () => perspective,
  perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
  perspectiveNO: () => perspectiveNO,
  perspectiveZO: () => perspectiveZO,
  rotate: () => rotate2,
  rotateX: () => rotateX,
  rotateY: () => rotateY,
  rotateZ: () => rotateZ,
  scale: () => scale2,
  set: () => set3,
  str: () => str2,
  sub: () => sub2,
  subtract: () => subtract3,
  targetTo: () => targetTo,
  translate: () => translate2,
  transpose: () => transpose2
});
function create2() {
  var out = new ARRAY_TYPE(16);
  if (ARRAY_TYPE != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
function clone2(a) {
  var out = new ARRAY_TYPE(16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function copy2(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new ARRAY_TYPE(16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function set3(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
function identity2(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function transpose2(out, a) {
  if (out === a) {
    var a01 = a[1], a02 = a[2], a03 = a[3];
    var a12 = a[6], a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }
  return out;
}
function invert2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
function adjoint2(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
function determinant2(a) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
function multiply2(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
  var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
  var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
  var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
function translate2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }
  return out;
}
function scale2(out, a, v) {
  var x = v[0], y = v[1], z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
function rotate2(out, a, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len4 = Math.hypot(x, y, z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;
  if (len4 < EPSILON) {
    return null;
  }
  len4 = 1 / len4;
  x *= len4;
  y *= len4;
  z *= len4;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11];
  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c;
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;
  if (a !== out) {
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];
  if (a !== out) {
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  if (a !== out) {
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
function fromTranslation2(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromScaling2(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotation2(out, rad, axis) {
  var x = axis[0], y = axis[1], z = axis[2];
  var len4 = Math.hypot(x, y, z);
  var s, c, t;
  if (len4 < EPSILON) {
    return null;
  }
  len4 = 1 / len4;
  x *= len4;
  y *= len4;
  z *= len4;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function fromRotationTranslation(out, q, v) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromQuat2(out, a) {
  var translation = new ARRAY_TYPE(3);
  var bx = -a[0], by = -a[1], bz = -a[2], bw = a[3], ax = a[4], ay = a[5], az = a[6], aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.hypot(m11, m12, m13);
  out[1] = Math.hypot(m21, m22, m23);
  out[2] = Math.hypot(m31, m32, m33);
  return out;
}
function getRotation(out, mat) {
  var scaling = new ARRAY_TYPE(3);
  getScaling(scaling, mat);
  var is1 = 1 / scaling[0];
  var is2 = 1 / scaling[1];
  var is3 = 1 / scaling[2];
  var sm11 = mat[0] * is1;
  var sm12 = mat[1] * is2;
  var sm13 = mat[2] * is3;
  var sm21 = mat[4] * is1;
  var sm22 = mat[5] * is2;
  var sm23 = mat[6] * is3;
  var sm31 = mat[8] * is1;
  var sm32 = mat[9] * is2;
  var sm33 = mat[10] * is3;
  var trace = sm11 + sm22 + sm33;
  var S = 0;
  if (trace > 0) {
    S = Math.sqrt(trace + 1) * 2;
    out[3] = 0.25 * S;
    out[0] = (sm23 - sm32) / S;
    out[1] = (sm31 - sm13) / S;
    out[2] = (sm12 - sm21) / S;
  } else if (sm11 > sm22 && sm11 > sm33) {
    S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
    out[3] = (sm23 - sm32) / S;
    out[0] = 0.25 * S;
    out[1] = (sm12 + sm21) / S;
    out[2] = (sm31 + sm13) / S;
  } else if (sm22 > sm33) {
    S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
    out[3] = (sm31 - sm13) / S;
    out[0] = (sm12 + sm21) / S;
    out[1] = 0.25 * S;
    out[2] = (sm23 + sm32) / S;
  } else {
    S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
    out[3] = (sm12 - sm21) / S;
    out[0] = (sm31 + sm13) / S;
    out[1] = (sm23 + sm32) / S;
    out[2] = 0.25 * S;
  }
  return out;
}
function fromRotationTranslationScale(out, q, v, s) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
function fromQuat3(out, q) {
  var x = q[0], y = q[1], z = q[2], w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
function perspectiveNO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}
var perspective = perspectiveNO;
function perspectiveZO(out, fovy, aspect, near, far) {
  var f = 1 / Math.tan(fovy / 2), nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = far * nf;
    out[14] = far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -near;
  }
  return out;
}
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
  var xScale = 2 / (leftTan + rightTan);
  var yScale = 2 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = yScale;
  out[6] = 0;
  out[7] = 0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near / (near - far);
  out[15] = 0;
  return out;
}
function orthoNO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
var ortho = orthoNO;
function orthoZO(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = near * nf;
  out[15] = 1;
  return out;
}
function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len4;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];
  if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
    return identity2(out);
  }
  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len4 = 1 / Math.hypot(z0, z1, z2);
  z0 *= len4;
  z1 *= len4;
  z2 *= len4;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len4 = Math.hypot(x0, x1, x2);
  if (!len4) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len4 = 1 / len4;
    x0 *= len4;
    x1 *= len4;
    x2 *= len4;
  }
  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len4 = Math.hypot(y0, y1, y2);
  if (!len4) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len4 = 1 / len4;
    y0 *= len4;
    y1 *= len4;
    y2 *= len4;
  }
  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
function targetTo(out, eye, target, up) {
  var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
  var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
  var len4 = z0 * z0 + z1 * z1 + z2 * z2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
    z0 *= len4;
    z1 *= len4;
    z2 *= len4;
  }
  var x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0;
  len4 = x0 * x0 + x1 * x1 + x2 * x2;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
    x0 *= len4;
    x1 *= len4;
    x2 *= len4;
  }
  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
function str2(a) {
  return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")";
}
function frob2(a) {
  return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]);
}
function add3(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
function subtract3(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
function multiplyScalar2(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
function multiplyScalarAndAdd2(out, a, b, scale7) {
  out[0] = a[0] + b[0] * scale7;
  out[1] = a[1] + b[1] * scale7;
  out[2] = a[2] + b[2] * scale7;
  out[3] = a[3] + b[3] * scale7;
  out[4] = a[4] + b[4] * scale7;
  out[5] = a[5] + b[5] * scale7;
  out[6] = a[6] + b[6] * scale7;
  out[7] = a[7] + b[7] * scale7;
  out[8] = a[8] + b[8] * scale7;
  out[9] = a[9] + b[9] * scale7;
  out[10] = a[10] + b[10] * scale7;
  out[11] = a[11] + b[11] * scale7;
  out[12] = a[12] + b[12] * scale7;
  out[13] = a[13] + b[13] * scale7;
  out[14] = a[14] + b[14] * scale7;
  out[15] = a[15] + b[15] * scale7;
  return out;
}
function exactEquals2(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
function equals3(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
  var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
  var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
  var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
  var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
}
var mul2 = multiply2;
var sub2 = subtract3;

// node_modules/gl-matrix/esm/quat.js
var quat_exports = {};
__export(quat_exports, {
  add: () => add6,
  calculateW: () => calculateW,
  clone: () => clone5,
  conjugate: () => conjugate,
  copy: () => copy5,
  create: () => create5,
  dot: () => dot4,
  equals: () => equals6,
  exactEquals: () => exactEquals5,
  exp: () => exp,
  fromEuler: () => fromEuler,
  fromMat3: () => fromMat3,
  fromValues: () => fromValues5,
  getAngle: () => getAngle,
  getAxisAngle: () => getAxisAngle,
  identity: () => identity3,
  invert: () => invert3,
  len: () => len3,
  length: () => length3,
  lerp: () => lerp3,
  ln: () => ln,
  mul: () => mul5,
  multiply: () => multiply5,
  normalize: () => normalize4,
  pow: () => pow,
  random: () => random3,
  rotateX: () => rotateX3,
  rotateY: () => rotateY3,
  rotateZ: () => rotateZ3,
  rotationTo: () => rotationTo,
  scale: () => scale5,
  set: () => set6,
  setAxes: () => setAxes,
  setAxisAngle: () => setAxisAngle,
  slerp: () => slerp,
  sqlerp: () => sqlerp,
  sqrLen: () => sqrLen3,
  squaredLength: () => squaredLength3,
  str: () => str5
});

// node_modules/gl-matrix/esm/vec3.js
var vec3_exports = {};
__export(vec3_exports, {
  add: () => add4,
  angle: () => angle,
  bezier: () => bezier,
  ceil: () => ceil,
  clone: () => clone3,
  copy: () => copy3,
  create: () => create3,
  cross: () => cross2,
  dist: () => dist,
  distance: () => distance,
  div: () => div,
  divide: () => divide,
  dot: () => dot2,
  equals: () => equals4,
  exactEquals: () => exactEquals3,
  floor: () => floor,
  forEach: () => forEach,
  fromValues: () => fromValues3,
  hermite: () => hermite,
  inverse: () => inverse,
  len: () => len,
  length: () => length,
  lerp: () => lerp,
  max: () => max,
  min: () => min,
  mul: () => mul3,
  multiply: () => multiply3,
  negate: () => negate,
  normalize: () => normalize2,
  random: () => random,
  rotateX: () => rotateX2,
  rotateY: () => rotateY2,
  rotateZ: () => rotateZ2,
  round: () => round2,
  scale: () => scale3,
  scaleAndAdd: () => scaleAndAdd,
  set: () => set4,
  sqrDist: () => sqrDist,
  sqrLen: () => sqrLen,
  squaredDistance: () => squaredDistance,
  squaredLength: () => squaredLength,
  str: () => str3,
  sub: () => sub3,
  subtract: () => subtract4,
  transformMat3: () => transformMat3,
  transformMat4: () => transformMat4,
  transformQuat: () => transformQuat,
  zero: () => zero
});
function create3() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function clone3(a) {
  var out = new ARRAY_TYPE(3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.hypot(x, y, z);
}
function fromValues3(x, y, z) {
  var out = new ARRAY_TYPE(3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function copy3(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
function set4(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
function add4(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
function subtract4(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
function multiply3(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
function round2(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
function scale3(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
function scaleAndAdd(out, a, b, scale7) {
  out[0] = a[0] + b[0] * scale7;
  out[1] = a[1] + b[1] * scale7;
  out[2] = a[2] + b[2] * scale7;
  return out;
}
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.hypot(x, y, z);
}
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
function inverse(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  return out;
}
function normalize2(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len4 = x * x + y * y + z * z;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = a[0] * len4;
  out[1] = a[1] * len4;
  out[2] = a[2] * len4;
  return out;
}
function dot2(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
function cross2(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2];
  var bx = b[0], by = b[1], bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
function random(out, scale7) {
  scale7 = scale7 || 1;
  var r = RANDOM() * 2 * Math.PI;
  var z = RANDOM() * 2 - 1;
  var zScale = Math.sqrt(1 - z * z) * scale7;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale7;
  return out;
}
function transformMat4(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
function transformQuat(out, a, q) {
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var x = a[0], y = a[1], z = a[2];
  var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
  var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
function rotateX2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0];
  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateY2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function rotateZ2(out, a, b, rad) {
  var p = [], r = [];
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];
  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
  r[2] = p[2];
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
function angle(a, b) {
  var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot2(a, b) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function zero(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  return out;
}
function str3(a) {
  return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")";
}
function exactEquals3(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
function equals4(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2];
  var b0 = b[0], b1 = b[1], b2 = b[2];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
}
var sub3 = subtract4;
var mul3 = multiply3;
var div = divide;
var dist = distance;
var sqrDist = squaredDistance;
var len = length;
var sqrLen = squaredLength;
var forEach = function() {
  var vec = create3();
  return function(a, stride, offset, count2, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
}();

// node_modules/gl-matrix/esm/vec4.js
var vec4_exports = {};
__export(vec4_exports, {
  add: () => add5,
  ceil: () => ceil2,
  clone: () => clone4,
  copy: () => copy4,
  create: () => create4,
  cross: () => cross3,
  dist: () => dist2,
  distance: () => distance2,
  div: () => div2,
  divide: () => divide2,
  dot: () => dot3,
  equals: () => equals5,
  exactEquals: () => exactEquals4,
  floor: () => floor2,
  forEach: () => forEach2,
  fromValues: () => fromValues4,
  inverse: () => inverse2,
  len: () => len2,
  length: () => length2,
  lerp: () => lerp2,
  max: () => max2,
  min: () => min2,
  mul: () => mul4,
  multiply: () => multiply4,
  negate: () => negate2,
  normalize: () => normalize3,
  random: () => random2,
  round: () => round3,
  scale: () => scale4,
  scaleAndAdd: () => scaleAndAdd2,
  set: () => set5,
  sqrDist: () => sqrDist2,
  sqrLen: () => sqrLen2,
  squaredDistance: () => squaredDistance2,
  squaredLength: () => squaredLength2,
  str: () => str4,
  sub: () => sub4,
  subtract: () => subtract5,
  transformMat4: () => transformMat42,
  transformQuat: () => transformQuat2,
  zero: () => zero2
});
function create4() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}
function clone4(a) {
  var out = new ARRAY_TYPE(4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function fromValues4(x, y, z, w) {
  var out = new ARRAY_TYPE(4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function copy4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function set5(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
function add5(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
function subtract5(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
function multiply4(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
function divide2(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
function ceil2(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
function floor2(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
function min2(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
function max2(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
function round3(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
function scale4(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
function scaleAndAdd2(out, a, b, scale7) {
  out[0] = a[0] + b[0] * scale7;
  out[1] = a[1] + b[1] * scale7;
  out[2] = a[2] + b[2] * scale7;
  out[3] = a[3] + b[3] * scale7;
  return out;
}
function distance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.hypot(x, y, z, w);
}
function squaredDistance2(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
function length2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.hypot(x, y, z, w);
}
function squaredLength2(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
function negate2(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
function inverse2(out, a) {
  out[0] = 1 / a[0];
  out[1] = 1 / a[1];
  out[2] = 1 / a[2];
  out[3] = 1 / a[3];
  return out;
}
function normalize3(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len4 = x * x + y * y + z * z + w * w;
  if (len4 > 0) {
    len4 = 1 / Math.sqrt(len4);
  }
  out[0] = x * len4;
  out[1] = y * len4;
  out[2] = z * len4;
  out[3] = w * len4;
  return out;
}
function dot3(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
function cross3(out, u, v, w) {
  var A2 = v[0] * w[1] - v[1] * w[0], B2 = v[0] * w[2] - v[2] * w[0], C2 = v[0] * w[3] - v[3] * w[0], D2 = v[1] * w[2] - v[2] * w[1], E2 = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E2 + J * D2;
  out[1] = -(G * F) + I * C2 - J * B2;
  out[2] = G * E2 - H * C2 + J * A2;
  out[3] = -(G * D2) + H * B2 - I * A2;
  return out;
}
function lerp2(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
function random2(out, scale7) {
  scale7 = scale7 || 1;
  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = RANDOM() * 2 - 1;
    v2 = RANDOM() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = RANDOM() * 2 - 1;
    v4 = RANDOM() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);
  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale7 * v1;
  out[1] = scale7 * v2;
  out[2] = scale7 * v3 * d;
  out[3] = scale7 * v4 * d;
  return out;
}
function transformMat42(out, a, m) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
function transformQuat2(out, a, q) {
  var x = a[0], y = a[1], z = a[2];
  var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
function zero2(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  return out;
}
function str4(a) {
  return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
function exactEquals4(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
function equals5(a, b) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
  return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3));
}
var sub4 = subtract5;
var mul4 = multiply4;
var div2 = divide2;
var dist2 = distance2;
var sqrDist2 = squaredDistance2;
var len2 = length2;
var sqrLen2 = squaredLength2;
var forEach2 = function() {
  var vec = create4();
  return function(a, stride, offset, count2, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 4;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }
    return a;
  };
}();

// node_modules/gl-matrix/esm/quat.js
function create5() {
  var out = new ARRAY_TYPE(4);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}
function identity3(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2;
  var s = Math.sin(rad / 2);
  if (s > EPSILON) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}
function getAngle(a, b) {
  var dotproduct = dot4(a, b);
  return Math.acos(2 * dotproduct * dotproduct - 1);
}
function multiply5(out, a, b) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
function rotateX3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
function rotateY3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var by = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
function rotateZ3(out, a, rad) {
  rad *= 0.5;
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bz = Math.sin(rad), bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
function calculateW(out, a) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1 - x * x - y * y - z * z));
  return out;
}
function exp(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var et = Math.exp(w);
  var s = r > 0 ? et * Math.sin(r) / r : 0;
  out[0] = x * s;
  out[1] = y * s;
  out[2] = z * s;
  out[3] = et * Math.cos(r);
  return out;
}
function ln(out, a) {
  var x = a[0], y = a[1], z = a[2], w = a[3];
  var r = Math.sqrt(x * x + y * y + z * z);
  var t = r > 0 ? Math.atan2(r, w) / r : 0;
  out[0] = x * t;
  out[1] = y * t;
  out[2] = z * t;
  out[3] = 0.5 * Math.log(x * x + y * y + z * z + w * w);
  return out;
}
function pow(out, a, b) {
  ln(out, a);
  scale5(out, out, b);
  exp(out, out);
  return out;
}
function slerp(out, a, b, t) {
  var ax = a[0], ay = a[1], az = a[2], aw = a[3];
  var bx = b[0], by = b[1], bz = b[2], bw = b[3];
  var omega, cosom, sinom, scale0, scale1;
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  if (cosom < 0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  if (1 - cosom > EPSILON) {
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    scale0 = 1 - t;
    scale1 = t;
  }
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
function random3(out) {
  var u1 = RANDOM();
  var u2 = RANDOM();
  var u3 = RANDOM();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
  return out;
}
function invert3(out, a) {
  var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
  var dot5 = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot5 ? 1 / dot5 : 0;
  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
function fromMat3(out, m) {
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;
  if (fTrace > 0) {
    fRoot = Math.sqrt(fTrace + 1);
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    var i = 0;
    if (m[4] > m[0])
      i = 1;
    if (m[8] > m[i * 3 + i])
      i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }
  return out;
}
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
function str5(a) {
  return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")";
}
var clone5 = clone4;
var fromValues5 = fromValues4;
var copy5 = copy4;
var set6 = set5;
var add6 = add5;
var mul5 = multiply5;
var scale5 = scale4;
var dot4 = dot3;
var lerp3 = lerp2;
var length3 = length2;
var len3 = length3;
var squaredLength3 = squaredLength2;
var sqrLen3 = squaredLength3;
var normalize4 = normalize3;
var exactEquals5 = exactEquals4;
var equals6 = equals5;
var rotationTo = function() {
  var tmpvec3 = create3();
  var xUnitVec3 = fromValues3(1, 0, 0);
  var yUnitVec3 = fromValues3(0, 1, 0);
  return function(out, a, b) {
    var dot5 = dot2(a, b);
    if (dot5 < -0.999999) {
      cross2(tmpvec3, xUnitVec3, a);
      if (len(tmpvec3) < 1e-6)
        cross2(tmpvec3, yUnitVec3, a);
      normalize2(tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot5 > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      cross2(tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot5;
      return normalize4(out, out);
    }
  };
}();
var sqlerp = function() {
  var temp1 = create5();
  var temp2 = create5();
  return function(out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
var setAxes = function() {
  var matr = create();
  return function(out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize4(out, fromMat3(out, matr));
  };
}();

// node_modules/gl-matrix/esm/vec2.js
function create6() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
var forEach3 = function() {
  var vec = create6();
  return function(a, stride, offset, count2, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
}();

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor.js
function vtkOpenGLActor(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getTextures());
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
      model.ogltextures = null;
      model.activeTextures = null;
      for (let index2 = 0; index2 < model.children.length; index2++) {
        const child = model.children[index2];
        if (child.isA("vtkOpenGLTexture")) {
          if (!model.ogltextures) {
            model.ogltextures = [];
          }
          model.ogltextures.push(child);
        } else {
          model.oglmapper = child;
        }
      }
    }
  };
  publicAPI.traverseZBufferPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOpaqueZBufferPass = (renderPass) => publicAPI.traverseOpaquePass(renderPass);
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.activateTextures = () => {
    if (!model.ogltextures) {
      return;
    }
    model.activeTextures = [];
    for (let index2 = 0; index2 < model.ogltextures.length; index2++) {
      const child = model.ogltextures[index2];
      child.render();
      if (child.getHandle()) {
        model.activeTextures.push(child);
      }
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.zBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaqueZBufferPass = (prepass, renderPass) => publicAPI.opaquePass(prepass, renderPass);
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index2 = 0; index2 < model.activeTextures.length; index2++) {
        model.activeTextures[index2].deactivate();
      }
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(model._openGLRenderer.getSelector() && model.renderable.getNestedPickable());
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index2 = 0; index2 < model.activeTextures.length; index2++) {
        model.activeTextures[index2].deactivate();
      }
    }
  };
  publicAPI.getKeyMatrices = () => {
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      mat4_exports.copy(model.keyMatrices.mcwc, model.renderable.getMatrix());
      mat4_exports.transpose(model.keyMatrices.mcwc, model.keyMatrices.mcwc);
      if (model.renderable.getIsIdentity()) {
        mat3_exports.identity(model.keyMatrices.normalMatrix);
      } else {
        mat3_exports.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.mcwc);
        mat3_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        mat3_exports.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES9 = {
  context: null,
  keyMatrixTime: null,
  keyMatrices: null,
  activeTextures: null
};
function extend9(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES9, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: mat3_exports.identity(new Float64Array(9)),
    mcwc: mat4_exports.identity(new Float64Array(16))
  };
  setGet(publicAPI, model, ["context"]);
  get(publicAPI, model, ["activeTextures"]);
  vtkOpenGLActor(publicAPI, model);
}
var newInstance10 = newInstance(extend9);
var vtkActor = {
  newInstance: newInstance10,
  extend: extend9
};
registerOverride("vtkActor", newInstance10);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Actor2D.js
function vtkOpenGLActor2D(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLActor2D");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model._openGLRenderWindow = publicAPI.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model.context = model._openGLRenderWindow.getContext();
      publicAPI.prepareNodes();
      publicAPI.addMissingNodes(model.renderable.getTextures());
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
      model.ogltextures = null;
      model.activeTextures = null;
      for (let index2 = 0; index2 < model.children.length; index2++) {
        const child = model.children[index2];
        if (child.isA("vtkOpenGLTexture")) {
          if (!model.ogltextures) {
            model.ogltextures = [];
          }
          model.ogltextures.push(child);
        } else {
          model.oglmapper = child;
        }
      }
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementOverlayActorCount();
    }
  };
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseOverlayPass = (renderPass) => {
    if (!model.oglmapper || !model.renderable || !model.renderable.getNestedVisibility() || model._openGLRenderer.getSelector() && !model.renderable.getNestedPickable) {
      return;
    }
    publicAPI.apply(renderPass, true);
    model.oglmapper.traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };
  publicAPI.activateTextures = () => {
    if (!model.ogltextures) {
      return;
    }
    model.activeTextures = [];
    for (let index2 = 0; index2 < model.ogltextures.length; index2++) {
      const child = model.ogltextures[index2];
      child.render();
      if (child.getHandle()) {
        model.activeTextures.push(child);
      }
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index2 = 0; index2 < model.activeTextures.length; index2++) {
        model.activeTextures[index2].deactivate();
      }
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(false);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index2 = 0; index2 < model.activeTextures.length; index2++) {
        model.activeTextures[index2].deactivate();
      }
    }
  };
  publicAPI.overlayPass = (prepass, renderPass) => {
    if (prepass) {
      model.context.depthMask(true);
      publicAPI.activateTextures();
    } else if (model.activeTextures) {
      for (let index2 = 0; index2 < model.activeTextures.length; index2++) {
        model.activeTextures[index2].deactivate();
      }
    }
  };
}
var DEFAULT_VALUES10 = {
  context: null,
  activeTextures: null
};
function extend10(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES10, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  setGet(publicAPI, model, ["context"]);
  get(publicAPI, model, ["activeTextures"]);
  vtkOpenGLActor2D(publicAPI, model);
}
var newInstance11 = newInstance(extend10);
var vtkActor2D = {
  newInstance: newInstance11,
  extend: extend10
};
registerOverride("vtkActor2D", newInstance11);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Camera.js
function vtkOpenGLCamera(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCamera");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.context.viewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
      model.context.scissor(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
    }
  };
  publicAPI.translucentPass = publicAPI.opaquePass;
  publicAPI.zBufferPass = publicAPI.opaquePass;
  publicAPI.opaqueZBufferPass = publicAPI.opaquePass;
  publicAPI.volumePass = publicAPI.opaquePass;
  publicAPI.getKeyMatrices = (ren) => {
    if (ren !== model.lastRenderer || model._openGLRenderWindow.getMTime() > model.keyMatrixTime.getMTime() || publicAPI.getMTime() > model.keyMatrixTime.getMTime() || ren.getMTime() > model.keyMatrixTime.getMTime() || model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      mat4_exports.copy(model.keyMatrices.wcvc, model.renderable.getViewMatrix());
      mat3_exports.fromMat4(model.keyMatrices.normalMatrix, model.keyMatrices.wcvc);
      mat3_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      mat4_exports.transpose(model.keyMatrices.wcvc, model.keyMatrices.wcvc);
      const aspectRatio = model._openGLRenderer.getAspectRatio();
      mat4_exports.copy(model.keyMatrices.vcpc, model.renderable.getProjectionMatrix(aspectRatio, -1, 1));
      mat4_exports.transpose(model.keyMatrices.vcpc, model.keyMatrices.vcpc);
      mat4_exports.multiply(model.keyMatrices.wcpc, model.keyMatrices.vcpc, model.keyMatrices.wcvc);
      model.keyMatrixTime.modified();
      model.lastRenderer = ren;
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES11 = {
  context: null,
  lastRenderer: null,
  keyMatrixTime: null,
  keyMatrices: null
};
function extend11(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES11, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime);
  model.keyMatrices = {
    normalMatrix: new Float64Array(9),
    vcpc: new Float64Array(16),
    wcvc: new Float64Array(16),
    wcpc: new Float64Array(16)
  };
  setGet(publicAPI, model, ["context", "keyMatrixTime"]);
  vtkOpenGLCamera(publicAPI, model);
}
var newInstance12 = newInstance(extend11);
var vtkCamera = {
  newInstance: newInstance12,
  extend: extend11
};
registerOverride("vtkCamera", newInstance12);

// node_modules/d3-array/src/ascending.js
function ascending(a, b) {
  return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

// node_modules/d3-array/src/descending.js
function descending(a, b) {
  return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}

// node_modules/d3-array/src/bisector.js
function bisector(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending;
    compare2 = (d, x) => ascending(f(d), x);
    delta = (d, x) => f(d) - x;
  } else {
    compare1 = f === ascending || f === descending ? f : zero3;
    compare2 = f;
    delta = f;
  }
  function left(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a, x, lo = 0, hi = a.length) {
    if (lo < hi) {
      if (compare1(x, x) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a[mid], x) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a, x, lo = 0, hi = a.length) {
    const i = left(a, x, lo, hi - 1);
    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
  }
  return { left, center, right };
}
function zero3() {
  return 0;
}

// node_modules/d3-array/src/number.js
function number(x) {
  return x === null ? NaN : +x;
}

// node_modules/d3-array/src/bisect.js
var ascendingBisect = bisector(ascending);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
var bisectCenter = bisector(number).center;
var bisect_default = bisectRight;

// node_modules/d3-array/src/blur.js
var blur2 = Blur2(blurf);
var blurImage = Blur2(blurfImage);
function Blur2(blur3) {
  return function(data, rx, ry = rx) {
    if (!((rx = +rx) >= 0))
      throw new RangeError("invalid rx");
    if (!((ry = +ry) >= 0))
      throw new RangeError("invalid ry");
    let { data: values, width, height } = data;
    if (!((width = Math.floor(width)) >= 0))
      throw new RangeError("invalid width");
    if (!((height = Math.floor(height !== void 0 ? height : values.length / width)) >= 0))
      throw new RangeError("invalid height");
    if (!width || !height || !rx && !ry)
      return data;
    const blurx = rx && blur3(rx);
    const blury = ry && blur3(ry);
    const temp = values.slice();
    if (blurx && blury) {
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    } else if (blurx) {
      blurh(blurx, values, temp, width, height);
      blurh(blurx, temp, values, width, height);
      blurh(blurx, values, temp, width, height);
    } else if (blury) {
      blurv(blury, values, temp, width, height);
      blurv(blury, temp, values, width, height);
      blurv(blury, values, temp, width, height);
    }
    return data;
  };
}
function blurh(blur3, T, S, w, h) {
  for (let y = 0, n = w * h; y < n; ) {
    blur3(T, S, y, y += w, 1);
  }
}
function blurv(blur3, T, S, w, h) {
  for (let x = 0, n = w * h; x < w; ++x) {
    blur3(T, S, x, x + n, w);
  }
}
function blurfImage(radius) {
  const blur3 = blurf(radius);
  return (T, S, start, stop, step) => {
    start <<= 2, stop <<= 2, step <<= 2;
    blur3(T, S, start + 0, stop + 0, step);
    blur3(T, S, start + 1, stop + 1, step);
    blur3(T, S, start + 2, stop + 2, step);
    blur3(T, S, start + 3, stop + 3, step);
  };
}
function blurf(radius) {
  const radius0 = Math.floor(radius);
  if (radius0 === radius)
    return bluri(radius);
  const t = radius - radius0;
  const w = 2 * radius + 1;
  return (T, S, start, stop, step) => {
    if (!((stop -= step) >= start))
      return;
    let sum2 = radius0 * S[start];
    const s0 = step * radius0;
    const s1 = s0 + step;
    for (let i = start, j = start + s0; i < j; i += step) {
      sum2 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum2 += S[Math.min(stop, i + s0)];
      T[i] = (sum2 + t * (S[Math.max(start, i - s1)] + S[Math.min(stop, i + s1)])) / w;
      sum2 -= S[Math.max(start, i - s0)];
    }
  };
}
function bluri(radius) {
  const w = 2 * radius + 1;
  return (T, S, start, stop, step) => {
    if (!((stop -= step) >= start))
      return;
    let sum2 = radius * S[start];
    const s = step * radius;
    for (let i = start, j = start + s; i < j; i += step) {
      sum2 += S[Math.min(stop, i)];
    }
    for (let i = start, j = stop; i <= j; i += step) {
      sum2 += S[Math.min(stop, i + s)];
      T[i] = sum2 / w;
      sum2 -= S[Math.max(start, i - s)];
    }
  };
}

// node_modules/d3-array/src/array.js
var array = Array.prototype;
var slice = array.slice;
var map = array.map;

// node_modules/d3-array/src/ticks.js
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
function tickSpec(start, stop, count2) {
  const step = (stop - start) / Math.max(0, count2), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start)
      ++i1;
    if (i2 / inc > stop)
      --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start)
      ++i1;
    if (i2 * inc > stop)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count2 && count2 < 2)
    return tickSpec(start, stop, count2 * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  if (!(count2 > 0))
    return [];
  if (start === stop)
    return [start];
  const reverse2 = stop < start, [i1, i2, inc] = reverse2 ? tickSpec(stop, start, count2) : tickSpec(start, stop, count2);
  if (!(i2 >= i1))
    return [];
  const n = i2 - i1 + 1, ticks2 = new Array(n);
  if (reverse2) {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) / -inc;
    else
      for (let i = 0; i < n; ++i)
        ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  return tickSpec(start, stop, count2)[2];
}
function tickStep(start, stop, count2) {
  stop = +stop, start = +start, count2 = +count2;
  const reverse2 = stop < start, inc = reverse2 ? tickIncrement(stop, start, count2) : tickIncrement(start, stop, count2);
  return (reverse2 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}

// node_modules/d3-array/src/shuffle.js
var shuffle_default = shuffler(Math.random);
function shuffler(random4) {
  return function shuffle(array2, i0 = 0, i1 = array2.length) {
    let m = i1 - (i0 = +i0);
    while (m) {
      const i = random4() * m-- | 0, t = array2[m + i0];
      array2[m + i0] = array2[i + i0];
      array2[i + i0] = t;
    }
    return array2;
  };
}

// node_modules/d3-scale/src/init.js
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}

// node_modules/d3-scale/src/ordinal.js
var implicit = Symbol("implicit");

// node_modules/d3-color/src/define.js
function define_default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend12(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}

// node_modules/d3-color/src/color.js
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*";
var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
var reHex = /^#([0-9a-f]{3,8})$/;
var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define_default(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Rgb, rgb, extend12(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min4 = Math.min(r, g, b), max4 = Math.max(r, g, b), h = NaN, s = max4 - min4, l = (max4 + min4) / 2;
  if (s) {
    if (r === max4)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max4)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max4 + min4 : 2 - max4 - min4;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Hsl, hsl, extend12(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}

// node_modules/d3-color/src/math.js
var radians = Math.PI / 180;
var degrees = 180 / Math.PI;

// node_modules/d3-color/src/lab.js
var K = 18;
var Xn = 0.96422;
var Yn = 1;
var Zn = 0.82521;
var t0 = 4 / 29;
var t1 = 6 / 29;
var t2 = 3 * t1 * t1;
var t3 = t1 * t1 * t1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x, z;
  if (r === g && g === b)
    x = z = y;
  else {
    x = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}
function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}
function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}
define_default(Lab, lab, extend12(Color, {
  brighter(k) {
    return new Lab(this.l + K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker(k) {
    return new Lab(this.l - K * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb() {
    var y = (this.l + 16) / 116, x = isNaN(this.a) ? y : y + this.a / 500, z = isNaN(this.b) ? y : y - this.b / 200;
    x = Xn * lab2xyz(x);
    y = Yn * lab2xyz(y);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x - 1.6168667 * y - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x + 1.9161415 * y + 0.033454 * z),
      lrgb2rgb(0.0719453 * x - 0.2289914 * y + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}
function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}
function lrgb2rgb(x) {
  return 255 * (x <= 31308e-7 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * radians;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define_default(Hcl, hcl, extend12(Color, {
  brighter(k) {
    return new Hcl(this.h, this.c, this.l + K * (k == null ? 1 : k), this.opacity);
  },
  darker(k) {
    return new Hcl(this.h, this.c, this.l - K * (k == null ? 1 : k), this.opacity);
  },
  rgb() {
    return hcl2lab(this).rgb();
  }
}));

// node_modules/d3-color/src/cubehelix.js
var A = -0.14861;
var B = 1.78277;
var C = -0.29227;
var D = -0.90649;
var E = 1.97294;
var ED = E * D;
var EB = E * B;
var BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k = (E * (g - l) - C * bl) / D, s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)), h = s ? Math.atan2(k, bl) * degrees - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}
function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define_default(Cubehelix, cubehelix, extend12(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l = +this.l, a = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a * (A * cosh2 + B * sinh2)),
      255 * (l + a * (C * cosh2 + D * sinh2)),
      255 * (l + a * (E * cosh2)),
      this.opacity
    );
  }
}));

// node_modules/d3-interpolate/src/basis.js
function basis(t13, v0, v1, v2, v3) {
  var t22 = t13 * t13, t32 = t22 * t13;
  return ((1 - 3 * t13 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t13 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis_default(values) {
  var n = values.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/basisClosed.js
function basisClosed_default(values) {
  var n = values.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values[(i + n - 1) % n], v1 = values[i % n], v2 = values[(i + 1) % n], v3 = values[(i + 2) % n];
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}

// node_modules/d3-interpolate/src/constant.js
var constant_default = (x) => () => x;

// node_modules/d3-interpolate/src/color.js
function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant_default(isNaN(a) ? b : a);
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant_default(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant_default(isNaN(a) ? b : a);
}

// node_modules/d3-interpolate/src/rgb.js
var rgb_default = function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start, end) {
    var r = color2((start = rgb(start)).r, (end = rgb(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function rgbSpline(spline) {
  return function(colors) {
    var n = colors.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis_default);
var rgbBasisClosed = rgbSpline(basisClosed_default);

// node_modules/d3-interpolate/src/numberArray.js
function numberArray_default(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}

// node_modules/d3-interpolate/src/array.js
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x[i] = value_default(a[i], b[i]);
  for (; i < nb; ++i)
    c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c[i] = x[i](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/date.js
function date_default(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}

// node_modules/d3-interpolate/src/number.js
function number_default(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

// node_modules/d3-interpolate/src/object.js
function object_default(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = value_default(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c[k] = i[k](t);
    return c;
  };
}

// node_modules/d3-interpolate/src/string.js
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
var reB = new RegExp(reA.source, "g");
function zero4(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string_default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number_default(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero4(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}

// node_modules/d3-interpolate/src/value.js
function value_default(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c = color(b)) ? (b = c, rgb_default) : string_default : b instanceof color ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
}

// node_modules/d3-interpolate/src/round.js
function round_default(a, b) {
  return a = +a, b = +b, function(t) {
    return Math.round(a * (1 - t) + b * t);
  };
}

// node_modules/d3-interpolate/src/transform/decompose.js
var degrees2 = 180 / Math.PI;
var identity5 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose_default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b))
    a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d)
    c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d))
    c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c)
    a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees2,
    skewX: Math.atan(skewX) * degrees2,
    scaleX,
    scaleY
  };
}

// node_modules/d3-interpolate/src/transform/parse.js
var svgNode;
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity5 : decompose_default(m.a, m.b, m.c, m.d, m.e, m.f);
}
function parseSvg(value) {
  if (value == null)
    return identity5;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity5;
  value = value.matrix;
  return decompose_default(value.a, value.b, value.c, value.d, value.e, value.f);
}

// node_modules/d3-interpolate/src/transform/index.js
function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }
  function translate3(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate3(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180)
        b += 360;
      else if (b - a > 180)
        a += 360;
      q.push({ i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }
  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({ i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: number_default(a, b) });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }
  function scale7(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: number_default(xa, xb) }, { i: i - 2, x: number_default(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a, b) {
    var s = [], q = [];
    a = parse(a), b = parse(b);
    translate3(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate3(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale7(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

// node_modules/d3-interpolate/src/zoom.js
var epsilon2 = 1e-12;
function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}
function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}
function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
}
var zoom_default = function zoomRho(rho, rho2, rho4) {
  function zoom(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < epsilon2) {
      S = Math.log(w1 / w0) / rho;
      i = function(t) {
        return [
          ux0 + t * dx,
          uy0 + t * dy,
          w0 * Math.exp(rho * t * S)
        ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;
      i = function(t) {
        var s = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [
          ux0 + u * dx,
          uy0 + u * dy,
          w0 * coshr0 / cosh(rho * s + r0)
        ];
      };
    }
    i.duration = S * 1e3 * rho / Math.SQRT2;
    return i;
  }
  zoom.rho = function(_) {
    var _1 = Math.max(1e-3, +_), _2 = _1 * _1, _4 = _2 * _2;
    return zoomRho(_1, _2, _4);
  };
  return zoom;
}(Math.SQRT2, 2, 4);

// node_modules/d3-interpolate/src/hsl.js
function hsl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hsl(start)).h, (end = hsl(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hsl_default = hsl2(hue);
var hslLong = hsl2(nogamma);

// node_modules/d3-interpolate/src/hcl.js
function hcl2(hue2) {
  return function(start, end) {
    var h = hue2((start = hcl(start)).h, (end = hcl(end)).h), c = nogamma(start.c, end.c), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}
var hcl_default = hcl2(hue);
var hclLong = hcl2(nogamma);

// node_modules/d3-interpolate/src/cubehelix.js
function cubehelix2(hue2) {
  return function cubehelixGamma(y) {
    y = +y;
    function cubehelix3(start, end) {
      var h = hue2((start = cubehelix(start)).h, (end = cubehelix(end)).h), s = nogamma(start.s, end.s), l = nogamma(start.l, end.l), opacity = nogamma(start.opacity, end.opacity);
      return function(t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }
    cubehelix3.gamma = cubehelixGamma;
    return cubehelix3;
  }(1);
}
var cubehelix_default = cubehelix2(hue);
var cubehelixLong = cubehelix2(nogamma);

// node_modules/d3-scale/src/constant.js
function constants(x) {
  return function() {
    return x;
  };
}

// node_modules/d3-scale/src/number.js
function number2(x) {
  return +x;
}

// node_modules/d3-scale/src/continuous.js
var unit = [0, 1];
function identity6(x) {
  return x;
}
function normalize5(a, b) {
  return (b -= a = +a) ? function(x) {
    return (x - a) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper(a, b) {
  var t;
  if (a > b)
    t = a, a = b, b = t;
  return function(x) {
    return Math.max(a, Math.min(b, x));
  };
}
function bimap(domain, range2, interpolate) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0)
    d0 = normalize5(d1, d0), r0 = interpolate(r1, r0);
  else
    d0 = normalize5(d0, d1), r0 = interpolate(r0, r1);
  return function(x) {
    return r0(d0(x));
  };
}
function polymap(domain, range2, interpolate) {
  var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize5(domain[i], domain[i + 1]);
    r[i] = interpolate(range2[i], range2[i + 1]);
  }
  return function(x) {
    var i2 = bisect_default(domain, x, 1, j) - 1;
    return r[i2](d[i2](x));
  };
}
function copy6(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer() {
  var domain = unit, range2 = unit, interpolate = value_default, transform, untransform, unknown, clamp = identity6, piecewise2, output, input;
  function rescale() {
    var n = Math.min(domain.length, range2.length);
    if (clamp !== identity6)
      clamp = clamper(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap : bimap;
    output = input = null;
    return scale7;
  }
  function scale7(x) {
    return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise2(domain.map(transform), range2, interpolate)))(transform(clamp(x)));
  }
  scale7.invert = function(y) {
    return clamp(untransform((input || (input = piecewise2(range2, domain.map(transform), number_default)))(y)));
  };
  scale7.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number2), rescale()) : domain.slice();
  };
  scale7.range = function(_) {
    return arguments.length ? (range2 = Array.from(_), rescale()) : range2.slice();
  };
  scale7.rangeRound = function(_) {
    return range2 = Array.from(_), interpolate = round_default, rescale();
  };
  scale7.clamp = function(_) {
    return arguments.length ? (clamp = _ ? true : identity6, rescale()) : clamp !== identity6;
  };
  scale7.interpolate = function(_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };
  scale7.unknown = function(_) {
    return arguments.length ? (unknown = _, scale7) : unknown;
  };
  return function(t, u) {
    transform = t, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer()(identity6, identity6);
}

// node_modules/d3-format/src/formatDecimal.js
function formatDecimal_default(x) {
  return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
}
function formatDecimalParts(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x.slice(i + 1)
  ];
}

// node_modules/d3-format/src/exponent.js
function exponent_default(x) {
  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
}

// node_modules/d3-format/src/formatGroup.js
function formatGroup_default(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t = [], j = 0, g = grouping[0], length4 = 0;
    while (i > 0 && g > 0) {
      if (length4 + g + 1 > width)
        g = Math.max(1, width - length4);
      t.push(value.substring(i -= g, i + g));
      if ((length4 += g + 1) > width)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}

// node_modules/d3-format/src/formatNumerals.js
function formatNumerals_default(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}

// node_modules/d3-format/src/formatSpecifier.js
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};

// node_modules/d3-format/src/formatTrim.js
function formatTrim_default(s) {
  out:
    for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
}

// node_modules/d3-format/src/formatPrefixAuto.js
var prefixExponent;
function formatPrefixAuto_default(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
}

// node_modules/d3-format/src/formatRounded.js
function formatRounded_default(x, p) {
  var d = formatDecimalParts(x, p);
  if (!d)
    return x + "";
  var coefficient = d[0], exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}

// node_modules/d3-format/src/formatTypes.js
var formatTypes_default = {
  "%": (x, p) => (x * 100).toFixed(p),
  "b": (x) => Math.round(x).toString(2),
  "c": (x) => x + "",
  "d": formatDecimal_default,
  "e": (x, p) => x.toExponential(p),
  "f": (x, p) => x.toFixed(p),
  "g": (x, p) => x.toPrecision(p),
  "o": (x) => Math.round(x).toString(8),
  "p": (x, p) => formatRounded_default(x * 100, p),
  "r": formatRounded_default,
  "s": formatPrefixAuto_default,
  "X": (x) => Math.round(x).toString(16).toUpperCase(),
  "x": (x) => Math.round(x).toString(16)
};

// node_modules/d3-format/src/identity.js
function identity_default(x) {
  return x;
}

// node_modules/d3-format/src/locale.js
var map3 = Array.prototype.map;
var prefixes = ["y", "z", "a", "f", "p", "n", "", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function locale_default(locale3) {
  var group2 = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default : formatGroup_default(map3.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default : formatNumerals_default(map3.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero5 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n")
      comma = true, type = "g";
    else if (!formatTypes_default[type])
      precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero5 || fill === "0" && align === "=")
      zero5 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n, c;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim_default(value);
        if (valueNegative && +value === 0 && sign !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero5)
        value = group2(value, Infinity);
      var length4 = valuePrefix.length + value.length + valueSuffix.length, padding = length4 < width ? new Array(width - length4 + 1).join(fill) : "";
      if (comma && zero5)
        value = group2(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length4 = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length4);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e), prefix = prefixes[8 + e / 3];
    return function(value2) {
      return f(k * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}

// node_modules/d3-format/src/defaultLocale.js
var locale;
var format;
var formatPrefix;
defaultLocale({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale(definition) {
  locale = locale_default(definition);
  format = locale.format;
  formatPrefix = locale.formatPrefix;
  return locale;
}

// node_modules/d3-format/src/precisionFixed.js
function precisionFixed_default(step) {
  return Math.max(0, -exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionPrefix.js
function precisionPrefix_default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
}

// node_modules/d3-format/src/precisionRound.js
function precisionRound_default(step, max4) {
  step = Math.abs(step), max4 = Math.abs(max4) - step;
  return Math.max(0, exponent_default(max4) - exponent_default(step)) + 1;
}

// node_modules/d3-scale/src/tickFormat.js
function tickFormat(start, stop, count2, specifier) {
  var step = tickStep(start, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}

// node_modules/d3-scale/src/linear.js
function linearish(scale7) {
  var domain = scale7.domain;
  scale7.ticks = function(count2) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale7.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale7.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start = d[i0];
    var stop = d[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count2);
      if (step === prestep) {
        d[i0] = start;
        d[i1] = stop;
        return domain(d);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale7;
  };
  return scale7;
}
function linear2() {
  var scale7 = continuous();
  scale7.copy = function() {
    return copy6(scale7, linear2());
  };
  initRange.apply(scale7, arguments);
  return linearish(scale7);
}

// node_modules/d3-time/src/interval.js
var t02 = /* @__PURE__ */ new Date();
var t12 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count2, field) {
  function interval(date) {
    return floori(date = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date)), date;
  }
  interval.floor = (date) => {
    return floori(date = /* @__PURE__ */ new Date(+date)), date;
  };
  interval.ceil = (date) => {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };
  interval.round = (date) => {
    const d0 = interval(date), d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };
  interval.offset = (date, step) => {
    return offseti(date = /* @__PURE__ */ new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };
  interval.range = (start, stop, step) => {
    const range2 = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0))
      return range2;
    let previous;
    do
      range2.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range2;
  };
  interval.filter = (test) => {
    return timeInterval((date) => {
      if (date >= date)
        while (floori(date), !test(date))
          date.setTime(date - 1);
    }, (date, step) => {
      if (date >= date) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date, -1), !test(date)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date, 1), !test(date)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval.count = (start, end) => {
      t02.setTime(+start), t12.setTime(+end);
      floori(t02), floori(t12);
      return Math.floor(count2(t02, t12));
    };
    interval.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d) => field(d) % step === 0 : (d) => interval.count(0, d) % step === 0);
    };
  }
  return interval;
}

// node_modules/d3-time/src/millisecond.js
var millisecond = timeInterval(() => {
}, (date, step) => {
  date.setTime(+date + step);
}, (start, end) => {
  return end - start;
});
millisecond.every = (k) => {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0))
    return null;
  if (!(k > 1))
    return millisecond;
  return timeInterval((date) => {
    date.setTime(Math.floor(date / k) * k);
  }, (date, step) => {
    date.setTime(+date + step * k);
  }, (start, end) => {
    return (end - start) / k;
  });
};
var milliseconds = millisecond.range;

// node_modules/d3-time/src/duration.js
var durationSecond = 1e3;
var durationMinute = durationSecond * 60;
var durationHour = durationMinute * 60;
var durationDay = durationHour * 24;
var durationWeek = durationDay * 7;
var durationMonth = durationDay * 30;
var durationYear = durationDay * 365;

// node_modules/d3-time/src/second.js
var second = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds());
}, (date, step) => {
  date.setTime(+date + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date) => {
  return date.getUTCSeconds();
});
var seconds = second.range;

// node_modules/d3-time/src/minute.js
var timeMinute = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, (date, step) => {
  date.setTime(+date + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getMinutes();
});
var timeMinutes = timeMinute.range;
var utcMinute = timeInterval((date) => {
  date.setUTCSeconds(0, 0);
}, (date, step) => {
  date.setTime(+date + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getUTCMinutes();
});
var utcMinutes = utcMinute.range;

// node_modules/d3-time/src/hour.js
var timeHour = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, (date, step) => {
  date.setTime(+date + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getHours();
});
var timeHours = timeHour.range;
var utcHour = timeInterval((date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step) => {
  date.setTime(+date + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getUTCHours();
});
var utcHours = utcHour.range;

// node_modules/d3-time/src/day.js
var timeDay = timeInterval(
  (date) => date.setHours(0, 0, 0, 0),
  (date, step) => date.setDate(date.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date) => date.getDate() - 1
);
var timeDays = timeDay.range;
var utcDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCDate(date.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return date.getUTCDate() - 1;
});
var utcDays = utcDay.range;
var unixDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCDate(date.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return Math.floor(date / durationDay);
});
var unixDays = unixDay.range;

// node_modules/d3-time/src/week.js
function timeWeekday(i) {
  return timeInterval((date) => {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setDate(date.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
var timeSunday = timeWeekday(0);
var timeMonday = timeWeekday(1);
var timeTuesday = timeWeekday(2);
var timeWednesday = timeWeekday(3);
var timeThursday = timeWeekday(4);
var timeFriday = timeWeekday(5);
var timeSaturday = timeWeekday(6);
var timeSundays = timeSunday.range;
var timeMondays = timeMonday.range;
var timeTuesdays = timeTuesday.range;
var timeWednesdays = timeWednesday.range;
var timeThursdays = timeThursday.range;
var timeFridays = timeFriday.range;
var timeSaturdays = timeSaturday.range;
function utcWeekday(i) {
  return timeInterval((date) => {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;

// node_modules/d3-time/src/month.js
var timeMonth = timeInterval((date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step) => {
  date.setMonth(date.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date) => {
  return date.getMonth();
});
var timeMonths = timeMonth.range;
var utcMonth = timeInterval((date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCMonth(date.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date) => {
  return date.getUTCMonth();
});
var utcMonths = utcMonth.range;

// node_modules/d3-time/src/year.js
var timeYear = timeInterval((date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step) => {
  date.setFullYear(date.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date) => {
  return date.getFullYear();
});
timeYear.every = (k) => {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setFullYear(date.getFullYear() + step * k);
  });
};
var timeYears = timeYear.range;
var utcYear = timeInterval((date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date) => {
  return date.getUTCFullYear();
});
utcYear.every = (k) => {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};
var utcYears = utcYear.range;

// node_modules/d3-time/src/ticks.js
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start, stop, count2) {
    const reverse2 = stop < start;
    if (reverse2)
      [start, stop] = [stop, start];
    const interval = count2 && typeof count2.range === "function" ? count2 : tickInterval(start, stop, count2);
    const ticks3 = interval ? interval.range(start, +stop + 1) : [];
    return reverse2 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start, stop, count2) {
    const target = Math.abs(stop - start) / count2;
    const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i === tickIntervals.length)
      return year.every(tickStep(start / durationYear, stop / durationYear, count2));
    if (i === 0)
      return millisecond.every(Math.max(tickStep(start, stop, count2), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }
  return [ticks2, tickInterval];
}
var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

// node_modules/d3-time-format/src/locale.js
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y, m, d) {
  return { y, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale3) {
  var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date) {
      var string = [], i = -1, j = 0, n = specifier.length, c, pad2, format2;
      if (!(date instanceof Date))
        date = /* @__PURE__ */ new Date(+date);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad2 = pads[c = specifier.charAt(++i)]) != null)
            c = specifier.charAt(++i);
          else
            pad2 = c === "e" ? " " : "0";
          if (format2 = formats2[c])
            c = format2(date, pad2);
          string.push(c);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
      if (i != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m = string.length, c, parse;
    while (i < n) {
      if (j >= m)
        return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0)
          return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" };
var numberRe = /^\s*\d+/;
var percentRe = /^%/;
var requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length4 = string.length;
  return sign + (length4 < width ? new Array(width - length4 + 1).join(fill) + string : string);
}
function requote(s) {
  return s.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d, p) {
  return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  var day = d.getDay();
  return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day = d.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}

// node_modules/d3-time-format/src/defaultLocale.js
var locale2;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale2(definition) {
  locale2 = formatLocale(definition);
  timeFormat = locale2.format;
  timeParse = locale2.parse;
  utcFormat = locale2.utcFormat;
  utcParse = locale2.utcParse;
  return locale2;
}

// node_modules/d3-time-format/src/isoFormat.js
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date) {
  return date.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);

// node_modules/d3-time-format/src/isoParse.js
function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}
var parseIso = +/* @__PURE__ */ new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);

// node_modules/@kitware/vtk.js/Common/DataModel/ImplicitFunction.js
function vtkImplicitFunction(publicAPI, model) {
  model.classHierarchy.push("vtkImplicitFunction");
  publicAPI.functionValue = (xyz) => {
    if (!model.transform) {
      return publicAPI.evaluateFunction(xyz);
    }
    const transformedXYZ = [];
    model.transform.transformPoint(xyz, transformedXYZ);
    return publicAPI.evaluateFunction(transformedXYZ);
  };
  publicAPI.evaluateFunction = (_xyz) => {
    macro.vtkErrorMacro("not implemented");
  };
}
var DEFAULT_VALUES12 = {
  // transform : null
};
function extend13(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES12, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["transform"]);
  vtkImplicitFunction(publicAPI, model);
}
var newInstance13 = macro.newInstance(extend13, "vtkImplicitFunction");
var vtkImplicitFunction$1 = {
  newInstance: newInstance13,
  extend: extend13
};

// node_modules/@kitware/vtk.js/Common/DataModel/Plane.js
var PLANE_TOLERANCE = 1e-6;
var COINCIDE = "coincide";
var DISJOINT = "disjoint";
function evaluate(normal, origin, x) {
  return normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);
}
function distanceToPlane(x, origin, normal) {
  const distance3 = normal[0] * (x[0] - origin[0]) + normal[1] * (x[1] - origin[1]) + normal[2] * (x[2] - origin[2]);
  return Math.abs(distance3);
}
function projectPoint(x, origin, normal, xproj) {
  const xo = [];
  subtract(x, origin, xo);
  const t = dot(normal, xo);
  xproj[0] = x[0] - t * normal[0];
  xproj[1] = x[1] - t * normal[1];
  xproj[2] = x[2] - t * normal[2];
}
function projectVector(v, normal, vproj) {
  const t = dot(v, normal);
  let n2 = dot(normal, normal);
  if (n2 === 0) {
    n2 = 1;
  }
  vproj[0] = v[0] - t * normal[0] / n2;
  vproj[1] = v[1] - t * normal[1] / n2;
  vproj[2] = v[2] - t * normal[2] / n2;
  return vproj;
}
function generalizedProjectPoint(x, origin, normal, xproj) {
  const xo = [];
  subtract(x, origin, xo);
  const t = dot(normal, xo);
  const n2 = dot(normal, normal);
  if (n2 !== 0) {
    xproj[0] = x[0] - t * normal[0] / n2;
    xproj[1] = x[1] - t * normal[1] / n2;
    xproj[2] = x[2] - t * normal[2] / n2;
  } else {
    xproj[0] = x[0];
    xproj[1] = x[1];
    xproj[2] = x[2];
  }
}
function intersectWithLine(p1, p2, origin, normal) {
  const outObj = {
    intersection: false,
    betweenPoints: false,
    t: Number.MAX_VALUE,
    x: []
  };
  const p21 = [];
  const p1Origin = [];
  subtract(p2, p1, p21);
  subtract(origin, p1, p1Origin);
  const num = dot(normal, p1Origin);
  const den = dot(normal, p21);
  let fabsden;
  let fabstolerance;
  if (den < 0) {
    fabsden = -den;
  } else {
    fabsden = den;
  }
  if (num < 0) {
    fabstolerance = -num * PLANE_TOLERANCE;
  } else {
    fabstolerance = num * PLANE_TOLERANCE;
  }
  if (fabsden <= fabstolerance) {
    return outObj;
  }
  outObj.t = num / den;
  outObj.x[0] = p1[0] + outObj.t * p21[0];
  outObj.x[1] = p1[1] + outObj.t * p21[1];
  outObj.x[2] = p1[2] + outObj.t * p21[2];
  outObj.intersection = true;
  outObj.betweenPoints = outObj.t >= 0 && outObj.t <= 1;
  return outObj;
}
function intersectWithPlane(plane1Origin, plane1Normal, plane2Origin, plane2Normal) {
  const outObj = {
    intersection: false,
    l0: [],
    l1: [],
    error: null
  };
  const cross$1 = [];
  cross(plane1Normal, plane2Normal, cross$1);
  const absCross = cross$1.map((n) => Math.abs(n));
  if (absCross[0] + absCross[1] + absCross[2] < PLANE_TOLERANCE) {
    const v = [];
    subtract(plane1Origin, plane2Origin, v);
    if (dot(plane1Normal, v) === 0) {
      outObj.error = COINCIDE;
    } else {
      outObj.error = DISJOINT;
    }
    return outObj;
  }
  let maxc;
  if (absCross[0] > absCross[1] && absCross[0] > absCross[2]) {
    maxc = "x";
  } else if (absCross[1] > absCross[2]) {
    maxc = "y";
  } else {
    maxc = "z";
  }
  const iP = [];
  const d1 = -dot(plane1Normal, plane1Origin);
  const d2 = -dot(plane2Normal, plane2Origin);
  switch (maxc) {
    case "x":
      iP[0] = 0;
      iP[1] = (d2 * plane1Normal[2] - d1 * plane2Normal[2]) / cross$1[0];
      iP[2] = (d1 * plane2Normal[1] - d2 * plane1Normal[1]) / cross$1[0];
      break;
    case "y":
      iP[0] = (d1 * plane2Normal[2] - d2 * plane1Normal[2]) / cross$1[1];
      iP[1] = 0;
      iP[2] = (d2 * plane1Normal[0] - d1 * plane2Normal[0]) / cross$1[1];
      break;
    case "z":
      iP[0] = (d2 * plane1Normal[1] - d1 * plane2Normal[1]) / cross$1[2];
      iP[1] = (d1 * plane2Normal[0] - d2 * plane1Normal[0]) / cross$1[2];
      iP[2] = 0;
      break;
  }
  outObj.l0 = iP;
  add(iP, cross$1, outObj.l1);
  outObj.intersection = true;
  return outObj;
}
var STATIC2 = {
  evaluate,
  distanceToPlane,
  projectPoint,
  projectVector,
  generalizedProjectPoint,
  intersectWithLine,
  intersectWithPlane,
  DISJOINT,
  COINCIDE
};
function vtkPlane(publicAPI, model) {
  model.classHierarchy.push("vtkPlane");
  publicAPI.distanceToPlane = (x) => distanceToPlane(x, model.origin, model.normal);
  publicAPI.projectPoint = (x, xproj) => {
    projectPoint(x, model.origin, model.normal, xproj);
  };
  publicAPI.projectVector = (v, vproj) => projectVector(v, model.normal, vproj);
  publicAPI.push = (distance3) => {
    if (distance3 === 0) {
      return;
    }
    for (let i = 0; i < 3; i++) {
      model.origin[i] += distance3 * model.normal[i];
    }
  };
  publicAPI.generalizedProjectPoint = (x, xproj) => {
    generalizedProjectPoint(x, model.origin, model.normal, xproj);
  };
  publicAPI.evaluateFunction = (x, y, z) => {
    if (!Array.isArray(x)) {
      return model.normal[0] * (x - model.origin[0]) + model.normal[1] * (y - model.origin[1]) + model.normal[2] * (z - model.origin[2]);
    }
    return model.normal[0] * (x[0] - model.origin[0]) + model.normal[1] * (x[1] - model.origin[1]) + model.normal[2] * (x[2] - model.origin[2]);
  };
  publicAPI.evaluateGradient = (xyz) => {
    const retVal = [model.normal[0], model.normal[1], model.normal[2]];
    return retVal;
  };
  publicAPI.intersectWithLine = (p1, p2) => intersectWithLine(p1, p2, model.origin, model.normal);
  publicAPI.intersectWithPlane = (planeOrigin, planeNormal) => intersectWithPlane(planeOrigin, planeNormal, model.origin, model.normal);
}
var DEFAULT_VALUES13 = {
  normal: [0, 0, 1],
  origin: [0, 0, 0]
};
function extend14(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES13, initialValues);
  vtkImplicitFunction$1.extend(publicAPI, model, initialValues);
  macro.setGetArray(publicAPI, model, ["normal", "origin"], 3);
  vtkPlane(publicAPI, model);
}
var newInstance14 = macro.newInstance(extend14, "vtkPlane");
var vtkPlane$1 = {
  newInstance: newInstance14,
  extend: extend14,
  ...STATIC2
};

// node_modules/@kitware/vtk.js/Common/DataModel/BoundingBox.js
var INIT_BOUNDS = [
  Number.MAX_VALUE,
  -Number.MAX_VALUE,
  // X
  Number.MAX_VALUE,
  -Number.MAX_VALUE,
  // Y
  Number.MAX_VALUE,
  -Number.MAX_VALUE
  // Z
];
function equals7(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}
function isValid(bounds) {
  return (bounds == null ? void 0 : bounds.length) >= 6 && bounds[0] <= bounds[1] && bounds[2] <= bounds[3] && bounds[4] <= bounds[5];
}
function setBounds(bounds, otherBounds) {
  bounds[0] = otherBounds[0];
  bounds[1] = otherBounds[1];
  bounds[2] = otherBounds[2];
  bounds[3] = otherBounds[3];
  bounds[4] = otherBounds[4];
  bounds[5] = otherBounds[5];
  return bounds;
}
function reset(bounds) {
  return setBounds(bounds, INIT_BOUNDS);
}
function addPoint(bounds, x, y, z) {
  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
  bounds[0] = xMin < x ? xMin : x;
  bounds[1] = xMax > x ? xMax : x;
  bounds[2] = yMin < y ? yMin : y;
  bounds[3] = yMax > y ? yMax : y;
  bounds[4] = zMin < z ? zMin : z;
  bounds[5] = zMax > z ? zMax : z;
  return bounds;
}
function addPoints(bounds, points) {
  if (points.length === 0) {
    return bounds;
  }
  if (Array.isArray(points[0])) {
    for (let i = 0; i < points.length; ++i) {
      addPoint(bounds, ...points[i]);
    }
  } else {
    for (let i = 0; i < points.length; i += 3) {
      addPoint(bounds, ...points.slice(i, i + 3));
    }
  }
  return bounds;
}
function addBounds(bounds, xMin, xMax, yMin, yMax, zMin, zMax) {
  const [_xMin, _xMax, _yMin, _yMax, _zMin, _zMax] = bounds;
  if (zMax === void 0) {
    bounds[0] = Math.min(xMin[0], _xMin);
    bounds[1] = Math.max(xMin[1], _xMax);
    bounds[2] = Math.min(xMin[2], _yMin);
    bounds[3] = Math.max(xMin[3], _yMax);
    bounds[4] = Math.min(xMin[4], _zMin);
    bounds[5] = Math.max(xMin[5], _zMax);
  } else {
    bounds[0] = Math.min(xMin, _xMin);
    bounds[1] = Math.max(xMax, _xMax);
    bounds[2] = Math.min(yMin, _yMin);
    bounds[3] = Math.max(yMax, _yMax);
    bounds[4] = Math.min(zMin, _zMin);
    bounds[5] = Math.max(zMax, _zMax);
  }
  return bounds;
}
function setMinPoint(bounds, x, y, z) {
  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
  bounds[0] = x;
  bounds[1] = x > xMax ? x : xMax;
  bounds[2] = y;
  bounds[3] = y > yMax ? y : yMax;
  bounds[4] = z;
  bounds[5] = z > zMax ? z : zMax;
  return xMin !== x || yMin !== y || zMin !== z;
}
function setMaxPoint(bounds, x, y, z) {
  const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;
  bounds[0] = x < xMin ? x : xMin;
  bounds[1] = x;
  bounds[2] = y < yMin ? y : yMin;
  bounds[3] = y;
  bounds[4] = z < zMin ? z : zMin;
  bounds[5] = z;
  return xMax !== x || yMax !== y || zMax !== z;
}
function inflate(bounds, delta) {
  if (delta == null) {
    return minInflate(bounds);
  }
  bounds[0] -= delta;
  bounds[1] += delta;
  bounds[2] -= delta;
  bounds[3] += delta;
  bounds[4] -= delta;
  bounds[5] += delta;
  return bounds;
}
function minInflate(bounds) {
  const nonZero = [0, 0, 0];
  let maxIdx = -1;
  let max4 = 0;
  let w = 0;
  for (let i = 0; i < 3; ++i) {
    w = bounds[i * 2 + 1] - bounds[i * 2];
    if (w > max4) {
      max4 = w;
      maxIdx = i;
    }
    nonZero[i] = w > 0 ? 1 : 0;
  }
  if (maxIdx < 0) {
    return inflate(bounds, 0.5);
  }
  for (let i = 0; i < 3; ++i) {
    if (!nonZero[i]) {
      const d = 5e-3 * max4;
      bounds[i * 2] -= d;
      bounds[i * 2 + 1] += d;
    }
  }
  return bounds;
}
function scale6(bounds, sx, sy, sz) {
  if (!isValid(bounds)) {
    return false;
  }
  if (sx >= 0) {
    bounds[0] *= sx;
    bounds[1] *= sx;
  } else {
    bounds[0] = sx * bounds[1];
    bounds[1] = sx * bounds[0];
  }
  if (sy >= 0) {
    bounds[2] *= sy;
    bounds[3] *= sy;
  } else {
    bounds[2] = sy * bounds[3];
    bounds[3] = sy * bounds[2];
  }
  if (sz >= 0) {
    bounds[4] *= sz;
    bounds[5] *= sz;
  } else {
    bounds[4] = sz * bounds[5];
    bounds[5] = sz * bounds[4];
  }
  return true;
}
function getCenter(bounds) {
  return [0.5 * (bounds[0] + bounds[1]), 0.5 * (bounds[2] + bounds[3]), 0.5 * (bounds[4] + bounds[5])];
}
function scaleAboutCenter(bounds, sx, sy, sz) {
  if (!isValid(bounds)) {
    return false;
  }
  const center = getCenter(bounds);
  bounds[0] -= center[0];
  bounds[1] -= center[0];
  bounds[2] -= center[1];
  bounds[3] -= center[1];
  bounds[4] -= center[2];
  bounds[5] -= center[2];
  scale6(bounds, sx, sy, sz);
  bounds[0] += center[0];
  bounds[1] += center[0];
  bounds[2] += center[1];
  bounds[3] += center[1];
  bounds[4] += center[2];
  bounds[5] += center[2];
  return true;
}
function getLength(bounds, index2) {
  return bounds[index2 * 2 + 1] - bounds[index2 * 2];
}
function getLengths(bounds) {
  return [getLength(bounds, 0), getLength(bounds, 1), getLength(bounds, 2)];
}
function getXRange(bounds) {
  return bounds.slice(0, 2);
}
function getYRange(bounds) {
  return bounds.slice(2, 4);
}
function getZRange(bounds) {
  return bounds.slice(4, 6);
}
function getMaxLength(bounds) {
  const l = getLengths(bounds);
  if (l[0] > l[1]) {
    if (l[0] > l[2]) {
      return l[0];
    }
    return l[2];
  }
  if (l[1] > l[2]) {
    return l[1];
  }
  return l[2];
}
function getDiagonalLength2(bounds) {
  if (isValid(bounds)) {
    const l = getLengths(bounds);
    return l[0] * l[0] + l[1] * l[1] + l[2] * l[2];
  }
  return null;
}
function getDiagonalLength(bounds) {
  const lenght2 = getDiagonalLength2(bounds);
  return lenght2 !== null ? Math.sqrt(lenght2) : null;
}
function getMinPoint(bounds) {
  return [bounds[0], bounds[2], bounds[4]];
}
function getMaxPoint(bounds) {
  return [bounds[1], bounds[3], bounds[5]];
}
function oppositeSign(a, b) {
  return a <= 0 && b >= 0 || a >= 0 && b <= 0;
}
function getCorners(bounds, corners) {
  corners[0] = [bounds[0], bounds[2], bounds[4]];
  corners[1] = [bounds[0], bounds[2], bounds[5]];
  corners[2] = [bounds[0], bounds[3], bounds[4]];
  corners[3] = [bounds[0], bounds[3], bounds[5]];
  corners[4] = [bounds[1], bounds[2], bounds[4]];
  corners[5] = [bounds[1], bounds[2], bounds[5]];
  corners[6] = [bounds[1], bounds[3], bounds[4]];
  corners[7] = [bounds[1], bounds[3], bounds[5]];
  return corners;
}
function computeCornerPoints(bounds, point1, point2) {
  point1[0] = bounds[0];
  point1[1] = bounds[2];
  point1[2] = bounds[4];
  point2[0] = bounds[1];
  point2[1] = bounds[3];
  point2[2] = bounds[5];
  return point1;
}
function transformBounds(bounds, transform) {
  let out = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  const corners = getCorners(bounds, []);
  for (let i = 0; i < corners.length; ++i) {
    vec3_exports.transformMat4(corners[i], corners[i], transform);
  }
  reset(out);
  return addPoints(out, corners);
}
function computeScale3(bounds) {
  let scale32 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  scale32[0] = 0.5 * (bounds[1] - bounds[0]);
  scale32[1] = 0.5 * (bounds[3] - bounds[2]);
  scale32[2] = 0.5 * (bounds[5] - bounds[4]);
  return scale32;
}
function computeLocalBounds(points, u, v, w) {
  const bounds = [].concat(INIT_BOUNDS);
  const pointsData = points.getData();
  for (let i = 0; i < pointsData.length; i += 3) {
    const point2 = [pointsData[i], pointsData[i + 1], pointsData[i + 2]];
    const du = dot(point2, u);
    bounds[0] = Math.min(du, bounds[0]);
    bounds[1] = Math.max(du, bounds[1]);
    const dv = dot(point2, v);
    bounds[2] = Math.min(dv, bounds[2]);
    bounds[3] = Math.max(dv, bounds[3]);
    const dw = dot(point2, w);
    bounds[4] = Math.min(dw, bounds[4]);
    bounds[5] = Math.max(dw, bounds[5]);
  }
  return bounds;
}
function intersectBox(bounds, origin, dir, coord, tolerance) {
  let inside = true;
  const quadrant = [];
  let whichPlane = 0;
  const maxT = [];
  const candidatePlane = [0, 0, 0];
  const RIGHT = 0;
  const LEFT = 1;
  const MIDDLE = 2;
  for (let i = 0; i < 3; i++) {
    if (origin[i] < bounds[2 * i]) {
      quadrant[i] = LEFT;
      candidatePlane[i] = bounds[2 * i];
      inside = false;
    } else if (origin[i] > bounds[2 * i + 1]) {
      quadrant[i] = RIGHT;
      candidatePlane[i] = bounds[2 * i + 1];
      inside = false;
    } else {
      quadrant[i] = MIDDLE;
    }
  }
  if (inside) {
    coord[0] = origin[0];
    coord[1] = origin[1];
    coord[2] = origin[2];
    tolerance[0] = 0;
    return 1;
  }
  for (let i = 0; i < 3; i++) {
    if (quadrant[i] !== MIDDLE && dir[i] !== 0) {
      maxT[i] = (candidatePlane[i] - origin[i]) / dir[i];
    } else {
      maxT[i] = -1;
    }
  }
  for (let i = 0; i < 3; i++) {
    if (maxT[whichPlane] < maxT[i]) {
      whichPlane = i;
    }
  }
  if (maxT[whichPlane] > 1 || maxT[whichPlane] < 0) {
    return 0;
  }
  tolerance[0] = maxT[whichPlane];
  for (let i = 0; i < 3; i++) {
    if (whichPlane !== i) {
      coord[i] = origin[i] + maxT[whichPlane] * dir[i];
      if (coord[i] < bounds[2 * i] || coord[i] > bounds[2 * i + 1]) {
        return 0;
      }
    } else {
      coord[i] = candidatePlane[i];
    }
  }
  return 1;
}
function intersectPlane(bounds, origin, normal) {
  const p = [];
  let d = 0;
  let sign = 1;
  let firstOne = 1;
  for (let z = 4; z <= 5; ++z) {
    p[2] = bounds[z];
    for (let y = 2; y <= 3; ++y) {
      p[1] = bounds[y];
      for (let x = 0; x <= 1; ++x) {
        p[0] = bounds[x];
        d = vtkPlane$1.evaluate(normal, origin, p);
        if (firstOne) {
          sign = d >= 0 ? 1 : -1;
          firstOne = 0;
        }
        if (d === 0 || sign > 0 && d < 0 || sign < 0 && d > 0) {
          return 1;
        }
      }
    }
  }
  return 0;
}
function intersect(bounds, bBounds) {
  if (!(isValid(bounds) && isValid(bBounds))) {
    return false;
  }
  const newBounds = [0, 0, 0, 0, 0, 0];
  let intersection3;
  for (let i = 0; i < 3; i++) {
    intersection3 = false;
    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {
      intersection3 = true;
      newBounds[i * 2] = bBounds[i * 2];
    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {
      intersection3 = true;
      newBounds[i * 2] = bounds[i * 2];
    }
    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {
      intersection3 = true;
      newBounds[i * 2 + 1] = bBounds[2 * i + 1];
    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {
      intersection3 = true;
      newBounds[i * 2 + 1] = bounds[i * 2 + 1];
    }
    if (!intersection3) {
      return false;
    }
  }
  bounds[0] = newBounds[0];
  bounds[1] = newBounds[1];
  bounds[2] = newBounds[2];
  bounds[3] = newBounds[3];
  bounds[4] = newBounds[4];
  bounds[5] = newBounds[5];
  return true;
}
function intersects(bounds, bBounds) {
  if (!(isValid(bounds) && isValid(bBounds))) {
    return false;
  }
  for (let i = 0; i < 3; i++) {
    if (bBounds[i * 2] >= bounds[i * 2] && bBounds[i * 2] <= bounds[i * 2 + 1]) {
      continue;
    } else if (bounds[i * 2] >= bBounds[i * 2] && bounds[i * 2] <= bBounds[i * 2 + 1]) {
      continue;
    }
    if (bBounds[i * 2 + 1] >= bounds[i * 2] && bBounds[i * 2 + 1] <= bounds[i * 2 + 1]) {
      continue;
    } else if (bounds[i * 2 + 1] >= bBounds[i * 2] && bounds[i * 2 + 1] <= bBounds[i * 2 + 1]) {
      continue;
    }
    return false;
  }
  return true;
}
function containsPoint(bounds, x, y, z) {
  if (x < bounds[0] || x > bounds[1]) {
    return false;
  }
  if (y < bounds[2] || y > bounds[3]) {
    return false;
  }
  if (z < bounds[4] || z > bounds[5]) {
    return false;
  }
  return true;
}
function contains(bounds, otherBounds) {
  if (!intersects(bounds, otherBounds)) {
    return false;
  }
  if (!containsPoint(bounds, ...getMinPoint(otherBounds))) {
    return false;
  }
  if (!containsPoint(bounds, ...getMaxPoint(otherBounds))) {
    return false;
  }
  return true;
}
function cutWithPlane(bounds, origin, normal) {
  const index2 = [[0, 1, 2, 3, 4, 5, 6, 7], [0, 1, 4, 5, 2, 3, 6, 7], [0, 2, 4, 6, 1, 3, 5, 7]];
  const d = [0, 0, 0, 0, 0, 0, 0, 0];
  let idx = 0;
  for (let ix = 0; ix < 2; ix++) {
    for (let iy = 2; iy < 4; iy++) {
      for (let iz = 4; iz < 6; iz++) {
        const x = [bounds[ix], bounds[iy], bounds[iz]];
        d[idx++] = vtkPlane$1.evaluate(normal, origin, x);
      }
    }
  }
  let dir = 2;
  while (dir--) {
    if (oppositeSign(d[index2[dir][0]], d[index2[dir][4]]) && oppositeSign(d[index2[dir][1]], d[index2[dir][5]]) && oppositeSign(d[index2[dir][2]], d[index2[dir][6]]) && oppositeSign(d[index2[dir][3]], d[index2[dir][7]])) {
      break;
    }
  }
  if (dir < 0) {
    return false;
  }
  const sign = Math.sign(normal[dir]);
  const size = Math.abs((bounds[dir * 2 + 1] - bounds[dir * 2]) * normal[dir]);
  let t = sign > 0 ? 1 : 0;
  for (let i = 0; i < 4; i++) {
    if (size === 0) {
      continue;
    }
    const ti = Math.abs(d[index2[dir][i]]) / size;
    if (sign > 0 && ti < t) {
      t = ti;
    }
    if (sign < 0 && ti > t) {
      t = ti;
    }
  }
  const bound = (1 - t) * bounds[dir * 2] + t * bounds[dir * 2 + 1];
  if (sign > 0) {
    bounds[dir * 2] = bound;
  } else {
    bounds[dir * 2 + 1] = bound;
  }
  return true;
}
function clampDivisions(targetBins, divs) {
  for (let i = 0; i < 3; ++i) {
    divs[i] = divs[i] < 1 ? 1 : divs[i];
  }
  let numBins = divs[0] * divs[1] * divs[2];
  while (numBins > targetBins) {
    for (let i = 0; i < 3; ++i) {
      divs[i] = divs[i] > 1 ? divs[i] - 1 : 1;
    }
    numBins = divs[0] * divs[1] * divs[2];
  }
}
function computeDivisions(bounds, totalBins, divs) {
  let adjustedBounds = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
  totalBins = totalBins <= 0 ? 1 : totalBins;
  let numNonZero = 0;
  const nonZero = [0, 0, 0];
  let maxIdx = -1;
  let max4 = 0;
  const lengths = getLengths(bounds);
  const totLen = lengths[0] + lengths[1] + lengths[2];
  const zeroDetectionTolerance = totLen * (1e-3 / 3);
  for (let i = 0; i < 3; ++i) {
    if (lengths[i] > max4) {
      maxIdx = i;
      max4 = lengths[i];
    }
    if (lengths[i] > zeroDetectionTolerance) {
      nonZero[i] = 1;
      numNonZero++;
    } else {
      nonZero[i] = 0;
    }
  }
  const minPoint = getMinPoint(bounds);
  const maxPoint = getMaxPoint(bounds);
  if (numNonZero < 1) {
    divs[0] = 1;
    divs[1] = 1;
    divs[2] = 1;
    adjustedBounds[0] = minPoint[0] - 0.5;
    adjustedBounds[1] = maxPoint[0] + 0.5;
    adjustedBounds[2] = minPoint[1] - 0.5;
    adjustedBounds[3] = maxPoint[1] + 0.5;
    adjustedBounds[4] = minPoint[2] - 0.5;
    adjustedBounds[5] = maxPoint[2] + 0.5;
    return 1;
  }
  let f = totalBins;
  f /= nonZero[0] ? lengths[0] / totLen : 1;
  f /= nonZero[1] ? lengths[1] / totLen : 1;
  f /= nonZero[2] ? lengths[2] / totLen : 1;
  f **= 1 / numNonZero;
  for (let i = 0; i < 3; ++i) {
    divs[i] = nonZero[i] ? Math.floor(f * lengths[i] / totLen) : 1;
    divs[i] = divs[i] < 1 ? 1 : divs[i];
  }
  clampDivisions(totalBins, divs);
  const delta = 0.5 * lengths[maxIdx] / divs[maxIdx];
  for (let i = 0; i < 3; ++i) {
    if (nonZero[i]) {
      adjustedBounds[2 * i] = minPoint[i];
      adjustedBounds[2 * i + 1] = maxPoint[i];
    } else {
      adjustedBounds[2 * i] = minPoint[i] - delta;
      adjustedBounds[2 * i + 1] = maxPoint[i] + delta;
    }
  }
  return divs[0] * divs[1] * divs[2];
}
function distance2ToBounds(x, bounds) {
  if (x[0] >= bounds[0] && x[0] <= bounds[1] && x[1] >= bounds[2] && x[1] <= bounds[3] && x[2] >= bounds[4] && x[2] <= bounds[5]) {
    return 0;
  }
  const deltas = [0, 0, 0];
  if (x[0] < bounds[0]) {
    deltas[0] = bounds[0] - x[0];
  } else if (x[0] > bounds[1]) {
    deltas[0] = x[0] - bounds[1];
  }
  if (x[1] < bounds[2]) {
    deltas[1] = bounds[2] - x[1];
  } else if (x[1] > bounds[3]) {
    deltas[1] = x[1] - bounds[3];
  }
  if (x[2] < bounds[4]) {
    deltas[2] = bounds[4] - x[2];
  } else if (x[2] > bounds[5]) {
    deltas[2] = x[2] - bounds[5];
  }
  return dot(deltas, deltas);
}
var BoundingBox = class {
  constructor(refBounds) {
    this.bounds = refBounds;
    if (!this.bounds) {
      this.bounds = new Float64Array(INIT_BOUNDS);
    }
  }
  getBounds() {
    return this.bounds;
  }
  equals(otherBounds) {
    return equals7(this.bounds, otherBounds);
  }
  isValid() {
    return isValid(this.bounds);
  }
  setBounds(otherBounds) {
    return setBounds(this.bounds, otherBounds);
  }
  reset() {
    return reset(this.bounds);
  }
  addPoint() {
    for (var _len = arguments.length, xyz = new Array(_len), _key = 0; _key < _len; _key++) {
      xyz[_key] = arguments[_key];
    }
    return addPoint(this.bounds, ...xyz);
  }
  addPoints(points) {
    return addPoints(this.bounds, points);
  }
  addBounds(xMin, xMax, yMin, yMax, zMin, zMax) {
    return addBounds(this.bounds, xMin, xMax, yMin, yMax, zMin, zMax);
  }
  setMinPoint(x, y, z) {
    return setMinPoint(this.bounds, x, y, z);
  }
  setMaxPoint(x, y, z) {
    return setMaxPoint(this.bounds, x, y, z);
  }
  inflate(delta) {
    return inflate(this.bounds, delta);
  }
  scale(sx, sy, sz) {
    return scale6(this.bounds, sx, sy, sz);
  }
  getCenter() {
    return getCenter(this.bounds);
  }
  getLength(index2) {
    return getLength(this.bounds, index2);
  }
  getLengths() {
    return getLengths(this.bounds);
  }
  getMaxLength() {
    return getMaxLength(this.bounds);
  }
  getDiagonalLength() {
    return getDiagonalLength(this.bounds);
  }
  getDiagonalLength2() {
    return getDiagonalLength2(this.bounds);
  }
  getMinPoint() {
    return getMinPoint(this.bounds);
  }
  getMaxPoint() {
    return getMaxPoint(this.bounds);
  }
  getXRange() {
    return getXRange(this.bounds);
  }
  getYRange() {
    return getYRange(this.bounds);
  }
  getZRange() {
    return getZRange(this.bounds);
  }
  getCorners(corners) {
    return getCorners(this.bounds, corners);
  }
  computeCornerPoints(point1, point2) {
    return computeCornerPoints(this.bounds, point1, point2);
  }
  computeLocalBounds(u, v, w) {
    return computeLocalBounds(this.bounds, u, v, w);
  }
  transformBounds(transform) {
    let out = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return transformBounds(this.bounds, transform, out);
  }
  computeScale3(scale32) {
    return computeScale3(this.bounds, scale32);
  }
  cutWithPlane(origin, normal) {
    return cutWithPlane(this.bounds, origin, normal);
  }
  intersectBox(origin, dir, coord, tolerance) {
    return intersectBox(this.bounds, origin, dir, coord, tolerance);
  }
  intersectPlane(origin, normal) {
    return intersectPlane(this.bounds, origin, normal);
  }
  intersect(otherBounds) {
    return intersect(this.bounds, otherBounds);
  }
  intersects(otherBounds) {
    return intersects(this.bounds, otherBounds);
  }
  containsPoint(x, y, z) {
    return containsPoint(this.bounds, x, y, z);
  }
  contains(otherBounds) {
    return intersects(this.bounds, otherBounds);
  }
  computeDivisions(totalBins, divs) {
    let adjustedBounds = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
    return computeDivisions(this.bounds, totalBins, divs, adjustedBounds);
  }
  distance2ToBounds(x) {
    return distance2ToBounds(x, this.bounds);
  }
};
function newInstance15(initialValues) {
  const bounds = initialValues && initialValues.bounds;
  return new BoundingBox(bounds);
}
var STATIC3 = {
  equals: equals7,
  isValid,
  setBounds,
  reset,
  addPoint,
  addPoints,
  addBounds,
  setMinPoint,
  setMaxPoint,
  inflate,
  scale: scale6,
  scaleAboutCenter,
  getCenter,
  getLength,
  getLengths,
  getMaxLength,
  getDiagonalLength,
  getDiagonalLength2,
  getMinPoint,
  getMaxPoint,
  getXRange,
  getYRange,
  getZRange,
  getCorners,
  computeCornerPoints,
  computeLocalBounds,
  transformBounds,
  computeScale3,
  cutWithPlane,
  intersectBox,
  intersectPlane,
  intersect,
  intersects,
  containsPoint,
  contains,
  computeDivisions,
  clampDivisions,
  distance2ToBounds,
  INIT_BOUNDS
};
var vtkBoundingBox = {
  newInstance: newInstance15,
  ...STATIC3
};

// node_modules/@kitware/vtk.js/Rendering/Core/Prop/Constants.js
var CoordinateSystem = {
  DISPLAY: 0,
  WORLD: 1
};
var Constants2 = {
  CoordinateSystem
};

// node_modules/@kitware/vtk.js/Rendering/Core/Prop.js
var {
  CoordinateSystem: CoordinateSystem2
} = Constants2;
function notImplemented(method) {
  return () => macro.vtkErrorMacro(`vtkProp::${method} - NOT IMPLEMENTED`);
}
function vtkProp(publicAPI, model) {
  model.classHierarchy.push("vtkProp");
  publicAPI.getMTime = () => {
    let m1 = model.mtime;
    for (let index2 = 0; index2 < model.textures.length; ++index2) {
      const m2 = model.textures[index2].getMTime();
      if (m2 > m1) {
        m1 = m2;
      }
    }
    return m1;
  };
  publicAPI.processSelectorPixelBuffers = (selector, pixeloffsets) => {
  };
  publicAPI.getNestedProps = () => null;
  publicAPI.getActors = () => [];
  publicAPI.getActors2D = () => [];
  publicAPI.getVolumes = () => [];
  publicAPI.pick = notImplemented("pick");
  publicAPI.hasKey = notImplemented("hasKey");
  publicAPI.getNestedVisibility = () => model.visibility && (!model._parentProp || model._parentProp.getNestedVisibility());
  publicAPI.getNestedPickable = () => model.pickable && (!model._parentProp || model._parentProp.getNestedPickable());
  publicAPI.getNestedDragable = () => model.dragable && (!model._parentProp || model._parentProp.getNestedDragable());
  publicAPI.getRedrawMTime = () => model.mtime;
  publicAPI.setEstimatedRenderTime = (t) => {
    model.estimatedRenderTime = t;
    model.savedEstimatedRenderTime = t;
  };
  publicAPI.restoreEstimatedRenderTime = () => {
    model.estimatedRenderTime = model.savedEstimatedRenderTime;
  };
  publicAPI.addEstimatedRenderTime = (t) => {
    model.estimatedRenderTime += t;
  };
  publicAPI.setAllocatedRenderTime = (t) => {
    model.allocatedRenderTime = t;
    model.savedEstimatedRenderTime = model.estimatedRenderTime;
    model.estimatedRenderTime = 0;
  };
  publicAPI.getSupportsSelection = () => false;
  publicAPI.getTextures = () => model.textures;
  publicAPI.hasTexture = (texture) => model.textures.indexOf(texture) !== -1;
  publicAPI.addTexture = (texture) => {
    if (texture && !publicAPI.hasTexture(texture)) {
      model.textures = model.textures.concat(texture);
      publicAPI.modified();
    }
  };
  publicAPI.removeTexture = (texture) => {
    const newTextureList = model.textures.filter((item) => item !== texture);
    if (model.textures.length !== newTextureList.length) {
      model.textures = newTextureList;
      publicAPI.modified();
    }
  };
  publicAPI.removeAllTextures = () => {
    model.textures = [];
    publicAPI.modified();
  };
  publicAPI.setCoordinateSystemToWorld = () => publicAPI.setCoordinateSystem(CoordinateSystem2.WORLD);
  publicAPI.setCoordinateSystemToDisplay = () => publicAPI.setCoordinateSystem(CoordinateSystem2.DISPLAY);
}
var DEFAULT_VALUES14 = {
  // _parentProp: null,
  allocatedRenderTime: 10,
  coordinateSystem: CoordinateSystem2.WORLD,
  dragable: true,
  estimatedRenderTime: 0,
  paths: null,
  pickable: true,
  renderTimeMultiplier: 1,
  savedEstimatedRenderTime: 0,
  textures: [],
  useBounds: true,
  visibility: true
};
function extend15(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES14, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["estimatedRenderTime", "allocatedRenderTime"]);
  macro.setGet(publicAPI, model, ["_parentProp", "coordinateSystem", "dragable", "pickable", "renderTimeMultiplier", "useBounds", "visibility"]);
  macro.moveToProtected(publicAPI, model, ["parentProp"]);
  vtkProp(publicAPI, model);
}
var newInstance16 = macro.newInstance(extend15, "vtkProp");
var vtkProp$1 = {
  newInstance: newInstance16,
  extend: extend15,
  ...Constants2
};

// node_modules/@kitware/vtk.js/Rendering/Core/Prop3D.js
var VTK_EPSILON = 1e-6;
function vtkProp3D(publicAPI, model) {
  model.classHierarchy.push("vtkProp3D");
  publicAPI.addPosition = (deltaXYZ) => {
    model.position = model.position.map((value, index2) => value + deltaXYZ[index2]);
    publicAPI.modified();
  };
  publicAPI.getOrientationWXYZ = () => {
    const q = quat_exports.create();
    mat4_exports.getRotation(q, model.rotation);
    const oaxis = new Float64Array(3);
    const w = quat_exports.getAxisAngle(oaxis, q);
    return [degreesFromRadians(w), oaxis[0], oaxis[1], oaxis[2]];
  };
  publicAPI.getOrientationQuaternion = function() {
    let out = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return mat4_exports.getRotation(out, model.rotation);
  };
  publicAPI.rotateX = (val) => {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateX(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateY = (val) => {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateY(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateZ = (val) => {
    if (val === 0) {
      return;
    }
    mat4_exports.rotateZ(model.rotation, model.rotation, radiansFromDegrees(val));
    publicAPI.modified();
  };
  publicAPI.rotateWXYZ = (degrees3, x, y, z) => {
    if (degrees3 === 0 || x === 0 && y === 0 && z === 0) {
      return;
    }
    const angle2 = radiansFromDegrees(degrees3);
    const q = quat_exports.create();
    quat_exports.setAxisAngle(q, [x, y, z], angle2);
    const quatMat = new Float64Array(16);
    mat4_exports.fromQuat(quatMat, q);
    mat4_exports.multiply(model.rotation, model.rotation, quatMat);
    publicAPI.modified();
  };
  publicAPI.rotateQuaternion = (orientationQuaternion) => {
    if (Math.abs(orientationQuaternion[3]) >= 1 - VTK_EPSILON) {
      return;
    }
    const oriQuatMat = mat4_exports.fromQuat(new Float64Array(16), orientationQuaternion);
    mat4_exports.multiply(model.rotation, model.rotation, oriQuatMat);
    publicAPI.modified();
  };
  publicAPI.setOrientation = (x, y, z) => {
    if (x === model.orientation[0] && y === model.orientation[1] && z === model.orientation[2]) {
      return false;
    }
    model.orientation = [x, y, z];
    mat4_exports.identity(model.rotation);
    publicAPI.rotateZ(z);
    publicAPI.rotateX(x);
    publicAPI.rotateY(y);
    publicAPI.modified();
    return true;
  };
  publicAPI.setOrientationFromQuaternion = (q) => {
    const rotation = mat4_exports.create();
    mat4_exports.fromQuat(rotation, q);
    if (!areMatricesEqual(rotation, model.rotation)) {
      model.rotation = rotation;
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.setUserMatrix = (matrix) => {
    if (areMatricesEqual(model.userMatrix, matrix)) {
      return false;
    }
    mat4_exports.copy(model.userMatrix, matrix);
    publicAPI.modified();
    return true;
  };
  publicAPI.getMatrix = () => {
    publicAPI.computeMatrix();
    return model.matrix;
  };
  publicAPI.computeMatrix = () => {
    if (publicAPI.getMTime() > model.matrixMTime.getMTime()) {
      mat4_exports.identity(model.matrix);
      if (model.userMatrix) {
        mat4_exports.multiply(model.matrix, model.matrix, model.userMatrix);
      }
      mat4_exports.translate(model.matrix, model.matrix, model.origin);
      mat4_exports.translate(model.matrix, model.matrix, model.position);
      mat4_exports.multiply(model.matrix, model.matrix, model.rotation);
      mat4_exports.scale(model.matrix, model.matrix, model.scale);
      mat4_exports.translate(model.matrix, model.matrix, [-model.origin[0], -model.origin[1], -model.origin[2]]);
      mat4_exports.transpose(model.matrix, model.matrix);
      model.isIdentity = true;
      for (let i = 0; i < 4; ++i) {
        for (let j = 0; j < 4; ++j) {
          if ((i === j ? 1 : 0) !== model.matrix[i + j * 4]) {
            model.isIdentity = false;
          }
        }
      }
      model.matrixMTime.modified();
    }
  };
  publicAPI.getBoundsByReference = () => {
    if (model.mapper === null) {
      return model.bounds;
    }
    const bds = model.mapper.getBounds();
    if (!bds || bds.length !== 6) {
      return bds;
    }
    if (bds[0] > bds[1]) {
      model.mapperBounds = bds;
      model.bounds = [...vtkBoundingBox.INIT_BOUNDS];
      model.boundsMTime.modified();
      return bds;
    }
    if (!model.mapperBounds || !bds.every((_, i) => bds[i] === model.mapperBounds[i]) || publicAPI.getMTime() > model.boundsMTime.getMTime()) {
      macro.vtkDebugMacro("Recomputing bounds...");
      model.mapperBounds = bds;
      publicAPI.computeMatrix();
      const transposedMatrix = new Float64Array(16);
      mat4_exports.transpose(transposedMatrix, model.matrix);
      vtkBoundingBox.transformBounds(bds, transposedMatrix, model.bounds);
      model.boundsMTime.modified();
    }
    return model.bounds;
  };
  publicAPI.getBounds = () => {
    const bounds = publicAPI.getBoundsByReference();
    try {
      return [...bounds];
    } catch {
      return bounds;
    }
  };
  publicAPI.getCenter = () => vtkBoundingBox.getCenter(model.bounds);
  publicAPI.getLength = () => vtkBoundingBox.getLength(model.bounds);
  publicAPI.getXRange = () => vtkBoundingBox.getXRange(model.bounds);
  publicAPI.getYRange = () => vtkBoundingBox.getYRange(model.bounds);
  publicAPI.getZRange = () => vtkBoundingBox.getZRange(model.bounds);
  publicAPI.getUserMatrix = () => model.userMatrix;
  function updateIdentityFlag() {
    publicAPI.computeMatrix();
  }
  publicAPI.onModified(updateIdentityFlag);
  publicAPI.getProperty = function() {
    var _a;
    let mapperInputPort = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.properties[mapperInputPort] == null) {
      model.properties[mapperInputPort] = (_a = publicAPI.makeProperty) == null ? void 0 : _a.call(publicAPI);
    }
    return model.properties[mapperInputPort];
  };
  publicAPI.getProperties = () => {
    var _a;
    if (model.properties.length === 0) {
      model.properties[0] = (_a = publicAPI.makeProperty) == null ? void 0 : _a.call(publicAPI);
    }
    return model.properties;
  };
  publicAPI.setProperty = (firstArg, secondArg) => {
    const useInputPortArgument = Number.isInteger(firstArg);
    const [mapperInputPort, property] = useInputPortArgument ? [firstArg, secondArg] : [0, firstArg];
    if (model.properties[mapperInputPort] === property) {
      return false;
    }
    model.properties[mapperInputPort] = property;
    return true;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    model.properties.forEach((property) => {
      if (property !== null) {
        const time2 = property.getMTime();
        mt = time2 > mt ? time2 : mt;
      }
    });
    return mt;
  };
}
var DEFAULT_VALUES15 = {
  origin: [0, 0, 0],
  position: [0, 0, 0],
  orientation: [0, 0, 0],
  rotation: null,
  scale: [1, 1, 1],
  bounds: [...vtkBoundingBox.INIT_BOUNDS],
  properties: [],
  userMatrix: null,
  userMatrixMTime: null,
  cachedProp3D: null,
  isIdentity: true,
  matrixMTime: null
};
function extend16(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES15, initialValues);
  vtkProp$1.extend(publicAPI, model, initialValues);
  model.matrixMTime = {};
  macro.obj(model.matrixMTime);
  macro.get(publicAPI, model, ["isIdentity"]);
  macro.getArray(publicAPI, model, ["orientation"]);
  macro.setGetArray(publicAPI, model, ["origin", "position", "scale"], 3);
  macro.setGet(publicAPI, model, ["properties"]);
  model.matrix = mat4_exports.identity(new Float64Array(16));
  model.rotation = mat4_exports.identity(new Float64Array(16));
  model.userMatrix = mat4_exports.identity(new Float64Array(16));
  model.transform = null;
  vtkProp3D(publicAPI, model);
}
var newInstance17 = macro.newInstance(extend16, "vtkProp3D");
var vtkProp3D$1 = {
  newInstance: newInstance17,
  extend: extend16
};

// node_modules/@kitware/vtk.js/Rendering/Core/Property/Constants.js
var Shading = {
  FLAT: 0,
  GOURAUD: 1,
  PHONG: 2
};
var Representation = {
  POINTS: 0,
  WIREFRAME: 1,
  SURFACE: 2
};
var Interpolation = Shading;
var PropertyConst = {
  Shading,
  Representation,
  Interpolation
};

// node_modules/@kitware/vtk.js/Rendering/Core/Property.js
var {
  Representation: Representation2,
  Interpolation: Interpolation2
} = PropertyConst;
function notImplemented2(method) {
  return () => macro.vtkErrorMacro(`vtkProperty::${method} - NOT IMPLEMENTED`);
}
function vtkProperty(publicAPI, model) {
  model.classHierarchy.push("vtkProperty");
  publicAPI.setColor = (r, g, b) => {
    if (Array.isArray(r)) {
      if (model.color[0] !== r[0] || model.color[1] !== r[1] || model.color[2] !== r[2]) {
        model.color[0] = r[0];
        model.color[1] = r[1];
        model.color[2] = r[2];
        publicAPI.modified();
      }
    } else if (model.color[0] !== r || model.color[1] !== g || model.color[2] !== b) {
      model.color[0] = r;
      model.color[1] = g;
      model.color[2] = b;
      publicAPI.modified();
    }
    publicAPI.setDiffuseColor(model.color);
    publicAPI.setAmbientColor(model.color);
    publicAPI.setSpecularColor(model.color);
  };
  publicAPI.computeCompositeColor = notImplemented2("ComputeCompositeColor");
  publicAPI.getColor = () => {
    let norm2 = 0;
    if (model.ambient + model.diffuse + model.specular > 0) {
      norm2 = 1 / (model.ambient + model.diffuse + model.specular);
    }
    for (let i = 0; i < 3; i++) {
      model.color[i] = norm2 * (model.ambient * model.ambientColor[i] + model.diffuse * model.diffuseColor[i] + model.specular * model.specularColor[i]);
    }
    return [].concat(model.color);
  };
  publicAPI.setSpecularPower = (specularPower) => {
    const roughness = 1 / Math.max(1, specularPower);
    if (model.roughness !== roughness || model.specularPower !== specularPower) {
      model.specularPower = specularPower;
      model.roughness = roughness;
      publicAPI.modified();
    }
  };
  publicAPI.addShaderVariable = notImplemented2("AddShaderVariable");
  publicAPI.setInterpolationToFlat = () => publicAPI.setInterpolation(Interpolation2.FLAT);
  publicAPI.setInterpolationToGouraud = () => publicAPI.setInterpolation(Interpolation2.GOURAUD);
  publicAPI.setInterpolationToPhong = () => publicAPI.setInterpolation(Interpolation2.PHONG);
  publicAPI.getInterpolationAsString = () => macro.enumToString(Interpolation2, model.interpolation);
  publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Representation2.WIREFRAME);
  publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Representation2.SURFACE);
  publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Representation2.POINTS);
  publicAPI.getRepresentationAsString = () => macro.enumToString(Representation2, model.representation);
}
var DEFAULT_VALUES16 = {
  color: [1, 1, 1],
  ambientColor: [1, 1, 1],
  diffuseColor: [1, 1, 1],
  specularColor: [1, 1, 1],
  edgeColor: [0, 0, 0],
  ambient: 0,
  diffuse: 1,
  metallic: 0,
  roughness: 0.6,
  normalStrength: 1,
  emission: 1,
  baseIOR: 1.45,
  specular: 0,
  specularPower: 1,
  opacity: 1,
  interpolation: Interpolation2.GOURAUD,
  representation: Representation2.SURFACE,
  edgeVisibility: false,
  backfaceCulling: false,
  frontfaceCulling: false,
  pointSize: 1,
  lineWidth: 1,
  lighting: true,
  shading: false,
  materialName: null,
  ORMTexture: null,
  RMTexture: null
};
function extend17(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES16, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["lighting", "interpolation", "ambient", "diffuse", "metallic", "roughness", "normalStrength", "emission", "baseIOR", "specular", "specularPower", "opacity", "edgeVisibility", "lineWidth", "pointSize", "backfaceCulling", "frontfaceCulling", "representation", "diffuseTexture", "metallicTexture", "roughnessTexture", "normalTexture", "ambientOcclusionTexture", "emissionTexture", "ORMTexture", "RMTexture"]);
  macro.setGetArray(publicAPI, model, ["ambientColor", "specularColor", "diffuseColor", "edgeColor"], 3);
  vtkProperty(publicAPI, model);
}
var newInstance18 = macro.newInstance(extend17, "vtkProperty");
var vtkProperty$1 = {
  newInstance: newInstance18,
  extend: extend17,
  ...PropertyConst
};

// node_modules/@kitware/vtk.js/Rendering/Core/Actor.js
function vtkActor2(publicAPI, model) {
  model.classHierarchy.push("vtkActor");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getActors = () => [publicAPI];
  publicAPI.getIsOpaque = () => {
    if (model.forceOpaque) {
      return true;
    }
    if (model.forceTranslucent) {
      return false;
    }
    if (!model.properties[0]) {
      publicAPI.getProperty();
    }
    let isOpaque = model.properties[0].getOpacity() >= 1;
    isOpaque = isOpaque && (!model.texture || !model.texture.isTranslucent());
    isOpaque = isOpaque && (!model.mapper || model.mapper.getIsOpaque());
    return isOpaque;
  };
  publicAPI.hasTranslucentPolygonalGeometry = () => {
    if (model.mapper === null) {
      return false;
    }
    if (!model.properties[0]) {
      publicAPI.getProperty();
    }
    return !publicAPI.getIsOpaque();
  };
  publicAPI.makeProperty = vtkProperty$1.newInstance;
  publicAPI.getMTime = () => {
    let mt = superClass.getMTime();
    if (model.backfaceProperty !== null) {
      const time2 = model.backfaceProperty.getMTime();
      mt = time2 > mt ? time2 : mt;
    }
    return mt;
  };
  publicAPI.getRedrawMTime = () => {
    let mt = model.mtime;
    if (model.mapper !== null) {
      let time2 = model.mapper.getMTime();
      mt = time2 > mt ? time2 : mt;
      if (model.mapper.getInput() !== null) {
        model.mapper.getInputAlgorithm().update();
        time2 = model.mapper.getInput().getMTime();
        mt = time2 > mt ? time2 : mt;
      }
    }
    return mt;
  };
  publicAPI.getSupportsSelection = () => model.mapper ? model.mapper.getSupportsSelection() : false;
  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
    if (model.mapper && model.mapper.processSelectorPixelBuffers) {
      model.mapper.processSelectorPixelBuffers(selector, pixelOffsets);
    }
  };
}
var DEFAULT_VALUES17 = {
  mapper: null,
  backfaceProperty: null,
  forceOpaque: false,
  forceTranslucent: false
};
function extend18(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES17, initialValues);
  vtkProp3D$1.extend(publicAPI, model, initialValues);
  model.boundsMTime = {};
  macro.obj(model.boundsMTime);
  macro.setGet(publicAPI, model, ["backfaceProperty", "forceOpaque", "forceTranslucent", "mapper"]);
  vtkActor2(publicAPI, model);
}
var newInstance19 = macro.newInstance(extend18, "vtkActor");
var vtkActor$1 = {
  newInstance: newInstance19,
  extend: extend18
};

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper.js
function vtkAbstractMapper(publicAPI, model) {
  model.classHierarchy.push("vtkAbstractMapper");
  publicAPI.update = () => {
    publicAPI.getInputData();
  };
  publicAPI.addClippingPlane = (plane) => {
    if (!plane.isA("vtkPlane")) {
      return false;
    }
    if (!model.clippingPlanes.includes(plane)) {
      model.clippingPlanes.push(plane);
      publicAPI.modified();
      return true;
    }
    return false;
  };
  publicAPI.getNumberOfClippingPlanes = () => model.clippingPlanes.length;
  publicAPI.removeAllClippingPlanes = () => {
    if (model.clippingPlanes.length === 0) {
      return false;
    }
    model.clippingPlanes.length = 0;
    publicAPI.modified();
    return true;
  };
  publicAPI.removeClippingPlane = (clippingPlane) => {
    const i = model.clippingPlanes.indexOf(clippingPlane);
    if (i === -1) {
      return false;
    }
    model.clippingPlanes.splice(i, 1);
    publicAPI.modified();
    return true;
  };
  publicAPI.getClippingPlanes = () => model.clippingPlanes;
  publicAPI.setClippingPlanes = (planes) => {
    if (!planes) {
      return;
    }
    if (!Array.isArray(planes)) {
      publicAPI.addClippingPlane(planes);
    } else {
      const nbPlanes = planes.length;
      for (let i = 0; i < nbPlanes && i < 6; i++) {
        publicAPI.addClippingPlane(planes[i]);
      }
    }
  };
  publicAPI.getClippingPlaneInDataCoords = (propMatrix, i, hnormal) => {
    const clipPlanes = model.clippingPlanes;
    const mat = propMatrix;
    if (clipPlanes) {
      const n = clipPlanes.length;
      if (i >= 0 && i < n) {
        const plane = clipPlanes[i];
        const normal = plane.getNormal();
        const origin = plane.getOrigin();
        const v1 = normal[0];
        const v2 = normal[1];
        const v3 = normal[2];
        const v4 = -(v1 * origin[0] + v2 * origin[1] + v3 * origin[2]);
        hnormal[0] = v1 * mat[0] + v2 * mat[4] + v3 * mat[8] + v4 * mat[12];
        hnormal[1] = v1 * mat[1] + v2 * mat[5] + v3 * mat[9] + v4 * mat[13];
        hnormal[2] = v1 * mat[2] + v2 * mat[6] + v3 * mat[10] + v4 * mat[14];
        hnormal[3] = v1 * mat[3] + v2 * mat[7] + v3 * mat[11] + v4 * mat[15];
        return;
      }
    }
    macro.vtkErrorMacro(`Clipping plane index ${i} is out of range.`);
  };
}
var DEFAULT_VALUES18 = {
  clippingPlanes: []
};
function extend19(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES18, initialValues);
  macro.obj(publicAPI, model);
  macro.algo(publicAPI, model, 1, 0);
  if (!model.clippingPlanes) {
    model.clippingPlanes = [];
  }
  vtkAbstractMapper(publicAPI, model);
}
var vtkAbstractMapper$1 = {
  extend: extend19
};

// node_modules/@kitware/vtk.js/Rendering/Core/AbstractMapper3D.js
function vtkAbstractMapper3D(publicAPI, model) {
  publicAPI.getBounds = () => {
    macro.vtkErrorMacro(`vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED`);
    return createUninitializedBounds();
  };
  publicAPI.getCenter = () => {
    var _a;
    const bounds = publicAPI.getBounds();
    model.center = vtkBoundingBox.isValid(bounds) ? vtkBoundingBox.getCenter(bounds) : null;
    return (_a = model.center) == null ? void 0 : _a.slice();
  };
  publicAPI.getLength = () => {
    const bounds = publicAPI.getBounds();
    return vtkBoundingBox.getDiagonalLength(bounds);
  };
}
var defaultValues = (initialValues) => ({
  bounds: [...vtkBoundingBox.INIT_BOUNDS],
  center: [0, 0, 0],
  viewSpecificProperties: {},
  ...initialValues
});
function extend20(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues(initialValues));
  vtkAbstractMapper$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["viewSpecificProperties"]);
  vtkAbstractMapper3D(publicAPI, model);
}
var vtkAbstractMapper3D$1 = {
  extend: extend20
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/FieldData.js
var {
  vtkErrorMacro: vtkErrorMacro4,
  vtkWarningMacro: vtkWarningMacro2
} = macro;
function vtkFieldData(publicAPI, model) {
  model.classHierarchy.push("vtkFieldData");
  const superGetState = publicAPI.getState;
  if (model.arrays) {
    model.arrays = model.arrays.map((item) => ({
      data: vtk(item.data)
    }));
  }
  publicAPI.initialize = () => {
    publicAPI.initializeFields();
    publicAPI.copyAllOn();
    publicAPI.clearFieldFlags();
  };
  publicAPI.initializeFields = () => {
    model.arrays = [];
    model.copyFieldFlags = {};
    publicAPI.modified();
  };
  publicAPI.copyStructure = (other) => {
    publicAPI.initializeFields();
    model.copyFieldFlags = other.getCopyFieldFlags().map((x) => x);
    model.arrays = other.getArrays().map((x) => ({
      data: x
    }));
  };
  publicAPI.getNumberOfArrays = () => model.arrays.length;
  publicAPI.getNumberOfActiveArrays = () => model.arrays.length;
  publicAPI.addArray = (arr) => {
    const name = arr.getName();
    const {
      array: array2,
      index: index2
    } = publicAPI.getArrayWithIndex(name);
    if (array2 != null) {
      model.arrays[index2] = {
        data: arr
      };
      return index2;
    }
    model.arrays = [].concat(model.arrays, {
      data: arr
    });
    return model.arrays.length - 1;
  };
  publicAPI.removeAllArrays = () => {
    model.arrays = [];
  };
  publicAPI.removeArray = (arrayName) => {
    const index2 = model.arrays.findIndex((array2) => array2.data.getName() === arrayName);
    return publicAPI.removeArrayByIndex(index2);
  };
  publicAPI.removeArrayByIndex = (arrayIdx) => {
    if (arrayIdx !== -1 && arrayIdx < model.arrays.length) {
      model.arrays.splice(arrayIdx, 1);
      return true;
    }
    return false;
  };
  publicAPI.getArrays = () => model.arrays.map((entry) => entry.data);
  publicAPI.getArray = (arraySpec) => typeof arraySpec === "number" ? publicAPI.getArrayByIndex(arraySpec) : publicAPI.getArrayByName(arraySpec);
  publicAPI.getArrayByName = (arrayName) => model.arrays.reduce((a, b, i) => b.data.getName() === arrayName ? b.data : a, null);
  publicAPI.getArrayWithIndex = (arrayName) => {
    const index2 = model.arrays.findIndex((array2) => array2.data.getName() === arrayName);
    return {
      array: index2 !== -1 ? model.arrays[index2].data : null,
      index: index2
    };
  };
  publicAPI.getArrayByIndex = (idx) => idx >= 0 && idx < model.arrays.length ? model.arrays[idx].data : null;
  publicAPI.hasArray = (arrayName) => publicAPI.getArrayWithIndex(arrayName).index >= 0;
  publicAPI.getArrayName = (idx) => {
    const arr = model.arrays[idx];
    return arr ? arr.data.getName() : "";
  };
  publicAPI.getCopyFieldFlags = () => model.copyFieldFlags;
  publicAPI.getFlag = (arrayName) => model.copyFieldFlags[arrayName];
  publicAPI.passData = function(other) {
    let fromId = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    let toId = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    other.getArrays().forEach((arr) => {
      const copyFlag = publicAPI.getFlag(arr.getName());
      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
        let destArr = publicAPI.getArrayByName(arr.getName());
        if (!destArr) {
          if (fromId < 0 || fromId > arr.getNumberOfTuples()) {
            publicAPI.addArray(arr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(arr, attrType);
            });
          } else {
            const ncomps = arr.getNumberOfComponents();
            let newSize = arr.getNumberOfValues();
            const tId = toId > -1 ? toId : fromId;
            if (newSize <= tId * ncomps) {
              newSize = (tId + 1) * ncomps;
            }
            destArr = vtkDataArray$1.newInstance({
              name: arr.getName(),
              dataType: arr.getDataType(),
              numberOfComponents: ncomps,
              values: macro.newTypedArray(arr.getDataType(), newSize),
              size: 0
            });
            destArr.insertTuple(tId, arr.getTuple(fromId));
            publicAPI.addArray(destArr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(destArr, attrType);
            });
          }
        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
          if (fromId > -1 && fromId < arr.getNumberOfTuples()) {
            const tId = toId > -1 ? toId : fromId;
            destArr.insertTuple(tId, arr.getTuple(fromId));
          } else {
            destArr.insertTuples(0, arr.getTuples());
          }
        } else {
          vtkErrorMacro4("Unhandled case in passData");
        }
      }
    });
  };
  publicAPI.interpolateData = function(other) {
    let fromId1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;
    let fromId2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : -1;
    let toId = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1;
    let t = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0.5;
    other.getArrays().forEach((arr) => {
      const copyFlag = publicAPI.getFlag(arr.getName());
      if (copyFlag !== false && !(model.doCopyAllOff && copyFlag !== true) && arr) {
        let destArr = publicAPI.getArrayByName(arr.getName());
        if (!destArr) {
          if (fromId1 < 0 || fromId2 < 0 || fromId1 > arr.getNumberOfTuples()) {
            publicAPI.addArray(arr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(arr, attrType);
            });
          } else {
            const ncomps = arr.getNumberOfComponents();
            let newSize = arr.getNumberOfValues();
            const tId = toId > -1 ? toId : fromId1;
            if (newSize <= tId * ncomps) {
              newSize = (tId + 1) * ncomps;
            }
            destArr = vtkDataArray$1.newInstance({
              name: arr.getName(),
              dataType: arr.getDataType(),
              numberOfComponents: ncomps,
              values: macro.newTypedArray(arr.getDataType(), newSize),
              size: 0
            });
            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);
            publicAPI.addArray(destArr);
            other.getAttributes(arr).forEach((attrType) => {
              publicAPI.setAttribute(destArr, attrType);
            });
          }
        } else if (arr.getNumberOfComponents() === destArr.getNumberOfComponents()) {
          if (fromId1 > -1 && fromId1 < arr.getNumberOfTuples()) {
            const tId = toId > -1 ? toId : fromId1;
            destArr.interpolateTuple(tId, arr, fromId1, arr, fromId2, t);
            vtkWarningMacro2("Unexpected case in interpolateData");
          } else {
            destArr.insertTuples(arr.getTuples());
          }
        } else {
          vtkErrorMacro4("Unhandled case in interpolateData");
        }
      }
    });
  };
  publicAPI.copyFieldOn = (arrayName) => {
    model.copyFieldFlags[arrayName] = true;
  };
  publicAPI.copyFieldOff = (arrayName) => {
    model.copyFieldFlags[arrayName] = false;
  };
  publicAPI.copyAllOn = () => {
    if (!model.doCopyAllOn || model.doCopyAllOff) {
      model.doCopyAllOn = true;
      model.doCopyAllOff = false;
      publicAPI.modified();
    }
  };
  publicAPI.copyAllOff = () => {
    if (model.doCopyAllOn || !model.doCopyAllOff) {
      model.doCopyAllOn = false;
      model.doCopyAllOff = true;
      publicAPI.modified();
    }
  };
  publicAPI.clearFieldFlags = () => {
    model.copyFieldFlags = {};
  };
  publicAPI.deepCopy = (other) => {
    model.arrays = other.getArrays().map((arr) => {
      const arrNew = arr.newClone();
      arrNew.deepCopy(arr);
      return {
        data: arrNew
      };
    });
  };
  publicAPI.copyFlags = (other) => other.getCopyFieldFlags().map((x) => x);
  publicAPI.reset = () => model.arrays.forEach((entry) => entry.data.reset());
  publicAPI.getMTime = () => model.arrays.reduce((a, b) => b.data.getMTime() > a ? b.data.getMTime() : a, model.mtime);
  publicAPI.getNumberOfComponents = () => model.arrays.reduce((a, b) => a + b.data.getNumberOfComponents(), 0);
  publicAPI.getNumberOfTuples = () => model.arrays.length > 0 ? model.arrays[0].getNumberOfTuples() : 0;
  publicAPI.getState = () => {
    const result = superGetState();
    if (result) {
      result.arrays = model.arrays.map((item) => ({
        data: item.data.getState()
      }));
    }
    return result;
  };
}
var DEFAULT_VALUES19 = {
  arrays: [],
  copyFieldFlags: [],
  // fields not to copy
  doCopyAllOn: true,
  doCopyAllOff: false
};
function extend21(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES19, initialValues);
  macro.obj(publicAPI, model);
  vtkFieldData(publicAPI, model);
}
var newInstance20 = macro.newInstance(extend21, "vtkFieldData");
var vtkFieldData$1 = {
  newInstance: newInstance20,
  extend: extend21
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js
var AttributeTypes = {
  SCALARS: 0,
  VECTORS: 1,
  NORMALS: 2,
  TCOORDS: 3,
  TENSORS: 4,
  GLOBALIDS: 5,
  PEDIGREEIDS: 6,
  EDGEFLAG: 7,
  NUM_ATTRIBUTES: 8
};
var AttributeLimitTypes = {
  MAX: 0,
  EXACT: 1,
  NOLIMIT: 2
};
var CellGhostTypes = {
  DUPLICATECELL: 1,
  // the cell is present on multiple processors
  HIGHCONNECTIVITYCELL: 2,
  // the cell has more neighbors than in a regular mesh
  LOWCONNECTIVITYCELL: 4,
  // the cell has less neighbors than in a regular mesh
  REFINEDCELL: 8,
  // other cells are present that refines it.
  EXTERIORCELL: 16,
  // the cell is on the exterior of the data set
  HIDDENCELL: 32
  // the cell is needed to maintain connectivity, but the data values should be ignored.
};
var PointGhostTypes = {
  DUPLICATEPOINT: 1,
  // the cell is present on multiple processors
  HIDDENPOINT: 2
  // the point is needed to maintain connectivity, but the data values should be ignored.
};
var AttributeCopyOperations = {
  COPYTUPLE: 0,
  INTERPOLATE: 1,
  PASSDATA: 2,
  ALLCOPY: 3
  // all of the above
};
var ghostArrayName = "vtkGhostType";
var DesiredOutputPrecision = {
  DEFAULT: 0,
  // use the point type that does not truncate any data
  SINGLE: 1,
  // use Float32Array
  DOUBLE: 2
  // use Float64Array
};
var Constants3 = {
  AttributeCopyOperations,
  AttributeLimitTypes,
  AttributeTypes,
  CellGhostTypes,
  DesiredOutputPrecision,
  PointGhostTypes,
  ghostArrayName
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes.js
var {
  AttributeTypes: AttributeTypes2,
  AttributeCopyOperations: AttributeCopyOperations2
} = Constants3;
var {
  vtkWarningMacro: vtkWarningMacro3
} = macro;
function vtkDataSetAttributes(publicAPI, model) {
  const attrTypes = ["Scalars", "Vectors", "Normals", "TCoords", "Tensors", "GlobalIds", "PedigreeIds"];
  function cleanAttributeType(attType) {
    let cleanAttType = attrTypes.find((ee) => AttributeTypes2[ee.toUpperCase()] === attType || typeof attType !== "number" && ee.toLowerCase() === attType.toLowerCase());
    if (typeof cleanAttType === "undefined") {
      cleanAttType = null;
    }
    return cleanAttType;
  }
  model.classHierarchy.push("vtkDataSetAttributes");
  const superClass = {
    ...publicAPI
  };
  publicAPI.checkNumberOfComponents = (x) => true;
  publicAPI.setAttribute = (arr, uncleanAttType) => {
    const attType = cleanAttributeType(uncleanAttType);
    if (arr && attType.toUpperCase() === "PEDIGREEIDS" && !arr.isA("vtkDataArray")) {
      vtkWarningMacro3(`Cannot set attribute ${attType}. The attribute must be a vtkDataArray.`);
      return -1;
    }
    if (arr && !publicAPI.checkNumberOfComponents(arr, attType)) {
      vtkWarningMacro3(`Cannot set attribute ${attType}. Incorrect number of components.`);
      return -1;
    }
    let currentAttribute = model[`active${attType}`];
    if (currentAttribute >= 0 && currentAttribute < model.arrays.length) {
      if (model.arrays[currentAttribute] === arr) {
        return currentAttribute;
      }
      publicAPI.removeArrayByIndex(currentAttribute);
    }
    if (arr) {
      currentAttribute = publicAPI.addArray(arr);
      model[`active${attType}`] = currentAttribute;
    } else {
      model[`active${attType}`] = -1;
    }
    publicAPI.modified();
    return model[`active${attType}`];
  };
  publicAPI.getAttributes = (arr) => attrTypes.filter((attrType) => publicAPI[`get${attrType}`]() === arr);
  publicAPI.setActiveAttributeByName = (arrayName, attType) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, attType);
  publicAPI.setActiveAttributeByIndex = (arrayIdx, uncleanAttType) => {
    const attType = cleanAttributeType(uncleanAttType);
    if (arrayIdx >= 0 && arrayIdx < model.arrays.length) {
      if (attType.toUpperCase() !== "PEDIGREEIDS") {
        const arr = publicAPI.getArrayByIndex(arrayIdx);
        if (!arr.isA("vtkDataArray")) {
          vtkWarningMacro3(`Cannot set attribute ${attType}. Only vtkDataArray subclasses can be set as active attributes.`);
          return -1;
        }
        if (!publicAPI.checkNumberOfComponents(arr, attType)) {
          vtkWarningMacro3(`Cannot set attribute ${attType}. Incorrect number of components.`);
          return -1;
        }
      }
      model[`active${attType}`] = arrayIdx;
      publicAPI.modified();
      return arrayIdx;
    }
    if (arrayIdx === -1) {
      model[`active${attType}`] = arrayIdx;
      publicAPI.modified();
    }
    return -1;
  };
  publicAPI.getActiveAttribute = (attType) => {
    const cleanAttType = cleanAttributeType(attType);
    return publicAPI[`get${cleanAttType}`]();
  };
  publicAPI.removeAllArrays = () => {
    attrTypes.forEach((attType) => {
      model[`active${attType}`] = -1;
    });
    superClass.removeAllArrays();
  };
  publicAPI.removeArrayByIndex = (arrayIdx) => {
    if (arrayIdx !== -1) {
      attrTypes.forEach((attType) => {
        if (arrayIdx === model[`active${attType}`]) {
          model[`active${attType}`] = -1;
        } else if (arrayIdx < model[`active${attType}`]) {
          model[`active${attType}`] -= 1;
        }
      });
    }
    return superClass.removeArrayByIndex(arrayIdx);
  };
  attrTypes.forEach((value) => {
    const activeVal = `active${value}`;
    publicAPI[`get${value}`] = () => publicAPI.getArrayByIndex(model[activeVal]);
    publicAPI[`set${value}`] = (da) => publicAPI.setAttribute(da, value);
    publicAPI[`setActive${value}`] = (arrayName) => publicAPI.setActiveAttributeByIndex(publicAPI.getArrayWithIndex(arrayName).index, value);
    publicAPI[`copy${value}Off`] = () => {
      const attType = value.toUpperCase();
      model.copyAttributeFlags[AttributeCopyOperations2.PASSDATA][AttributeTypes2[attType]] = false;
    };
    publicAPI[`copy${value}On`] = () => {
      const attType = value.toUpperCase();
      model.copyAttributeFlags[AttributeCopyOperations2.PASSDATA][AttributeTypes2[attType]] = true;
    };
  });
  publicAPI.initializeAttributeCopyFlags = () => {
    model.copyAttributeFlags = [];
    Object.keys(AttributeCopyOperations2).filter((op) => op !== "ALLCOPY").forEach((attCopyOp) => {
      model.copyAttributeFlags[AttributeCopyOperations2[attCopyOp]] = Object.keys(AttributeTypes2).filter((ty) => ty !== "NUM_ATTRIBUTES").reduce((a, b) => {
        a[AttributeTypes2[b]] = true;
        return a;
      }, []);
    });
    model.copyAttributeFlags[AttributeCopyOperations2.COPYTUPLE][AttributeTypes2.GLOBALIDS] = false;
    model.copyAttributeFlags[AttributeCopyOperations2.INTERPOLATE][AttributeTypes2.GLOBALIDS] = false;
    model.copyAttributeFlags[AttributeCopyOperations2.COPYTUPLE][AttributeTypes2.PEDIGREEIDS] = false;
  };
  publicAPI.initialize = macro.chain(publicAPI.initialize, publicAPI.initializeAttributeCopyFlags);
  if (model.dataArrays && Object.keys(model.dataArrays).length) {
    Object.keys(model.dataArrays).forEach((name) => {
      if (!model.dataArrays[name].ref && model.dataArrays[name].type === "vtkDataArray") {
        publicAPI.addArray(vtkDataArray$1.newInstance(model.dataArrays[name]));
      }
    });
  }
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = (other, debug) => {
    superShallowCopy(other, debug);
    model.arrays = other.getArrays().map((arr) => {
      const arrNew = arr.newClone();
      arrNew.shallowCopy(arr, debug);
      return {
        data: arrNew
      };
    });
  };
  publicAPI.initializeAttributeCopyFlags();
}
var DEFAULT_VALUES20 = {
  activeScalars: -1,
  activeVectors: -1,
  activeTensors: -1,
  activeNormals: -1,
  activeTCoords: -1,
  activeGlobalIds: -1,
  activePedigreeIds: -1
};
function extend22(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES20, initialValues);
  vtkFieldData$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["activeScalars", "activeNormals", "activeTCoords", "activeVectors", "activeTensors", "activeGlobalIds", "activePedigreeIds"]);
  if (!model.arrays) {
    model.arrays = {};
  }
  vtkDataSetAttributes(publicAPI, model);
}
var newInstance21 = macro.newInstance(extend22, "vtkDataSetAttributes");
var vtkDataSetAttributes$1 = {
  newInstance: newInstance21,
  extend: extend22,
  ...Constants3
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSet/Constants.js
var FieldDataTypes = {
  UNIFORM: 0,
  // data that does not vary over points/cells/etc.
  DATA_OBJECT_FIELD: 0,
  // to match VTK
  COORDINATE: 1,
  // data that specifies the location of each point
  POINT_DATA: 1,
  // to match VTK
  POINT: 2,
  // data defined at each point, but that does not specify the point location
  POINT_FIELD_DATA: 2,
  // to match VTK
  CELL: 3,
  // data defined at each cell, but that does not specify the cell
  CELL_FIELD_DATA: 3,
  // to match VTK
  VERTEX: 4,
  // data defined at each graph vertex, but that does not specify the graph vertex
  VERTEX_FIELD_DATA: 4,
  // to match VTK
  EDGE: 5,
  // data defined at each graph edge, but that does not specify the graph edge
  EDGE_FIELD_DATA: 5,
  // to match VTK
  ROW: 6,
  // data specifying a table row
  ROW_DATA: 6
  // to match VTK
};
var FieldAssociations = {
  FIELD_ASSOCIATION_POINTS: 0,
  FIELD_ASSOCIATION_CELLS: 1,
  FIELD_ASSOCIATION_NONE: 2,
  FIELD_ASSOCIATION_POINTS_THEN_CELLS: 3,
  FIELD_ASSOCIATION_VERTICES: 4,
  FIELD_ASSOCIATION_EDGES: 5,
  FIELD_ASSOCIATION_ROWS: 6,
  NUMBER_OF_ASSOCIATIONS: 7
};
var Constants4 = {
  FieldDataTypes,
  FieldAssociations
};

// node_modules/@kitware/vtk.js/Common/DataModel/DataSet.js
var DATASET_FIELDS = ["pointData", "cellData", "fieldData"];
function vtkDataSet(publicAPI, model) {
  model.classHierarchy.push("vtkDataSet");
  DATASET_FIELDS.forEach((fieldName) => {
    if (!model[fieldName]) {
      model[fieldName] = vtkDataSetAttributes$1.newInstance();
    } else {
      model[fieldName] = vtk(model[fieldName]);
    }
  });
  publicAPI.computeBounds = () => {
    if (model.modifiedTime && model.computeTime && model.modifiedTime > model.computeTime || !model.computeTime) {
      const points = publicAPI.getPoints();
      if (points == null ? void 0 : points.getNumberOfPoints()) {
        vtkBoundingBox.setBounds(model.bounds, points.getBoundsByReference());
      } else {
        model.bounds = vtkMath.createUninitializedBounds();
      }
      model.computeTime = macro.getCurrentGlobalMTime();
    }
  };
  publicAPI.getLength2 = () => {
    const bounds = publicAPI.getBoundsByReference();
    if (!bounds || bounds.length !== 6)
      return 0;
    return vtkBoundingBox.getDiagonalLength2(bounds);
  };
  publicAPI.getLength = () => Math.sqrt(publicAPI.getLength2());
  publicAPI.getCenter = () => {
    const bounds = publicAPI.getBoundsByReference();
    if (!bounds || bounds.length !== 6)
      return [0, 0, 0];
    return vtkBoundingBox.getCenter(bounds);
  };
  publicAPI.getCellBounds = (cellId) => {
    const cell = publicAPI.getCell(cellId);
    if (cell) {
      return cell.getBounds();
    }
    return vtkMath.createUninitializedBounds();
  };
  publicAPI.getBounds = macro.chain(() => publicAPI.computeBounds, publicAPI.getBounds);
  publicAPI.getBoundsByReference = macro.chain(() => publicAPI.computeBounds, publicAPI.getBoundsByReference);
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    DATASET_FIELDS.forEach((fieldName) => {
      model[fieldName] = vtkDataSetAttributes$1.newInstance();
      model[fieldName].shallowCopy(other.getReferenceByName(fieldName));
    });
  };
  const superGetMTime = publicAPI.getMTime;
  publicAPI.getMTime = () => DATASET_FIELDS.reduce((mTime, fieldName) => {
    var _a;
    return Math.max(mTime, ((_a = model[fieldName]) == null ? void 0 : _a.getMTime()) ?? mTime);
  }, superGetMTime());
  publicAPI.initialize = () => {
    DATASET_FIELDS.forEach((fieldName) => {
      var _a;
      return (_a = model[fieldName]) == null ? void 0 : _a.initialize();
    });
    return publicAPI;
  };
}
var DEFAULT_VALUES21 = {
  // pointData: null,
  // cellData: null,
  // fieldData: null,
};
function extend23(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES21, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, DATASET_FIELDS);
  macro.getArray(publicAPI, model, ["bounds"], 6);
  vtkDataSet(publicAPI, model);
}
var newInstance22 = macro.newInstance(extend23, "vtkDataSet");
var vtkDataSet$1 = {
  newInstance: newInstance22,
  extend: extend23,
  ...Constants4
};

// node_modules/@kitware/vtk.js/Common/DataModel/StructuredData/Constants.js
var StructuredType = {
  UNCHANGED: 0,
  SINGLE_POINT: 1,
  X_LINE: 2,
  Y_LINE: 3,
  Z_LINE: 4,
  XY_PLANE: 5,
  YZ_PLANE: 6,
  XZ_PLANE: 7,
  XYZ_GRID: 8,
  EMPTY: 9
};
var Constants5 = {
  StructuredType
};

// node_modules/@kitware/vtk.js/Common/DataModel/StructuredData.js
var {
  StructuredType: StructuredType2
} = Constants5;
function getDataDescriptionFromExtent(inExt) {
  let dataDim = 0;
  for (let i = 0; i < 3; ++i) {
    if (inExt[i * 2] < inExt[i * 2 + 1]) {
      dataDim++;
    }
  }
  if (inExt[0] > inExt[1] || inExt[2] > inExt[3] || inExt[4] > inExt[5]) {
    return StructuredType2.EMPTY;
  }
  if (dataDim === 3) {
    return StructuredType2.XYZ_GRID;
  }
  if (dataDim === 2) {
    if (inExt[0] === inExt[1]) {
      return StructuredType2.YZ_PLANE;
    }
    if (inExt[2] === inExt[3]) {
      return StructuredType2.XZ_PLANE;
    }
    return StructuredType2.XY_PLANE;
  }
  if (dataDim === 1) {
    if (inExt[0] < inExt[1]) {
      return StructuredType2.X_LINE;
    }
    if (inExt[2] < inExt[3]) {
      return StructuredType2.Y_LINE;
    }
    return StructuredType2.Z_LINE;
  }
  return StructuredType2.SINGLE_POINT;
}
var vtkStructuredData = {
  getDataDescriptionFromExtent,
  ...Constants5
};

// node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js
var {
  vtkErrorMacro: vtkErrorMacro5
} = macro;
function vtkImageData(publicAPI, model) {
  model.classHierarchy.push("vtkImageData");
  publicAPI.setExtent = function() {
    if (model.deleted) {
      vtkErrorMacro5("instance deleted - cannot call any method");
      return false;
    }
    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {
      inExtent[_key] = arguments[_key];
    }
    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;
    if (extentArray.length !== 6) {
      return false;
    }
    const changeDetected = model.extent.some((item, index2) => item !== extentArray[index2]);
    if (changeDetected) {
      model.extent = extentArray.slice();
      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);
      publicAPI.modified();
    }
    return changeDetected;
  };
  publicAPI.setDimensions = function() {
    let i;
    let j;
    let k;
    if (model.deleted) {
      vtkErrorMacro5("instance deleted - cannot call any method");
      return;
    }
    if (arguments.length === 1) {
      const array2 = arguments.length <= 0 ? void 0 : arguments[0];
      i = array2[0];
      j = array2[1];
      k = array2[2];
    } else if (arguments.length === 3) {
      i = arguments.length <= 0 ? void 0 : arguments[0];
      j = arguments.length <= 1 ? void 0 : arguments[1];
      k = arguments.length <= 2 ? void 0 : arguments[2];
    } else {
      vtkErrorMacro5("Bad dimension specification");
      return;
    }
    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);
  };
  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];
  publicAPI.getNumberOfCells = () => {
    const dims = publicAPI.getDimensions();
    let nCells = 1;
    for (let i = 0; i < 3; i++) {
      if (dims[i] === 0) {
        return 0;
      }
      if (dims[i] > 1) {
        nCells *= dims[i] - 1;
      }
    }
    return nCells;
  };
  publicAPI.getNumberOfPoints = () => {
    const dims = publicAPI.getDimensions();
    return dims[0] * dims[1] * dims[2];
  };
  publicAPI.getPoint = (index2) => {
    const dims = publicAPI.getDimensions();
    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {
      vtkErrorMacro5("Requesting a point from an empty image.");
      return null;
    }
    const ijk = new Float64Array(3);
    switch (model.dataDescription) {
      case StructuredType.EMPTY:
        return null;
      case StructuredType.SINGLE_POINT:
        break;
      case StructuredType.X_LINE:
        ijk[0] = index2;
        break;
      case StructuredType.Y_LINE:
        ijk[1] = index2;
        break;
      case StructuredType.Z_LINE:
        ijk[2] = index2;
        break;
      case StructuredType.XY_PLANE:
        ijk[0] = index2 % dims[0];
        ijk[1] = index2 / dims[0];
        break;
      case StructuredType.YZ_PLANE:
        ijk[1] = index2 % dims[1];
        ijk[2] = index2 / dims[1];
        break;
      case StructuredType.XZ_PLANE:
        ijk[0] = index2 % dims[0];
        ijk[2] = index2 / dims[0];
        break;
      case StructuredType.XYZ_GRID:
        ijk[0] = index2 % dims[0];
        ijk[1] = index2 / dims[0] % dims[1];
        ijk[2] = index2 / (dims[0] * dims[1]);
        break;
      default:
        vtkErrorMacro5("Invalid dataDescription");
        break;
    }
    const coords = [0, 0, 0];
    publicAPI.indexToWorld(ijk, coords);
    return coords;
  };
  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());
  publicAPI.extentToBounds = (ex) => vtkBoundingBox.transformBounds(ex, model.indexToWorld);
  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);
  publicAPI.computeTransforms = () => {
    mat4_exports.fromTranslation(model.indexToWorld, model.origin);
    model.indexToWorld[0] = model.direction[0];
    model.indexToWorld[1] = model.direction[1];
    model.indexToWorld[2] = model.direction[2];
    model.indexToWorld[4] = model.direction[3];
    model.indexToWorld[5] = model.direction[4];
    model.indexToWorld[6] = model.direction[5];
    model.indexToWorld[8] = model.direction[6];
    model.indexToWorld[9] = model.direction[7];
    model.indexToWorld[10] = model.direction[8];
    mat4_exports.scale(model.indexToWorld, model.indexToWorld, model.spacing);
    mat4_exports.invert(model.worldToIndex, model.indexToWorld);
  };
  publicAPI.indexToWorld = function(ain) {
    let aout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    vec3_exports.transformMat4(aout, ain, model.indexToWorld);
    return aout;
  };
  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;
  publicAPI.worldToIndex = function(ain) {
    let aout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    vec3_exports.transformMat4(aout, ain, model.worldToIndex);
    return aout;
  };
  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;
  publicAPI.indexToWorldBounds = function(bin2) {
    let bout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return vtkBoundingBox.transformBounds(bin2, model.indexToWorld, bout);
  };
  publicAPI.worldToIndexBounds = function(bin2) {
    let bout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return vtkBoundingBox.transformBounds(bin2, model.worldToIndex, bout);
  };
  model._onOriginChanged = publicAPI.computeTransforms;
  model._onDirectionChanged = publicAPI.computeTransforms;
  model._onSpacingChanged = publicAPI.computeTransforms;
  publicAPI.computeTransforms();
  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());
  publicAPI.computeHistogram = function(worldBounds) {
    let voxelFunction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const bounds = [0, 0, 0, 0, 0, 0];
    publicAPI.worldToIndexBounds(worldBounds, bounds);
    const point1 = [0, 0, 0];
    const point2 = [0, 0, 0];
    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);
    roundVector(point1, point1);
    roundVector(point2, point2);
    const dimensions = publicAPI.getDimensions();
    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);
    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);
    const yStride = dimensions[0];
    const zStride = dimensions[0] * dimensions[1];
    const pixels = publicAPI.getPointData().getScalars().getData();
    let maximum = -Infinity;
    let minimum = Infinity;
    let sumOfSquares = 0;
    let isum = 0;
    let inum = 0;
    for (let z = point1[2]; z <= point2[2]; z++) {
      for (let y = point1[1]; y <= point2[1]; y++) {
        let index2 = point1[0] + y * yStride + z * zStride;
        for (let x = point1[0]; x <= point2[0]; x++) {
          if (!voxelFunction || voxelFunction([x, y, z], bounds)) {
            const pixel = pixels[index2];
            if (pixel > maximum)
              maximum = pixel;
            if (pixel < minimum)
              minimum = pixel;
            sumOfSquares += pixel * pixel;
            isum += pixel;
            inum += 1;
          }
          ++index2;
        }
      }
    }
    const average = inum > 0 ? isum / inum : 0;
    const variance2 = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;
    const sigma = Math.sqrt(variance2);
    return {
      minimum,
      maximum,
      average,
      variance: variance2,
      sigma,
      count: inum
    };
  };
  publicAPI.computeIncrements = function(extent2) {
    let numberOfComponents = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const increments = [];
    let incr = numberOfComponents;
    for (let idx = 0; idx < 3; ++idx) {
      increments[idx] = incr;
      incr *= extent2[idx * 2 + 1] - extent2[idx * 2] + 1;
    }
    return increments;
  };
  publicAPI.computeOffsetIndex = (_ref) => {
    let [i, j, k] = _ref;
    const extent2 = publicAPI.getExtent();
    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
    const increments = publicAPI.computeIncrements(extent2, numberOfComponents);
    return Math.floor((Math.round(i) - extent2[0]) * increments[0] + (Math.round(j) - extent2[2]) * increments[1] + (Math.round(k) - extent2[4]) * increments[2]);
  };
  publicAPI.getOffsetIndexFromWorld = (xyz) => {
    const extent2 = publicAPI.getExtent();
    const index2 = publicAPI.worldToIndex(xyz);
    for (let idx = 0; idx < 3; ++idx) {
      if (index2[idx] < extent2[idx * 2] || index2[idx] > extent2[idx * 2 + 1]) {
        vtkErrorMacro5(`GetScalarPointer: Pixel ${index2} is not in memory. Current extent = ${extent2}`);
        return NaN;
      }
    }
    return publicAPI.computeOffsetIndex(index2);
  };
  publicAPI.getScalarValueFromWorld = function(xyz) {
    let comp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();
    if (comp < 0 || comp >= numberOfComponents) {
      vtkErrorMacro5(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);
      return NaN;
    }
    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);
    if (Number.isNaN(offsetIndex)) {
      return offsetIndex;
    }
    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);
  };
  const superInitialize = publicAPI.initialize;
  publicAPI.initialize = () => {
    publicAPI.set({
      direction: mat3_exports.identity(model.direction),
      spacing: [1, 1, 1],
      origin: [0, 0, 0],
      extent: [0, -1, 0, -1, 0, -1],
      dataDescription: StructuredType.EMPTY
    });
    return superInitialize();
  };
}
var DEFAULT_VALUES22 = {
  direction: null,
  // a mat3
  indexToWorld: null,
  // a mat4
  worldToIndex: null,
  // a mat4
  spacing: [1, 1, 1],
  origin: [0, 0, 0],
  extent: [0, -1, 0, -1, 0, -1],
  dataDescription: StructuredType.EMPTY
};
function extend24(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES22, initialValues);
  vtkDataSet$1.extend(publicAPI, model, initialValues);
  if (!model.direction) {
    model.direction = mat3_exports.identity(new Float64Array(9));
  } else if (Array.isArray(model.direction)) {
    model.direction = new Float64Array(model.direction.slice(0, 9));
  }
  model.indexToWorld = new Float64Array(16);
  model.worldToIndex = new Float64Array(16);
  macro.get(publicAPI, model, ["indexToWorld", "worldToIndex"]);
  macro.setGetArray(publicAPI, model, ["origin", "spacing"], 3);
  macro.setGetArray(publicAPI, model, ["direction"], 9);
  macro.getArray(publicAPI, model, ["extent"], 6);
  vtkImageData(publicAPI, model);
}
var newInstance23 = macro.newInstance(extend24, "vtkImageData");
var vtkImageData$1 = {
  newInstance: newInstance23,
  extend: extend24
};

// node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors/Constants.js
var VectorMode = {
  MAGNITUDE: 0,
  COMPONENT: 1,
  RGBCOLORS: 2
};
var ScalarMappingTarget = {
  LUMINANCE: 1,
  LUMINANCE_ALPHA: 2,
  RGB: 3,
  RGBA: 4
};
var Scale = {
  LINEAR: 0,
  LOG10: 1
};
var vtkScalarsToColors = {
  VectorMode,
  ScalarMappingTarget,
  Scale
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Constants.js
var ColorMode = {
  DEFAULT: 0,
  MAP_SCALARS: 1,
  DIRECT_SCALARS: 2
};
var ScalarMode = {
  DEFAULT: 0,
  USE_POINT_DATA: 1,
  USE_CELL_DATA: 2,
  USE_POINT_FIELD_DATA: 3,
  USE_CELL_FIELD_DATA: 4,
  USE_FIELD_DATA: 5
};
var GetArray = {
  BY_ID: 0,
  BY_NAME: 1
};
var Constants6 = {
  ColorMode,
  GetArray,
  ScalarMode
};

// node_modules/@kitware/vtk.js/Common/Core/ScalarsToColors.js
var {
  ScalarMappingTarget: ScalarMappingTarget2,
  Scale: Scale2,
  VectorMode: VectorMode2
} = vtkScalarsToColors;
var {
  VtkDataTypes: VtkDataTypes3
} = vtkDataArray$1;
var {
  ColorMode: ColorMode2
} = Constants6;
var {
  vtkErrorMacro: vtkErrorMacro6
} = macro;
function intColorToUChar(c) {
  return c;
}
function floatColorToUChar(c) {
  return Math.floor(c * 255 + 0.5);
}
function vtkScalarsToColors2(publicAPI, model) {
  model.classHierarchy.push("vtkScalarsToColors");
  publicAPI.setVectorModeToMagnitude = () => publicAPI.setVectorMode(VectorMode2.MAGNITUDE);
  publicAPI.setVectorModeToComponent = () => publicAPI.setVectorMode(VectorMode2.COMPONENT);
  publicAPI.setVectorModeToRGBColors = () => publicAPI.setVectorMode(VectorMode2.RGBCOLORS);
  publicAPI.build = () => {
  };
  publicAPI.isOpaque = () => true;
  publicAPI.setAnnotations = (values, annotations) => {
    if (values && !annotations || !values && annotations) {
      return;
    }
    if (values && annotations && values.length !== annotations.length) {
      vtkErrorMacro6("Values and annotations do not have the same number of tuples so ignoring");
      return;
    }
    model.annotationArray = [];
    if (annotations && values) {
      const num = annotations.length;
      for (let i = 0; i < num; i++) {
        model.annotationArray.push({
          value: values[i],
          annotation: String(annotations[i])
        });
      }
    }
    publicAPI.updateAnnotatedValueMap();
    publicAPI.modified();
  };
  publicAPI.setAnnotation = (value, annotation) => {
    let i = publicAPI.checkForAnnotatedValue(value);
    let modified = false;
    if (i >= 0) {
      if (model.annotationArray[i].annotation !== annotation) {
        model.annotationArray[i].annotation = annotation;
        modified = true;
      }
    } else {
      model.annotationArray.push({
        value,
        annotation
      });
      i = model.annotationArray.length - 1;
      modified = true;
    }
    if (modified) {
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return i;
  };
  publicAPI.getNumberOfAnnotatedValues = () => model.annotationArray.length;
  publicAPI.getAnnotatedValue = (idx) => {
    if (idx < 0 || idx >= model.annotationArray.length) {
      return null;
    }
    return model.annotationArray[idx].value;
  };
  publicAPI.getAnnotation = (idx) => {
    if (model.annotationArray[idx] === void 0) {
      return null;
    }
    return model.annotationArray[idx].annotation;
  };
  publicAPI.getAnnotatedValueIndex = (val) => model.annotationArray.length ? publicAPI.checkForAnnotatedValue(val) : -1;
  publicAPI.removeAnnotation = (value) => {
    const i = publicAPI.checkForAnnotatedValue(value);
    const needToRemove = i >= 0;
    if (needToRemove) {
      model.annotationArray.splice(i, 1);
      publicAPI.updateAnnotatedValueMap();
      publicAPI.modified();
    }
    return needToRemove;
  };
  publicAPI.resetAnnotations = () => {
    model.annotationArray = [];
    model.annotatedValueMap = [];
    publicAPI.modified();
  };
  publicAPI.getAnnotationColor = (val, rgba2) => {
    if (model.indexedLookup) {
      const i = publicAPI.getAnnotatedValueIndex(val);
      publicAPI.getIndexedColor(i, rgba2);
    } else {
      publicAPI.getColor(parseFloat(val), rgba2);
      rgba2[3] = 1;
    }
  };
  publicAPI.checkForAnnotatedValue = (value) => publicAPI.getAnnotatedValueIndexInternal(value);
  publicAPI.getAnnotatedValueIndexInternal = (value) => {
    if (model.annotatedValueMap[value] !== void 0) {
      const na = model.annotationArray.length;
      return model.annotatedValueMap[value] % na;
    }
    return -1;
  };
  publicAPI.getIndexedColor = (val, rgba2) => {
    rgba2[0] = 0;
    rgba2[1] = 0;
    rgba2[2] = 0;
    rgba2[3] = 0;
  };
  publicAPI.updateAnnotatedValueMap = () => {
    model.annotatedValueMap = [];
    const na = model.annotationArray.length;
    for (let i = 0; i < na; i++) {
      model.annotatedValueMap[model.annotationArray[i].value] = i;
    }
  };
  publicAPI.mapScalars = (scalars, colorMode, componentIn) => {
    const numberOfComponents = scalars.getNumberOfComponents();
    let newColors = null;
    if (colorMode === ColorMode2.DEFAULT && (scalars.getDataType() === VtkDataTypes3.UNSIGNED_CHAR || scalars.getDataType() === VtkDataTypes3.UNSIGNED_CHAR_CLAMPED) || colorMode === ColorMode2.DIRECT_SCALARS && scalars) {
      newColors = publicAPI.convertToRGBA(scalars, numberOfComponents, scalars.getNumberOfTuples());
    } else {
      const newscalars = {
        type: "vtkDataArray",
        name: "temp",
        numberOfComponents: 4,
        dataType: VtkDataTypes3.UNSIGNED_CHAR
      };
      const s = macro.newTypedArray(newscalars.dataType, 4 * scalars.getNumberOfTuples());
      newscalars.values = s;
      newscalars.size = s.length;
      newColors = vtkDataArray$1.newInstance(newscalars);
      let component = componentIn;
      if (component < 0 && numberOfComponents > 1) {
        publicAPI.mapVectorsThroughTable(scalars, newColors, ScalarMappingTarget2.RGBA, -1, -1);
      } else {
        if (component < 0) {
          component = 0;
        }
        if (component >= numberOfComponents) {
          component = numberOfComponents - 1;
        }
        publicAPI.mapScalarsThroughTable(scalars, newColors, ScalarMappingTarget2.RGBA, component);
      }
    }
    return newColors;
  };
  publicAPI.mapVectorsToMagnitude = (input, output, compsToUse) => {
    const length4 = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    for (let i = 0; i < length4; i++) {
      let sum2 = 0;
      for (let j = 0; j < compsToUse; j++) {
        sum2 += inputV[i * inIncr + j] * inputV[i * inIncr + j];
      }
      outputV[i] = Math.sqrt(sum2);
    }
  };
  publicAPI.mapVectorsThroughTable = (input, output, outputFormat, vectorComponentIn, vectorSizeIn) => {
    let vectorMode = publicAPI.getVectorMode();
    let vectorSize = vectorSizeIn;
    let vectorComponent = vectorComponentIn;
    const inComponents = input.getNumberOfComponents();
    if (vectorMode === VectorMode2.COMPONENT) {
      if (vectorComponent === -1) {
        vectorComponent = publicAPI.getVectorComponent();
      }
      if (vectorComponent < 0) {
        vectorComponent = 0;
      }
      if (vectorComponent >= inComponents) {
        vectorComponent = inComponents - 1;
      }
    } else {
      if (vectorSize === -1) {
        vectorSize = publicAPI.getVectorSize();
      }
      if (vectorSize <= 0) {
        vectorComponent = 0;
        vectorSize = inComponents;
      } else {
        if (vectorComponent < 0) {
          vectorComponent = 0;
        }
        if (vectorComponent >= inComponents) {
          vectorComponent = inComponents - 1;
        }
        if (vectorComponent + vectorSize > inComponents) {
          vectorSize = inComponents - vectorComponent;
        }
      }
      if (vectorMode === VectorMode2.MAGNITUDE && (inComponents === 1 || vectorSize === 1)) {
        vectorMode = VectorMode2.COMPONENT;
      }
    }
    let inputOffset = 0;
    if (vectorComponent > 0) {
      inputOffset = vectorComponent;
    }
    switch (vectorMode) {
      case VectorMode2.COMPONENT: {
        publicAPI.mapScalarsThroughTable(input, output, outputFormat, inputOffset);
        break;
      }
      case VectorMode2.RGBCOLORS: {
        break;
      }
      case VectorMode2.MAGNITUDE:
      default: {
        const magValues = vtkDataArray$1.newInstance({
          numberOfComponents: 1,
          values: new Float32Array(input.getNumberOfTuples())
        });
        publicAPI.mapVectorsToMagnitude(input, magValues, vectorSize);
        publicAPI.mapScalarsThroughTable(magValues, output, outputFormat, 0);
        break;
      }
    }
  };
  publicAPI.luminanceToRGBA = (newColors, colors, alpha, convtFun) => {
    const a = convtFun(alpha);
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 1;
    let count2 = 0;
    for (let i = component; i < size; i += tuple) {
      const l = convtFun(values[i]);
      newValues[count2 * 4] = l;
      newValues[count2 * 4 + 1] = l;
      newValues[count2 * 4 + 2] = l;
      newValues[count2 * 4 + 3] = a;
      count2++;
    }
  };
  publicAPI.luminanceAlphaToRGBA = (newColors, colors, alpha, convtFun) => {
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 2;
    let count2 = 0;
    for (let i = component; i < size; i += tuple) {
      const l = convtFun(values[i]);
      newValues[count2] = l;
      newValues[count2 + 1] = l;
      newValues[count2 + 2] = l;
      newValues[count2 + 3] = convtFun(values[i + 1]) * alpha;
      count2 += 4;
    }
  };
  publicAPI.rGBToRGBA = (newColors, colors, alpha, convtFun) => {
    const a = floatColorToUChar(alpha);
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 3;
    let count2 = 0;
    for (let i = component; i < size; i += tuple) {
      newValues[count2 * 4] = convtFun(values[i]);
      newValues[count2 * 4 + 1] = convtFun(values[i + 1]);
      newValues[count2 * 4 + 2] = convtFun(values[i + 2]);
      newValues[count2 * 4 + 3] = a;
      count2++;
    }
  };
  publicAPI.rGBAToRGBA = (newColors, colors, alpha, convtFun) => {
    const values = colors.getData();
    const newValues = newColors.getData();
    const size = values.length;
    const component = 0;
    const tuple = 4;
    let count2 = 0;
    for (let i = component; i < size; i += tuple) {
      newValues[count2 * 4] = convtFun(values[i]);
      newValues[count2 * 4 + 1] = convtFun(values[i + 1]);
      newValues[count2 * 4 + 2] = convtFun(values[i + 2]);
      newValues[count2 * 4 + 3] = convtFun(values[i + 3]) * alpha;
      count2++;
    }
  };
  publicAPI.convertToRGBA = (colors, numComp, numTuples) => {
    let {
      alpha
    } = model;
    if (numComp === 4 && alpha >= 1 && colors.getDataType() === VtkDataTypes3.UNSIGNED_CHAR) {
      return colors;
    }
    const newColors = vtkDataArray$1.newInstance({
      numberOfComponents: 4,
      empty: true,
      size: 4 * numTuples,
      dataType: VtkDataTypes3.UNSIGNED_CHAR
    });
    if (numTuples <= 0) {
      return newColors;
    }
    alpha = alpha > 0 ? alpha : 0;
    alpha = alpha < 1 ? alpha : 1;
    let convtFun = intColorToUChar;
    if (colors.getDataType() === VtkDataTypes3.FLOAT || colors.getDataType() === VtkDataTypes3.DOUBLE) {
      convtFun = floatColorToUChar;
    }
    switch (numComp) {
      case 1:
        publicAPI.luminanceToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 2:
        publicAPI.luminanceAlphaToRGBA(newColors, colors, convtFun);
        break;
      case 3:
        publicAPI.rGBToRGBA(newColors, colors, alpha, convtFun);
        break;
      case 4:
        publicAPI.rGBAToRGBA(newColors, colors, alpha, convtFun);
        break;
      default:
        vtkErrorMacro6("Cannot convert colors");
        return null;
    }
    return newColors;
  };
  publicAPI.usingLogScale = () => false;
  publicAPI.getNumberOfAvailableColors = () => 256 * 256 * 256;
  publicAPI.setRange = (min4, max4) => publicAPI.setMappingRange(min4, max4);
  publicAPI.getRange = () => publicAPI.getMappingRange();
  publicAPI.areScalarsOpaque = (scalars, colorMode, componentIn) => {
    if (!scalars) {
      return publicAPI.isOpaque();
    }
    const numberOfComponents = scalars.getNumberOfComponents();
    if (colorMode === ColorMode2.DEFAULT && scalars.getDataType() === VtkDataTypes3.UNSIGNED_CHAR || colorMode === ColorMode2.DIRECT_SCALARS) {
      if (numberOfComponents === 3 || numberOfComponents === 1) {
        return model.alpha >= 1;
      }
      const range2 = scalars.getRange(numberOfComponents - 1);
      return range2[0] === 255;
    }
    return true;
  };
}
var DEFAULT_VALUES23 = {
  alpha: 1,
  vectorComponent: 0,
  vectorSize: -1,
  vectorMode: VectorMode2.COMPONENT,
  mappingRange: null,
  annotationArray: null,
  annotatedValueMap: null,
  indexedLookup: false,
  scale: Scale2.LINEAR
};
function extend25(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES23, initialValues);
  macro.obj(publicAPI, model);
  model.mappingRange = [0, 255];
  model.annotationArray = [];
  model.annotatedValueMap = [];
  macro.setGet(publicAPI, model, ["vectorSize", "vectorComponent", "vectorMode", "alpha", "indexedLookup"]);
  macro.setArray(publicAPI, model, ["mappingRange"], 2);
  macro.getArray(publicAPI, model, ["mappingRange"]);
  vtkScalarsToColors2(publicAPI, model);
}
var newInstance24 = macro.newInstance(extend25, "vtkScalarsToColors");
var vtkScalarsToColors$1 = {
  newInstance: newInstance24,
  extend: extend25,
  ...vtkScalarsToColors
};

// node_modules/@kitware/vtk.js/Common/Core/LookupTable.js
var {
  vtkErrorMacro: vtkErrorMacro7
} = macro;
var BELOW_RANGE_COLOR_INDEX = 0;
var ABOVE_RANGE_COLOR_INDEX = 1;
var NAN_COLOR_INDEX = 2;
function vtkLookupTable(publicAPI, model) {
  model.classHierarchy.push("vtkLookupTable");
  publicAPI.isOpaque = () => {
    if (model.opaqueFlagBuildTime.getMTime() < publicAPI.getMTime()) {
      let opaque = true;
      if (model.nanColor[3] < 1) {
        opaque = 0;
      }
      if (model.useBelowRangeColor && model.belowRangeColor[3] < 1) {
        opaque = 0;
      }
      if (model.useAboveRangeColor && model.aboveRangeColor[3] < 1) {
        opaque = 0;
      }
      for (let i = 3; i < model.table.length && opaque; i += 4) {
        if (model.table[i] < 255) {
          opaque = false;
        }
      }
      model.opaqueFlag = opaque;
      model.opaqueFlagBuildTime.modified();
    }
    return model.opaqueFlag;
  };
  publicAPI.usingLogScale = () => false;
  publicAPI.getNumberOfAvailableColors = () => model.table.length / 4 - 3;
  publicAPI.linearIndexLookup = (v, p) => {
    let dIndex = 0;
    const nv = Number(v);
    if (nv < p.range[0]) {
      dIndex = p.maxIndex + BELOW_RANGE_COLOR_INDEX + 1.5;
    } else if (nv > p.range[1]) {
      dIndex = p.maxIndex + ABOVE_RANGE_COLOR_INDEX + 1.5;
    } else {
      dIndex = (nv + p.shift) * p.scale;
      dIndex = dIndex < p.maxIndex ? dIndex : p.maxIndex;
    }
    return Math.floor(dIndex);
  };
  publicAPI.linearLookup = (v, table, p) => {
    let index2 = 0;
    if (isNan(v)) {
      index2 = Math.floor(p.maxIndex + 1.5 + NAN_COLOR_INDEX);
    } else {
      index2 = publicAPI.linearIndexLookup(v, p);
    }
    const offset = 4 * index2;
    return table.slice(offset, offset + 4);
  };
  publicAPI.indexedLookupFunction = (v, table, p) => {
    let index2 = publicAPI.getAnnotatedValueIndexInternal(v);
    if (index2 === -1) {
      index2 = model.numberOfColors + NAN_COLOR_INDEX;
    }
    const offset = 4 * index2;
    return [table[offset], table[offset + 1], table[offset + 2], table[offset + 3]];
  };
  publicAPI.lookupShiftAndScale = (range2, p) => {
    p.shift = -range2[0];
    p.scale = Number.MAX_VALUE;
    if (range2[1] > range2[0]) {
      p.scale = (p.maxIndex + 1) / (range2[1] - range2[0]);
    }
  };
  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {
    let lookupFunc = publicAPI.linearLookup;
    if (model.indexedLookup) {
      lookupFunc = publicAPI.indexedLookupFunction;
    }
    const trange = publicAPI.getMappingRange();
    const p = {
      maxIndex: publicAPI.getNumberOfColors() - 1,
      range: trange,
      shift: 0,
      scale: 0
    };
    publicAPI.lookupShiftAndScale(trange, p);
    const alpha = publicAPI.getAlpha();
    const length4 = input.getNumberOfTuples();
    const inIncr = input.getNumberOfComponents();
    const outputV = output.getData();
    const inputV = input.getData();
    if (alpha >= 1) {
      if (outFormat === ScalarMappingTarget.RGBA) {
        for (let i = 0; i < length4; i++) {
          const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
          outputV[i * 4] = cptr[0];
          outputV[i * 4 + 1] = cptr[1];
          outputV[i * 4 + 2] = cptr[2];
          outputV[i * 4 + 3] = cptr[3];
        }
      }
    } else {
      if (outFormat === ScalarMappingTarget.RGBA) {
        for (let i = 0; i < length4; i++) {
          const cptr = lookupFunc(inputV[i * inIncr + inputOffset], model.table, p);
          outputV[i * 4] = cptr[0];
          outputV[i * 4 + 1] = cptr[1];
          outputV[i * 4 + 2] = cptr[2];
          outputV[i * 4 + 3] = Math.floor(cptr[3] * alpha + 0.5);
        }
      }
    }
  };
  publicAPI.forceBuild = () => {
    let hinc = 0;
    let sinc = 0;
    let vinc = 0;
    let ainc = 0;
    const maxIndex2 = model.numberOfColors - 1;
    if (maxIndex2) {
      hinc = (model.hueRange[1] - model.hueRange[0]) / maxIndex2;
      sinc = (model.saturationRange[1] - model.saturationRange[0]) / maxIndex2;
      vinc = (model.valueRange[1] - model.valueRange[0]) / maxIndex2;
      ainc = (model.alphaRange[1] - model.alphaRange[0]) / maxIndex2;
    }
    model.table.length = 4 * maxIndex2 + 16;
    const hsv = [];
    const rgba2 = [];
    for (let i = 0; i <= maxIndex2; i++) {
      hsv[0] = model.hueRange[0] + i * hinc;
      hsv[1] = model.saturationRange[0] + i * sinc;
      hsv[2] = model.valueRange[0] + i * vinc;
      hsv2rgb(hsv, rgba2);
      rgba2[3] = model.alphaRange[0] + i * ainc;
      model.table[i * 4] = rgba2[0] * 255 + 0.5;
      model.table[i * 4 + 1] = rgba2[1] * 255 + 0.5;
      model.table[i * 4 + 2] = rgba2[2] * 255 + 0.5;
      model.table[i * 4 + 3] = rgba2[3] * 255 + 0.5;
    }
    publicAPI.buildSpecialColors();
    model.buildTime.modified();
  };
  publicAPI.setTable = (table) => {
    if (Array.isArray(table)) {
      const nbComponents = table[0].length;
      model.numberOfColors = table.length;
      const colorOffset = 4 - nbComponents;
      let offset = 0;
      for (let i = 0; i < model.numberOfColors; i++) {
        model.table[i * 4] = 255;
        model.table[i * 4 + 1] = 255;
        model.table[i * 4 + 2] = 255;
        model.table[i * 4 + 3] = 255;
      }
      for (let i = 0; i < table.length; i++) {
        const color2 = table[i];
        for (let j = 0; j < nbComponents; j++) {
          model.table[offset++] = color2[j];
        }
        offset += colorOffset;
      }
      publicAPI.buildSpecialColors();
      model.insertTime.modified();
      publicAPI.modified();
      return true;
    }
    if (table.getNumberOfComponents() !== 4) {
      vtkErrorMacro7("Expected 4 components for RGBA colors");
      return false;
    }
    if (table.getDataType() !== VtkDataTypes.UNSIGNED_CHAR) {
      vtkErrorMacro7("Expected unsigned char values for RGBA colors");
      return false;
    }
    model.numberOfColors = table.getNumberOfTuples();
    const data = table.getData();
    model.table.length = data.length;
    for (let i = 0; i < data.length; i++) {
      model.table[i] = data[i];
    }
    publicAPI.buildSpecialColors();
    model.insertTime.modified();
    publicAPI.modified();
    return true;
  };
  publicAPI.buildSpecialColors = () => {
    const {
      numberOfColors
    } = model;
    const tptr = model.table;
    let base = (numberOfColors + BELOW_RANGE_COLOR_INDEX) * 4;
    if (model.useBelowRangeColor || numberOfColors === 0) {
      tptr[base] = model.belowRangeColor[0] * 255 + 0.5;
      tptr[base + 1] = model.belowRangeColor[1] * 255 + 0.5;
      tptr[base + 2] = model.belowRangeColor[2] * 255 + 0.5;
      tptr[base + 3] = model.belowRangeColor[3] * 255 + 0.5;
    } else {
      tptr[base] = tptr[0];
      tptr[base + 1] = tptr[1];
      tptr[base + 2] = tptr[2];
      tptr[base + 3] = tptr[3];
    }
    base = (numberOfColors + ABOVE_RANGE_COLOR_INDEX) * 4;
    if (model.useAboveRangeColor || numberOfColors === 0) {
      tptr[base] = model.aboveRangeColor[0] * 255 + 0.5;
      tptr[base + 1] = model.aboveRangeColor[1] * 255 + 0.5;
      tptr[base + 2] = model.aboveRangeColor[2] * 255 + 0.5;
      tptr[base + 3] = model.aboveRangeColor[3] * 255 + 0.5;
    } else {
      tptr[base] = tptr[4 * (numberOfColors - 1) + 0];
      tptr[base + 1] = tptr[4 * (numberOfColors - 1) + 1];
      tptr[base + 2] = tptr[4 * (numberOfColors - 1) + 2];
      tptr[base + 3] = tptr[4 * (numberOfColors - 1) + 3];
    }
    base = (numberOfColors + NAN_COLOR_INDEX) * 4;
    tptr[base] = model.nanColor[0] * 255 + 0.5;
    tptr[base + 1] = model.nanColor[1] * 255 + 0.5;
    tptr[base + 2] = model.nanColor[2] * 255 + 0.5;
    tptr[base + 3] = model.nanColor[3] * 255 + 0.5;
  };
  publicAPI.build = () => {
    if (model.table.length < 1 || publicAPI.getMTime() > model.buildTime.getMTime() && model.insertTime.getMTime() <= model.buildTime.getMTime()) {
      publicAPI.forceBuild();
    }
  };
  if (model.table.length > 0) {
    publicAPI.buildSpecialColors();
    model.insertTime.modified();
  }
}
var DEFAULT_VALUES24 = {
  numberOfColors: 256,
  // table: null,
  hueRange: [0, 0.66667],
  saturationRange: [1, 1],
  valueRange: [1, 1],
  alphaRange: [1, 1],
  nanColor: [0.5, 0, 0, 1],
  belowRangeColor: [0, 0, 0, 1],
  aboveRangeColor: [1, 1, 1, 1],
  useAboveRangeColor: false,
  useBelowRangeColor: false,
  alpha: 1
  // buildTime: null,
  // opaqueFlagBuildTime: null,
  // insertTime: null,
};
function extend26(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES24, initialValues);
  vtkScalarsToColors$1.extend(publicAPI, model, initialValues);
  if (!model.table) {
    model.table = [];
  }
  model.buildTime = {};
  macro.obj(model.buildTime);
  model.opaqueFlagBuildTime = {};
  macro.obj(model.opaqueFlagBuildTime, {
    mtime: 0
  });
  model.insertTime = {};
  macro.obj(model.insertTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["buildTime"]);
  macro.setGet(publicAPI, model, ["numberOfColors", "useAboveRangeColor", "useBelowRangeColor"]);
  macro.setArray(publicAPI, model, ["alphaRange", "hueRange", "saturationRange", "valueRange"], 2);
  macro.setArray(publicAPI, model, ["nanColor", "belowRangeColor", "aboveRangeColor"], 4);
  macro.getArray(publicAPI, model, ["hueRange", "saturationRange", "valueRange", "alphaRange", "nanColor", "belowRangeColor", "aboveRangeColor"]);
  vtkLookupTable(publicAPI, model);
}
var newInstance25 = macro.newInstance(extend26, "vtkLookupTable");
var vtkLookupTable$1 = {
  newInstance: newInstance25,
  extend: extend26
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper/Static.js
var Resolve = {
  Off: 0,
  PolygonOffset: 1
};
var resolveCoincidentTopologyPolygonOffsetFaces = Resolve.PolygonOffset;
var resolveCoincidentTopology = Resolve.Off;
var RESOLVE_COINCIDENT_TOPOLOGY_MODE = ["VTK_RESOLVE_OFF", "VTK_RESOLVE_POLYGON_OFFSET"];
function getResolveCoincidentTopologyPolygonOffsetFaces() {
  return resolveCoincidentTopologyPolygonOffsetFaces;
}
function setResolveCoincidentTopologyPolygonOffsetFaces(value) {
  const changed = resolveCoincidentTopologyPolygonOffsetFaces === value;
  resolveCoincidentTopologyPolygonOffsetFaces = value;
  return changed;
}
function getResolveCoincidentTopology() {
  return resolveCoincidentTopology;
}
function setResolveCoincidentTopology() {
  let mode2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  const changed = resolveCoincidentTopology === mode2;
  resolveCoincidentTopology = mode2;
  return changed;
}
function setResolveCoincidentTopologyToDefault() {
  return setResolveCoincidentTopology(Resolve.Off);
}
function setResolveCoincidentTopologyToOff() {
  return setResolveCoincidentTopology(Resolve.Off);
}
function setResolveCoincidentTopologyToPolygonOffset() {
  return setResolveCoincidentTopology(Resolve.PolygonOffset);
}
function getResolveCoincidentTopologyAsString() {
  return RESOLVE_COINCIDENT_TOPOLOGY_MODE[resolveCoincidentTopology];
}
var otherStaticMethods = {
  Resolve,
  getResolveCoincidentTopologyAsString,
  getResolveCoincidentTopologyPolygonOffsetFaces,
  getResolveCoincidentTopology,
  setResolveCoincidentTopology,
  setResolveCoincidentTopologyPolygonOffsetFaces,
  setResolveCoincidentTopologyToDefault,
  setResolveCoincidentTopologyToOff,
  setResolveCoincidentTopologyToPolygonOffset
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper/CoincidentTopologyHelper.js
function addCoincidentTopologyMethods(publicAPI, model, nameList) {
  nameList.forEach((item) => {
    publicAPI[`get${item.method}`] = () => model[item.key];
    publicAPI[`set${item.method}`] = macro.objectSetterMap.object(publicAPI, model, {
      name: item.key,
      params: ["factor", "offset"]
    });
  });
}
var CATEGORIES = ["Polygon", "Line", "Point"];
var staticOffsetModel = {
  Polygon: {
    factor: 2,
    offset: 0
  },
  Line: {
    factor: 1,
    offset: -1
  },
  Point: {
    factor: 0,
    offset: -2
  }
};
var noOp = () => void 0;
var staticOffsetAPI = {
  modified: noOp
};
addCoincidentTopologyMethods(staticOffsetAPI, staticOffsetModel, CATEGORIES.map((key) => ({
  key,
  method: `ResolveCoincidentTopology${key}OffsetParameters`
})));
function implementCoincidentTopologyMethods(publicAPI, model) {
  if (model.resolveCoincidentTopology === void 0) {
    model.resolveCoincidentTopology = false;
  }
  macro.setGet(publicAPI, model, ["resolveCoincidentTopology"]);
  model.topologyOffset = {
    Polygon: {
      factor: 0,
      offset: 0
    },
    Line: {
      factor: 0,
      offset: 0
    },
    Point: {
      factor: 0,
      offset: 0
    }
  };
  Object.keys(otherStaticMethods).forEach((methodName) => {
    publicAPI[methodName] = otherStaticMethods[methodName];
  });
  Object.keys(staticOffsetAPI).filter((methodName) => methodName !== "modified").forEach((methodName) => {
    publicAPI[methodName] = staticOffsetAPI[methodName];
  });
  addCoincidentTopologyMethods(publicAPI, model.topologyOffset, CATEGORIES.map((key) => ({
    key,
    method: `RelativeCoincidentTopology${key}OffsetParameters`
  })));
  publicAPI.getCoincidentTopologyPolygonOffsetParameters = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPolygonOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyPolygonOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyLineOffsetParameters = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyLineOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyLineOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
  publicAPI.getCoincidentTopologyPointOffsetParameter = () => {
    const globalValue = staticOffsetAPI.getResolveCoincidentTopologyPointOffsetParameters();
    const localValue = publicAPI.getRelativeCoincidentTopologyPointOffsetParameters();
    return {
      factor: globalValue.factor + localValue.factor,
      offset: globalValue.offset + localValue.offset
    };
  };
}
var CoincidentTopologyHelper = {
  implementCoincidentTopologyMethods,
  staticOffsetAPI,
  otherStaticMethods,
  CATEGORIES,
  Resolve
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/HardwareSelector/Constants.js
var PassTypes = {
  MIN_KNOWN_PASS: 0,
  ACTOR_PASS: 0,
  COMPOSITE_INDEX_PASS: 1,
  ID_LOW24: 2,
  ID_HIGH24: 3,
  MAX_KNOWN_PASS: 3
};
var Constants7 = {
  PassTypes
};

// node_modules/@kitware/vtk.js/Rendering/Core/Mapper.js
var {
  FieldAssociations: FieldAssociations2
} = vtkDataSet$1;
var {
  staticOffsetAPI: staticOffsetAPI2,
  otherStaticMethods: otherStaticMethods2
} = CoincidentTopologyHelper;
var {
  ColorMode: ColorMode3,
  ScalarMode: ScalarMode2,
  GetArray: GetArray2
} = Constants6;
var {
  VectorMode: VectorMode3
} = vtkScalarsToColors;
var {
  VtkDataTypes: VtkDataTypes4
} = vtkDataArray$1;
function notImplemented3(method) {
  return () => macro.vtkErrorMacro(`vtkMapper::${method} - NOT IMPLEMENTED`);
}
function updateZigzaggingCoordinates(coordinates, dimensions) {
  const directionX = coordinates[1] % 2 === 0 ? 1 : -1;
  coordinates[0] += directionX;
  if (coordinates[0] >= dimensions[0] || coordinates[0] < 0) {
    const directionY = coordinates[2] % 2 === 0 ? 1 : -1;
    coordinates[0] -= directionX;
    coordinates[1] += directionY;
    if (coordinates[1] >= dimensions[1] || coordinates[1] < 0) {
      coordinates[1] -= directionY;
      coordinates[2]++;
    }
  }
}
function getIndexFromCoordinates(coordinates, dimensions) {
  return coordinates[0] + dimensions[0] * (coordinates[1] + dimensions[1] * coordinates[2]);
}
function getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions) {
  const intTexelIndex = Math.floor(texelIndexPosition);
  const xCoordBeforeWrap = intTexelIndex % (2 * dimensions[0]);
  let xDirection;
  let xEndFlag;
  if (xCoordBeforeWrap < dimensions[0]) {
    textureCoordinate[0] = xCoordBeforeWrap;
    xDirection = 1;
    xEndFlag = textureCoordinate[0] === dimensions[0] - 1;
  } else {
    textureCoordinate[0] = 2 * dimensions[0] - 1 - xCoordBeforeWrap;
    xDirection = -1;
    xEndFlag = textureCoordinate[0] === 0;
  }
  const intRowIndex = Math.floor(intTexelIndex / dimensions[0]);
  const yCoordBeforeWrap = intRowIndex % (2 * dimensions[1]);
  let yDirection;
  let yEndFlag;
  if (yCoordBeforeWrap < dimensions[1]) {
    textureCoordinate[1] = yCoordBeforeWrap;
    yDirection = 1;
    yEndFlag = textureCoordinate[1] === dimensions[1] - 1;
  } else {
    textureCoordinate[1] = 2 * dimensions[1] - 1 - yCoordBeforeWrap;
    yDirection = -1;
    yEndFlag = textureCoordinate[1] === 0;
  }
  textureCoordinate[2] = Math.floor(intRowIndex / dimensions[1]);
  const remainder = texelIndexPosition - intTexelIndex;
  if (xEndFlag) {
    if (yEndFlag) {
      textureCoordinate[2] += remainder;
    } else {
      textureCoordinate[1] += yDirection * remainder;
    }
  } else {
    textureCoordinate[0] += xDirection * remainder;
  }
  textureCoordinate[0] = (textureCoordinate[0] + 0.5) / dimensions[0];
  textureCoordinate[1] = (textureCoordinate[1] + 0.5) / dimensions[1];
  textureCoordinate[2] = (textureCoordinate[2] + 0.5) / dimensions[2];
}
var colorTextureCoordinatesCache = /* @__PURE__ */ new WeakMap();
function getOrCreateColorTextureCoordinates(input, component, range2, useLogScale, numberOfColorsInRange, dimensions, useZigzagPattern) {
  var _a;
  const argStrings = new Array(arguments.length);
  for (let argIndex = 0; argIndex < arguments.length; ++argIndex) {
    const arg = arguments[argIndex];
    argStrings[argIndex] = ((_a = arg.getMTime) == null ? void 0 : _a.call(arg)) ?? arg;
  }
  const stringHash = argStrings.join("/");
  const cachedResult = colorTextureCoordinatesCache.get(input);
  if (cachedResult && cachedResult.stringHash === stringHash) {
    return cachedResult.textureCoordinates;
  }
  const scalarTexelWidth = (range2[1] - range2[0]) / (numberOfColorsInRange - 1);
  const [paddedRangeMin, paddedRangeMax] = [range2[0] - scalarTexelWidth, range2[1] + scalarTexelWidth];
  const textureSOrigin = paddedRangeMin - 0.5 * scalarTexelWidth;
  const textureSCoeff = 1 / (paddedRangeMax - paddedRangeMin + scalarTexelWidth);
  const texelIndexOrigin = paddedRangeMin;
  const texelIndexCoeff = (numberOfColorsInRange + 1) / (paddedRangeMax - paddedRangeMin);
  const inputV = input.getData();
  const numScalars = input.getNumberOfTuples();
  const numComps = input.getNumberOfComponents();
  const useMagnitude = component < 0 || component >= numComps;
  const numberOfOutputComponents = dimensions[2] <= 1 ? 2 : 3;
  const output = vtkDataArray$1.newInstance({
    numberOfComponents: numberOfOutputComponents,
    values: new Float32Array(numScalars * numberOfOutputComponents)
  });
  const outputV = output.getData();
  const nanTextureCoordinate = [0, 0, 0];
  getZigZagTextureCoordinatesFromTexelPosition(nanTextureCoordinate, numberOfColorsInRange + 2, dimensions);
  let inputIdx = 0;
  let outputIdx = 0;
  const textureCoordinate = [0.5, 0.5, 0.5];
  for (let scalarIdx = 0; scalarIdx < numScalars; ++scalarIdx) {
    let scalarValue;
    if (useMagnitude) {
      let sum2 = 0;
      for (let compIdx = 0; compIdx < numComps; ++compIdx) {
        const compValue = Number(inputV[inputIdx + compIdx]);
        sum2 += compValue * compValue;
      }
      scalarValue = Math.sqrt(sum2);
    } else {
      scalarValue = Number(inputV[inputIdx + component]);
    }
    if (useLogScale) {
      scalarValue = Math.log10(scalarValue);
    }
    inputIdx += numComps;
    if (isNan(scalarValue)) {
      textureCoordinate[0] = nanTextureCoordinate[0];
      textureCoordinate[1] = nanTextureCoordinate[1];
      textureCoordinate[2] = nanTextureCoordinate[2];
    } else if (useZigzagPattern) {
      let texelIndexPosition = (scalarValue - texelIndexOrigin) * texelIndexCoeff;
      if (texelIndexPosition < 1) {
        texelIndexPosition = 0;
      } else if (texelIndexPosition > numberOfColorsInRange) {
        texelIndexPosition = numberOfColorsInRange + 1;
      }
      getZigZagTextureCoordinatesFromTexelPosition(textureCoordinate, texelIndexPosition, dimensions);
    } else {
      textureCoordinate[1] = 0.49;
      const textureS = (scalarValue - textureSOrigin) * textureSCoeff;
      if (textureS > 1e3) {
        textureCoordinate[0] = 1e3;
      } else if (textureS < -1e3) {
        textureCoordinate[0] = -1e3;
      } else {
        textureCoordinate[0] = textureS;
      }
    }
    for (let i = 0; i < numberOfOutputComponents; ++i) {
      outputV[outputIdx++] = textureCoordinate[i];
    }
  }
  colorTextureCoordinatesCache.set(input, {
    stringHash,
    textureCoordinates: output
  });
  return output;
}
function vtkMapper(publicAPI, model) {
  model.classHierarchy.push("vtkMapper");
  publicAPI.getBounds = () => {
    const input = publicAPI.getInputData();
    if (!input) {
      model.bounds = createUninitializedBounds();
    } else {
      if (!model.static) {
        publicAPI.update();
      }
      model.bounds = input.getBounds();
    }
    return model.bounds;
  };
  publicAPI.setForceCompileOnly = (v) => {
    model.forceCompileOnly = v;
  };
  publicAPI.setSelectionWebGLIdsToVTKIds = (selectionWebGLIdsToVTKIds) => {
    model.selectionWebGLIdsToVTKIds = selectionWebGLIdsToVTKIds;
  };
  publicAPI.createDefaultLookupTable = () => {
    model.lookupTable = vtkLookupTable$1.newInstance();
  };
  publicAPI.getColorModeAsString = () => macro.enumToString(ColorMode3, model.colorMode);
  publicAPI.setColorModeToDefault = () => publicAPI.setColorMode(0);
  publicAPI.setColorModeToMapScalars = () => publicAPI.setColorMode(1);
  publicAPI.setColorModeToDirectScalars = () => publicAPI.setColorMode(2);
  publicAPI.getScalarModeAsString = () => macro.enumToString(ScalarMode2, model.scalarMode);
  publicAPI.setScalarModeToDefault = () => publicAPI.setScalarMode(0);
  publicAPI.setScalarModeToUsePointData = () => publicAPI.setScalarMode(1);
  publicAPI.setScalarModeToUseCellData = () => publicAPI.setScalarMode(2);
  publicAPI.setScalarModeToUsePointFieldData = () => publicAPI.setScalarMode(3);
  publicAPI.setScalarModeToUseCellFieldData = () => publicAPI.setScalarMode(4);
  publicAPI.setScalarModeToUseFieldData = () => publicAPI.setScalarMode(5);
  publicAPI.getAbstractScalars = (input, scalarMode, arrayAccessMode, arrayId, arrayName) => {
    if (!input || !model.scalarVisibility) {
      return {
        scalars: null,
        cellFlag: false
      };
    }
    let scalars = null;
    let cellFlag = false;
    if (scalarMode === ScalarMode2.DEFAULT) {
      scalars = input.getPointData().getScalars();
      if (!scalars) {
        scalars = input.getCellData().getScalars();
        cellFlag = true;
      }
    } else if (scalarMode === ScalarMode2.USE_POINT_DATA) {
      scalars = input.getPointData().getScalars();
    } else if (scalarMode === ScalarMode2.USE_CELL_DATA) {
      scalars = input.getCellData().getScalars();
      cellFlag = true;
    } else if (scalarMode === ScalarMode2.USE_POINT_FIELD_DATA) {
      const pd = input.getPointData();
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = pd.getArrayByIndex(arrayId);
      } else {
        scalars = pd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode2.USE_CELL_FIELD_DATA) {
      const cd = input.getCellData();
      cellFlag = true;
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = cd.getArrayByIndex(arrayId);
      } else {
        scalars = cd.getArrayByName(arrayName);
      }
    } else if (scalarMode === ScalarMode2.USE_FIELD_DATA) {
      const fd = input.getFieldData();
      if (arrayAccessMode === GetArray2.BY_ID) {
        scalars = fd.getArrayByIndex(arrayId);
      } else {
        scalars = fd.getArrayByName(arrayName);
      }
    }
    return {
      scalars,
      cellFlag
    };
  };
  publicAPI.mapScalars = (input, alpha) => {
    const {
      scalars,
      cellFlag
    } = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    model.areScalarsMappedFromCells = cellFlag;
    if (!scalars) {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      model.colorMapColors = null;
      return;
    }
    const toString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
    if (model.colorBuildString === toString)
      return;
    if (!model.useLookupTableScalarRange) {
      publicAPI.getLookupTable().setRange(model.scalarRange[0], model.scalarRange[1]);
    }
    if (publicAPI.canUseTextureMapForColoring(scalars, cellFlag)) {
      model.mapScalarsToTexture(scalars, cellFlag, alpha);
    } else {
      model.colorCoordinates = null;
      model.colorTextureMap = null;
      const lut = publicAPI.getLookupTable();
      if (lut) {
        lut.build();
        model.colorMapColors = lut.mapScalars(scalars, model.colorMode, model.fieldDataTupleId);
      }
    }
    model.colorBuildString = `${publicAPI.getMTime()}${scalars.getMTime()}${alpha}`;
  };
  model.mapScalarsToTexture = (scalars, cellFlag, alpha) => {
    const range2 = model.lookupTable.getRange();
    const useLogScale = model.lookupTable.usingLogScale();
    const origAlpha = model.lookupTable.getAlpha();
    const scaledRange = useLogScale ? [Math.log10(range2[0]), Math.log10(range2[1])] : range2;
    model.colorMapColors = null;
    if (model.colorTextureMap == null || publicAPI.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getMTime() > model.colorTextureMap.getMTime() || model.lookupTable.getAlpha() !== alpha) {
      model.lookupTable.setAlpha(alpha);
      model.colorTextureMap = null;
      model.lookupTable.build();
      const numberOfAvailableColors = model.lookupTable.getNumberOfAvailableColors();
      const maxTextureWidthForCells = 2048;
      const maxColorsInRangeForCells = maxTextureWidthForCells ** 3 - 3;
      const maxTextureWidthForPoints = 4096;
      const maxColorsInRangeForPoints = maxTextureWidthForPoints - 2;
      const minColorsInRange = 2;
      const maxColorsInRange = cellFlag ? maxColorsInRangeForCells : maxColorsInRangeForPoints;
      model.numberOfColorsInRange = Math.min(Math.max(numberOfAvailableColors, minColorsInRange), maxColorsInRange);
      const numberOfColorsForCells = model.numberOfColorsInRange + 3;
      const numberOfColorsInUpperRowForPoints = model.numberOfColorsInRange + 2;
      const textureDimensions = cellFlag ? [Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 0), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 1), maxTextureWidthForCells), Math.min(Math.ceil(numberOfColorsForCells / maxTextureWidthForCells ** 2), maxTextureWidthForCells)] : [numberOfColorsInUpperRowForPoints, 2, 1];
      const textureSize = textureDimensions[0] * textureDimensions[1] * textureDimensions[2];
      const scalarsArray = new Float64Array(textureSize);
      scalarsArray.fill(NaN);
      const numberOfNonSpecialColors = model.numberOfColorsInRange;
      const numberOfNonNaNColors = numberOfNonSpecialColors + 2;
      const textureCoordinates = [0, 0, 0];
      const rangeMin = scaledRange[0];
      const rangeDifference = scaledRange[1] - scaledRange[0];
      for (let i = 0; i < numberOfNonNaNColors; ++i) {
        const scalarsArrayIndex = getIndexFromCoordinates(textureCoordinates, textureDimensions);
        const intermediateValue = rangeMin + rangeDifference * (i - 1) / (numberOfNonSpecialColors - 1);
        const scalarValue = useLogScale ? 10 ** intermediateValue : intermediateValue;
        scalarsArray[scalarsArrayIndex] = scalarValue;
        updateZigzaggingCoordinates(textureCoordinates, textureDimensions);
      }
      const scalarsDataArray = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: scalarsArray
      });
      const colorsDataArray = model.lookupTable.mapScalars(scalarsDataArray, model.colorMode, 0);
      model.colorTextureMap = vtkImageData$1.newInstance();
      model.colorTextureMap.setDimensions(textureDimensions);
      model.colorTextureMap.getPointData().setScalars(colorsDataArray);
      model.lookupTable.setAlpha(origAlpha);
    }
    const scalarComponent = model.lookupTable.getVectorMode() === VectorMode3.MAGNITUDE && scalars.getNumberOfComponents() > 1 ? -1 : model.lookupTable.getVectorComponent();
    model.colorCoordinates = getOrCreateColorTextureCoordinates(scalars, scalarComponent, scaledRange, useLogScale, model.numberOfColorsInRange, model.colorTextureMap.getDimensions(), cellFlag);
  };
  publicAPI.getIsOpaque = () => {
    const input = publicAPI.getInputData();
    const gasResult = publicAPI.getAbstractScalars(input, model.scalarMode, model.arrayAccessMode, model.arrayId, model.colorByArrayName);
    const scalars = gasResult.scalars;
    if (!model.scalarVisibility || scalars == null) {
      return true;
    }
    const lut = publicAPI.getLookupTable();
    if (lut) {
      lut.build();
      return lut.areScalarsOpaque(scalars, model.colorMode, -1);
    }
    return true;
  };
  publicAPI.canUseTextureMapForColoring = (scalars, cellFlag) => {
    if (cellFlag && !(model.colorMode === ColorMode3.DIRECT_SCALARS)) {
      return true;
    }
    if (!model.interpolateScalarsBeforeMapping) {
      return false;
    }
    if (model.lookupTable && model.lookupTable.getIndexedLookup()) {
      return false;
    }
    if (!scalars) {
      return false;
    }
    if (model.colorMode === ColorMode3.DEFAULT && scalars.getDataType() === VtkDataTypes4.UNSIGNED_CHAR || model.colorMode === ColorMode3.DIRECT_SCALARS) {
      return false;
    }
    return true;
  };
  publicAPI.clearColorArrays = () => {
    model.colorMapColors = null;
    model.colorCoordinates = null;
    model.colorTextureMap = null;
  };
  publicAPI.getLookupTable = () => {
    if (!model.lookupTable) {
      publicAPI.createDefaultLookupTable();
    }
    return model.lookupTable;
  };
  publicAPI.getMTime = () => {
    let mt = model.mtime;
    if (model.lookupTable !== null) {
      const time2 = model.lookupTable.getMTime();
      mt = time2 > mt ? time2 : mt;
    }
    return mt;
  };
  publicAPI.getPrimitiveCount = () => {
    const input = publicAPI.getInputData();
    const pcount = {
      points: input.getPoints().getNumberOfValues() / 3,
      verts: input.getVerts().getNumberOfValues() - input.getVerts().getNumberOfCells(),
      lines: input.getLines().getNumberOfValues() - 2 * input.getLines().getNumberOfCells(),
      triangles: input.getPolys().getNumberOfValues() - 3 * input.getPolys().getNumberOfCells()
    };
    return pcount;
  };
  publicAPI.acquireInvertibleLookupTable = notImplemented3("AcquireInvertibleLookupTable");
  publicAPI.valueToColor = notImplemented3("ValueToColor");
  publicAPI.colorToValue = notImplemented3("ColorToValue");
  publicAPI.useInvertibleColorFor = notImplemented3("UseInvertibleColorFor");
  publicAPI.clearInvertibleColor = notImplemented3("ClearInvertibleColor");
  publicAPI.processSelectorPixelBuffers = (selector, pixelOffsets) => {
    if (!selector || !model.selectionWebGLIdsToVTKIds || !model.populateSelectionSettings) {
      return;
    }
    const rawLowData = selector.getRawPixelBuffer(PassTypes.ID_LOW24);
    const rawHighData = selector.getRawPixelBuffer(PassTypes.ID_HIGH24);
    const currentPass = selector.getCurrentPass();
    const fieldAssociation = selector.getFieldAssociation();
    let idMap = null;
    if (fieldAssociation === FieldAssociations2.FIELD_ASSOCIATION_POINTS) {
      idMap = model.selectionWebGLIdsToVTKIds.points;
    } else if (fieldAssociation === FieldAssociations2.FIELD_ASSOCIATION_CELLS) {
      idMap = model.selectionWebGLIdsToVTKIds.cells;
    }
    if (!idMap) {
      return;
    }
    pixelOffsets.forEach((pos) => {
      if (currentPass === PassTypes.ID_LOW24) {
        let inValue = 0;
        if (rawHighData) {
          inValue += rawHighData[pos];
          inValue *= 256;
        }
        inValue += rawLowData[pos + 2];
        inValue *= 256;
        inValue += rawLowData[pos + 1];
        inValue *= 256;
        inValue += rawLowData[pos];
        const outValue = idMap[inValue];
        const lowData = selector.getPixelBuffer(PassTypes.ID_LOW24);
        lowData[pos] = outValue & 255;
        lowData[pos + 1] = (outValue & 65280) >> 8;
        lowData[pos + 2] = (outValue & 16711680) >> 16;
      } else if (currentPass === PassTypes.ID_HIGH24 && rawHighData) {
        let inValue = 0;
        inValue += rawHighData[pos];
        inValue *= 256;
        inValue += rawLowData[pos + 2];
        inValue *= 256;
        inValue += rawLowData[pos + 1];
        inValue *= 256;
        inValue += rawLowData[pos];
        const outValue = idMap[inValue];
        const highData = selector.getPixelBuffer(PassTypes.ID_HIGH24);
        highData[pos] = (outValue & 4278190080) >> 24;
      }
    });
  };
}
var DEFAULT_VALUES25 = {
  colorMapColors: null,
  // Same as this->Colors
  areScalarsMappedFromCells: false,
  static: false,
  lookupTable: null,
  scalarVisibility: true,
  scalarRange: [0, 1],
  useLookupTableScalarRange: false,
  colorMode: 0,
  scalarMode: 0,
  arrayAccessMode: 1,
  // By_NAME
  renderTime: 0,
  colorByArrayName: null,
  fieldDataTupleId: -1,
  populateSelectionSettings: true,
  selectionWebGLIdsToVTKIds: null,
  interpolateScalarsBeforeMapping: false,
  colorCoordinates: null,
  colorTextureMap: null,
  numberOfColorsInRange: 0,
  forceCompileOnly: 0,
  useInvertibleColors: false,
  invertibleScalars: null,
  customShaderAttributes: []
};
function extend27(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES25, initialValues);
  vtkAbstractMapper3D$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["areScalarsMappedFromCells", "colorCoordinates", "colorMapColors", "colorTextureMap", "numberOfColorsInRange", "selectionWebGLIdsToVTKIds"]);
  macro.setGet(publicAPI, model, [
    "colorByArrayName",
    "arrayAccessMode",
    "colorMode",
    "fieldDataTupleId",
    "interpolateScalarsBeforeMapping",
    "lookupTable",
    "populateSelectionSettings",
    "renderTime",
    "scalarMode",
    "scalarVisibility",
    "static",
    "useLookupTableScalarRange",
    "customShaderAttributes"
    // point data array names that will be transferred to the VBO
  ]);
  macro.setGetArray(publicAPI, model, ["scalarRange"], 2);
  CoincidentTopologyHelper.implementCoincidentTopologyMethods(publicAPI, model);
  vtkMapper(publicAPI, model);
}
var newInstance26 = macro.newInstance(extend27, "vtkMapper");
var vtkMapper$1 = {
  newInstance: newInstance26,
  extend: extend27,
  ...staticOffsetAPI2,
  ...otherStaticMethods2,
  ...Constants6
};

// node_modules/@kitware/vtk.js/Common/Core/CellArray.js
var {
  isVtkObject
} = macro;
function extractCellSizes(cellArray) {
  let currentIdx = 0;
  return cellArray.filter((value, index2) => {
    if (index2 === currentIdx) {
      currentIdx += value + 1;
      return true;
    }
    return false;
  });
}
function getNumberOfCells(cellArray) {
  let cellId = 0;
  for (let cellArrayIndex = 0; cellArrayIndex < cellArray.length; ) {
    cellArrayIndex += cellArray[cellArrayIndex] + 1;
    cellId++;
  }
  return cellId;
}
var STATIC4 = {
  extractCellSizes,
  getNumberOfCells
};
function vtkCellArray(publicAPI, model) {
  model.classHierarchy.push("vtkCellArray");
  const superClass = {
    ...publicAPI
  };
  publicAPI.getNumberOfCells = (recompute) => {
    if (model.numberOfCells !== void 0 && !recompute) {
      return model.numberOfCells;
    }
    if (model.cellSizes) {
      model.numberOfCells = model.cellSizes.length;
    } else {
      model.numberOfCells = getNumberOfCells(publicAPI.getData());
    }
    return model.numberOfCells;
  };
  publicAPI.getCellSizes = (recompute) => {
    if (model.cellSizes !== void 0 && !recompute) {
      return model.cellSizes;
    }
    model.cellSizes = extractCellSizes(publicAPI.getData());
    return model.cellSizes;
  };
  publicAPI.resize = (requestedNumTuples) => {
    const oldNumTuples = publicAPI.getNumberOfTuples();
    superClass.resize(requestedNumTuples);
    const newNumTuples = publicAPI.getNumberOfTuples();
    if (newNumTuples < oldNumTuples) {
      if (newNumTuples === 0) {
        model.numberOfCells = 0;
        model.cellSizes = [];
      } else {
        model.numberOfCells = void 0;
        model.cellSizes = void 0;
      }
    }
  };
  publicAPI.setData = (typedArray) => {
    superClass.setData(typedArray, 1);
    model.numberOfCells = void 0;
    model.cellSizes = void 0;
  };
  publicAPI.getCell = (loc) => {
    let cellLoc = loc;
    const numberOfPoints = model.values[cellLoc++];
    return model.values.subarray(cellLoc, cellLoc + numberOfPoints);
  };
  publicAPI.insertNextCell = (cell) => {
    let cellPointIds;
    if (isVtkObject(cell)) {
      cellPointIds = cell.getPointsIds();
    } else {
      cellPointIds = cell;
    }
    const cellId = publicAPI.getNumberOfCells();
    publicAPI.insertNextTuples([cellPointIds.length, ...cellPointIds]);
    ++model.numberOfCells;
    if (model.cellSizes != null) {
      model.cellSizes.push(cellPointIds.length);
    }
    return cellId;
  };
  publicAPI.getMaxCellSize = () => publicAPI.getCellSizes().reduce((a, b) => Math.max(a, b), 0);
}
function defaultValues2(initialValues) {
  return {
    empty: true,
    numberOfComponents: 1,
    dataType: VtkDataTypes.UNSIGNED_INT,
    ...initialValues
  };
}
function extend28(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkDataArray$1.extend(publicAPI, model, defaultValues2(initialValues));
  vtkCellArray(publicAPI, model);
}
var newInstance27 = macro.newInstance(extend28, "vtkCellArray");
var vtkCellArray$1 = {
  newInstance: newInstance27,
  extend: extend28,
  ...STATIC4
};

// node_modules/@kitware/vtk.js/Common/Core/Points.js
var {
  vtkErrorMacro: vtkErrorMacro8
} = macro;
function vtkPoints(publicAPI, model) {
  let boundMTime = 0;
  model.classHierarchy.push("vtkPoints");
  publicAPI.getNumberOfPoints = publicAPI.getNumberOfTuples;
  publicAPI.setNumberOfPoints = function(nbPoints) {
    let dimension = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
    if (publicAPI.getNumberOfPoints() !== nbPoints) {
      model.size = nbPoints * dimension;
      model.values = macro.newTypedArray(model.dataType, model.size);
      publicAPI.setNumberOfComponents(dimension);
      publicAPI.modified();
    }
  };
  publicAPI.setPoint = function(idx) {
    for (var _len = arguments.length, xyz = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      xyz[_key - 1] = arguments[_key];
    }
    publicAPI.setTuple(idx, xyz);
  };
  publicAPI.getPoint = publicAPI.getTuple;
  publicAPI.findPoint = publicAPI.findTuple;
  publicAPI.insertNextPoint = (x, y, z) => publicAPI.insertNextTuple([x, y, z]);
  publicAPI.insertPoint = (ptId, point2) => publicAPI.insertTuple(ptId, point2);
  const superGetBounds = publicAPI.getBounds;
  publicAPI.getBounds = () => {
    if (boundMTime < model.mtime) {
      publicAPI.computeBounds();
    }
    return superGetBounds();
  };
  const superGetBoundsByReference = publicAPI.getBoundsByReference;
  publicAPI.getBoundsByReference = () => {
    if (boundMTime < model.mtime) {
      publicAPI.computeBounds();
    }
    return superGetBoundsByReference();
  };
  publicAPI.computeBounds = () => {
    if (publicAPI.getNumberOfComponents() === 3) {
      const xRange = publicAPI.getRange(0);
      model.bounds[0] = xRange[0];
      model.bounds[1] = xRange[1];
      const yRange = publicAPI.getRange(1);
      model.bounds[2] = yRange[0];
      model.bounds[3] = yRange[1];
      const zRange = publicAPI.getRange(2);
      model.bounds[4] = zRange[0];
      model.bounds[5] = zRange[1];
    } else if (publicAPI.getNumberOfComponents() === 2) {
      const xRange = publicAPI.getRange(0);
      model.bounds[0] = xRange[0];
      model.bounds[1] = xRange[1];
      const yRange = publicAPI.getRange(1);
      model.bounds[2] = yRange[0];
      model.bounds[3] = yRange[1];
      model.bounds[4] = 0;
      model.bounds[5] = 0;
    } else {
      vtkErrorMacro8(`getBounds called on an array with components of ${publicAPI.getNumberOfComponents()}`);
      uninitializeBounds(model.bounds);
    }
    boundMTime = macro.getCurrentGlobalMTime();
  };
  publicAPI.setNumberOfComponents(model.numberOfComponents < 2 ? 3 : model.numberOfComponents);
}
var DEFAULT_VALUES26 = {
  empty: true,
  numberOfComponents: 3,
  dataType: VtkDataTypes.FLOAT,
  bounds: [1, -1, 1, -1, 1, -1]
};
function extend29(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES26, initialValues);
  vtkDataArray$1.extend(publicAPI, model, initialValues);
  macro.getArray(publicAPI, model, ["bounds"], 6);
  vtkPoints(publicAPI, model);
}
var newInstance28 = macro.newInstance(extend29, "vtkPoints");
var vtkPoints$1 = {
  newInstance: newInstance28,
  extend: extend29
};

// node_modules/@kitware/vtk.js/Common/DataModel/Cell.js
function vtkCell(publicAPI, model) {
  model.classHierarchy.push("vtkCell");
  publicAPI.initialize = function(points) {
    let pointIdsList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!pointIdsList) {
      model.points = points;
      model.pointsIds = new Array(points.getNumberOfPoints());
      for (let i = points.getNumberOfPoints() - 1; i >= 0; --i) {
        model.pointsIds[i] = i;
      }
    } else {
      model.pointsIds = pointIdsList;
      let triangleData = model.points.getData();
      if (triangleData.length !== 3 * model.pointsIds.length) {
        triangleData = macro.newTypedArray(points.getDataType(), 3 * model.pointsIds.length);
      }
      const pointsData = points.getData();
      model.pointsIds.forEach((pointId, index2) => {
        let pointOffset = 3 * pointId;
        let trianglePointOffset = 3 * index2;
        triangleData[trianglePointOffset] = pointsData[pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
        triangleData[++trianglePointOffset] = pointsData[++pointOffset];
      });
      model.points.setData(triangleData);
    }
  };
  publicAPI.getBounds = () => model.points.getBounds();
  publicAPI.getLength2 = () => {
    const lengths = vtkBoundingBox.getLengths(publicAPI.getBounds());
    return lengths[0] * lengths[0] + lengths[1] * lengths[1] + lengths[2] * lengths[2];
  };
  publicAPI.getParametricDistance = (pcoords) => {
    let pDist;
    let pDistMax = 0;
    for (let i = 0; i < 3; i++) {
      if (pcoords[i] < 0) {
        pDist = -pcoords[i];
      } else if (pcoords[i] > 1) {
        pDist = pcoords[i] - 1;
      } else {
        pDist = 0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
  publicAPI.deepCopy = (cell) => {
    cell.initialize(model.points, model.pointsIds);
  };
  publicAPI.getCellDimension = () => {
  };
  publicAPI.intersectWithLine = (p1, p2, tol, t, x, pcoords, subId) => {
  };
  publicAPI.evaluatePosition = (x, closestPoint, subId, pcoords, dist22, weights) => {
    macro.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.");
  };
}
var DEFAULT_VALUES27 = {
  bounds: [-1, -1, -1, -1, -1, -1],
  pointsIds: []
};
function extend30(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES27, initialValues);
  macro.obj(publicAPI, model);
  if (!model.points) {
    model.points = vtkPoints$1.newInstance();
  }
  macro.get(publicAPI, model, ["points", "pointsIds"]);
  vtkCell(publicAPI, model);
}
var newInstance29 = macro.newInstance(extend30, "vtkCell");
var vtkCell$1 = {
  newInstance: newInstance29,
  extend: extend30
};

// node_modules/@kitware/vtk.js/Common/DataModel/CellLinks.js
function resize(model, sz) {
  let newSize = sz;
  if (sz >= model.array.length) {
    newSize += model.array.length;
  }
  while (newSize > model.array.length)
    model.array.push({
      ncells: 0,
      cells: null
    });
  model.array.length = newSize;
}
function vtkCellLinks(publicAPI, model) {
  model.classHierarchy.push("vtkCellLinks");
  publicAPI.buildLinks = (data) => {
    const numPts = data.getPoints().getNumberOfPoints();
    const numCells = data.getNumberOfCells();
    const linkLoc = new Uint32Array(numPts);
    if (data.isA("vtkPolyData")) {
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const {
          cellPointIds
        } = data.getCellPoints(cellId);
        cellPointIds.forEach((cellPointId) => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const {
          cellPointIds
        } = data.getCellPoints(cellId);
        cellPointIds.forEach((cellPointId) => {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
        });
      }
    } else {
      for (let cellId = 0; cellId < numCells; cellId++) {
        const cell = vtkCell$1.newInstance();
        cell.getPointsIds().forEach((cellPointId) => {
          publicAPI.incrementLinkCount(cellPointId);
        });
      }
      publicAPI.allocateLinks(numPts);
      model.maxId = numPts - 1;
      for (let cellId = 0; cellId < numCells; ++cellId) {
        const cell = vtkCell$1.newInstance();
        cell.getPointsIds().forEach((cellPointId) => {
          publicAPI.insertCellReference(cellPointId, linkLoc[cellPointId]++, cellId);
        });
      }
    }
  };
  publicAPI.allocate = function(numLinks) {
    let ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    model.array = Array(numLinks).fill().map(() => ({
      ncells: 0,
      cells: null
    }));
    model.extend = ext;
    model.maxId = -1;
  };
  publicAPI.initialize = () => {
    model.array = null;
  };
  publicAPI.getLink = (ptId) => model.array[ptId];
  publicAPI.getNcells = (ptId) => model.array[ptId].ncells;
  publicAPI.getCells = (ptId) => model.array[ptId].cells;
  publicAPI.insertNextPoint = (numLinks) => {
    model.array.push({
      ncells: numLinks,
      cells: Array(numLinks)
    });
    ++model.maxId;
  };
  publicAPI.insertNextCellReference = (ptId, cellId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };
  publicAPI.deletePoint = (ptId) => {
    model.array[ptId].ncells = 0;
    model.array[ptId].cells = null;
  };
  publicAPI.removeCellReference = (cellId, ptId) => {
    model.array[ptId].cells = model.array[ptId].cells.filter((cell) => cell !== cellId);
    model.array[ptId].ncells = model.array[ptId].cells.length;
  };
  publicAPI.addCellReference = (cellId, ptId) => {
    model.array[ptId].cells[model.array[ptId].ncells++] = cellId;
  };
  publicAPI.resizeCellList = (ptId, size) => {
    model.array[ptId].cells.length = size;
  };
  publicAPI.squeeze = () => {
    resize(model, model.maxId + 1);
  };
  publicAPI.reset = () => {
    model.maxId = -1;
  };
  publicAPI.deepCopy = (src) => {
    model.array = [...src.array];
    model.extend = src.extend;
    model.maxId = src.maxId;
  };
  publicAPI.incrementLinkCount = (ptId) => {
    ++model.array[ptId].ncells;
  };
  publicAPI.allocateLinks = (n) => {
    for (let i = 0; i < n; ++i) {
      model.array[i].cells = new Array(model.array[i].ncells);
    }
  };
  publicAPI.insertCellReference = (ptId, pos, cellId) => {
    model.array[ptId].cells[pos] = cellId;
  };
}
var DEFAULT_VALUES28 = {
  array: null,
  // pointer to data
  maxId: 0,
  // maximum index inserted thus far
  extend: 0
  // grow array by this point
};
function extend31(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES28, initialValues);
  macro.obj(publicAPI, model);
  vtkCellLinks(publicAPI, model);
}
var newInstance30 = macro.newInstance(extend31, "vtkCellLinks");
var vtkCellLinks$1 = {
  newInstance: newInstance30,
  extend: extend31
};

// node_modules/@kitware/vtk.js/Common/DataModel/CellTypes/Constants.js
var CellType = {
  // Linear cells
  VTK_EMPTY_CELL: 0,
  VTK_VERTEX: 1,
  VTK_POLY_VERTEX: 2,
  VTK_LINE: 3,
  VTK_POLY_LINE: 4,
  VTK_TRIANGLE: 5,
  VTK_TRIANGLE_STRIP: 6,
  VTK_POLYGON: 7,
  VTK_PIXEL: 8,
  VTK_QUAD: 9,
  VTK_TETRA: 10,
  VTK_VOXEL: 11,
  VTK_HEXAHEDRON: 12,
  VTK_WEDGE: 13,
  VTK_PYRAMID: 14,
  VTK_PENTAGONAL_PRISM: 15,
  VTK_HEXAGONAL_PRISM: 16,
  // Quadratic, isoparametric cells
  VTK_QUADRATIC_EDGE: 21,
  VTK_QUADRATIC_TRIANGLE: 22,
  VTK_QUADRATIC_QUAD: 23,
  VTK_QUADRATIC_POLYGON: 36,
  VTK_QUADRATIC_TETRA: 24,
  VTK_QUADRATIC_HEXAHEDRON: 25,
  VTK_QUADRATIC_WEDGE: 26,
  VTK_QUADRATIC_PYRAMID: 27,
  VTK_BIQUADRATIC_QUAD: 28,
  VTK_TRIQUADRATIC_HEXAHEDRON: 29,
  VTK_QUADRATIC_LINEAR_QUAD: 30,
  VTK_QUADRATIC_LINEAR_WEDGE: 31,
  VTK_BIQUADRATIC_QUADRATIC_WEDGE: 32,
  VTK_BIQUADRATIC_QUADRATIC_HEXAHEDRON: 33,
  VTK_BIQUADRATIC_TRIANGLE: 34,
  // Cubic, isoparametric cell
  VTK_CUBIC_LINE: 35,
  // Special class of cells formed by convex group of points
  VTK_CONVEX_POINT_SET: 41,
  // Polyhedron cell (consisting of polygonal faces)
  VTK_POLYHEDRON: 42,
  // Higher order cells in parametric form
  VTK_PARAMETRIC_CURVE: 51,
  VTK_PARAMETRIC_SURFACE: 52,
  VTK_PARAMETRIC_TRI_SURFACE: 53,
  VTK_PARAMETRIC_QUAD_SURFACE: 54,
  VTK_PARAMETRIC_TETRA_REGION: 55,
  VTK_PARAMETRIC_HEX_REGION: 56,
  // Higher order cells
  VTK_HIGHER_ORDER_EDGE: 60,
  VTK_HIGHER_ORDER_TRIANGLE: 61,
  VTK_HIGHER_ORDER_QUAD: 62,
  VTK_HIGHER_ORDER_POLYGON: 63,
  VTK_HIGHER_ORDER_TETRAHEDRON: 64,
  VTK_HIGHER_ORDER_WEDGE: 65,
  VTK_HIGHER_ORDER_PYRAMID: 66,
  VTK_HIGHER_ORDER_HEXAHEDRON: 67,
  // Arbitrary order Lagrange elements (formulated separated from generic higher order cells)
  VTK_LAGRANGE_CURVE: 68,
  VTK_LAGRANGE_TRIANGLE: 69,
  VTK_LAGRANGE_QUADRILATERAL: 70,
  VTK_LAGRANGE_TETRAHEDRON: 71,
  VTK_LAGRANGE_HEXAHEDRON: 72,
  VTK_LAGRANGE_WEDGE: 73,
  VTK_LAGRANGE_PYRAMID: 74,
  VTK_NUMBER_OF_CELL_TYPES: 75
};
var CellTypesStrings = ["vtkEmptyCell", "vtkVertex", "vtkPolyVertex", "vtkLine", "vtkPolyLine", "vtkTriangle", "vtkTriangleStrip", "vtkPolygon", "vtkPixel", "vtkQuad", "vtkTetra", "vtkVoxel", "vtkHexahedron", "vtkWedge", "vtkPyramid", "vtkPentagonalPrism", "vtkHexagonalPrism", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkQuadraticEdge", "vtkQuadraticTriangle", "vtkQuadraticQuad", "vtkQuadraticTetra", "vtkQuadraticHexahedron", "vtkQuadraticWedge", "vtkQuadraticPyramid", "vtkBiQuadraticQuad", "vtkTriQuadraticHexahedron", "vtkQuadraticLinearQuad", "vtkQuadraticLinearWedge", "vtkBiQuadraticQuadraticWedge", "vtkBiQuadraticQuadraticHexahedron", "vtkBiQuadraticTriangle", "vtkCubicLine", "vtkQuadraticPolygon", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkConvexPointSet", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "UnknownClass", "vtkParametricCurve", "vtkParametricSurface", "vtkParametricTriSurface", "vtkParametricQuadSurface", "vtkParametricTetraRegion", "vtkParametricHexRegion", "UnknownClass", "UnknownClass", "UnknownClass", "vtkHigherOrderEdge", "vtkHigherOrderTriangle", "vtkHigherOrderQuad", "vtkHigherOrderPolygon", "vtkHigherOrderTetrahedron", "vtkHigherOrderWedge", "vtkHigherOrderPyramid", "vtkHigherOrderHexahedron"];

// node_modules/@kitware/vtk.js/Common/DataModel/CellTypes.js
function getClassNameFromTypeId(typeId) {
  return typeId < CellTypesStrings.length ? CellTypesStrings[typeId] : "UnknownClass";
}
function getTypeIdFromClassName(cellTypeString) {
  return CellTypesStrings.findIndex(cellTypeString);
}
function isLinear(type) {
  return type < CellType.VTK_QUADRATIC_EDGE || type === CellType.VTK_CONVEX_POINT_SET || type === CellType.VTK_POLYHEDRON;
}
function hasSubCells(cellType) {
  return cellType === CellType.VTK_TRIANGLE_STRIP || cellType === CellType.VTK_POLY_LINE || cellType === CellType.VTK_POLY_VERTEX;
}
var STATIC5 = {
  getClassNameFromTypeId,
  getTypeIdFromClassName,
  isLinear,
  hasSubCells
};
function vtkCellTypes(publicAPI, model) {
  model.classHierarchy.push("vtkCellTypes");
  publicAPI.allocate = function() {
    let sz = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 512;
    let ext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e3;
    model.size = sz > 0 ? sz : 1;
    model.extend = ext > 0 ? ext : 1;
    model.maxId = -1;
    model.typeArray = new Uint8Array(sz);
    model.locationArray = new Uint32Array(sz);
  };
  publicAPI.insertCell = (cellId, type, loc) => {
    model.typeArray[cellId] = type;
    model.locationArray[cellId] = loc;
    if (cellId > model.maxId) {
      model.maxId = cellId;
    }
  };
  publicAPI.insertNextCell = (type, loc) => {
    publicAPI.insertCell(++model.maxId, type, loc);
    return model.maxId;
  };
  publicAPI.setCellTypes = (ncells, cellTypes, cellLocations) => {
    model.size = ncells;
    model.typeArray = cellTypes;
    model.locationArray = cellLocations;
    model.maxId = ncells - 1;
  };
  publicAPI.getCellLocation = (cellId) => model.locationArray[cellId];
  publicAPI.deleteCell = (cellId) => {
    model.typeArray[cellId] = CellType.VTK_EMPTY_CELL;
  };
  publicAPI.getNumberOfTypes = () => model.maxId + 1;
  publicAPI.isType = (type) => {
    const numTypes = publicAPI.getNumberOfTypes();
    for (let i = 0; i < numTypes; ++i) {
      if (type === publicAPI.getCellType(i)) {
        return true;
      }
    }
    return false;
  };
  publicAPI.insertNextType = (type) => publicAPI.insertNextCell(type, -1);
  publicAPI.getCellType = (cellId) => model.typeArray[cellId];
  publicAPI.reset = () => {
    model.maxId = -1;
  };
  publicAPI.deepCopy = (src) => {
    publicAPI.allocate(src.getSize(), src.getExtend());
    model.typeArray.set(src.getTypeArray());
    model.locationArray.set(src.getLocationArray());
    model.maxId = src.getMaxId();
  };
}
var DEFAULT_VALUES29 = {
  // typeArray: null, // pointer to types array
  // locationArray: null;   // pointer to array of offsets
  size: 0,
  // allocated size of data
  maxId: -1,
  // maximum index inserted thus far
  extend: 1e3
  // grow array by this point
};
function extend32(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES29, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["size", "maxId", "extend"]);
  macro.getArray(publicAPI, model, ["typeArray", "locationArray"]);
  vtkCellTypes(publicAPI, model);
}
var newInstance31 = macro.newInstance(extend32, "vtkCellTypes");
var vtkCellTypes$1 = {
  newInstance: newInstance31,
  extend: extend32,
  ...STATIC5
};

// node_modules/@kitware/vtk.js/Common/DataModel/Line/Constants.js
var IntersectionState = {
  NO_INTERSECTION: 0,
  YES_INTERSECTION: 1,
  ON_LINE: 2
};
var Constants8 = {
  IntersectionState
};

// node_modules/@kitware/vtk.js/Common/DataModel/Line.js
var {
  IntersectionState: IntersectionState2
} = Constants8;
function distanceToLine(x, p1, p2) {
  let closestPoint = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  const outObj = {
    t: Number.MIN_VALUE,
    distance: 0
  };
  const p21 = [];
  let closest;
  p21[0] = p2[0] - p1[0];
  p21[1] = p2[1] - p1[1];
  p21[2] = p2[2] - p1[2];
  const num = p21[0] * (x[0] - p1[0]) + p21[1] * (x[1] - p1[1]) + p21[2] * (x[2] - p1[2]);
  const denom = dot(p21, p21);
  let tolerance = 1e-5 * num;
  if (denom !== 0) {
    outObj.t = num / denom;
  }
  if (tolerance < 0) {
    tolerance = -tolerance;
  }
  if (-tolerance < denom && denom < tolerance) {
    closest = p1;
  } else if (denom <= 0 || outObj.t < 0) {
    closest = p1;
  } else if (outObj.t > 1) {
    closest = p2;
  } else {
    closest = p21;
    p21[0] = p1[0] + outObj.t * p21[0];
    p21[1] = p1[1] + outObj.t * p21[1];
    p21[2] = p1[2] + outObj.t * p21[2];
  }
  if (closestPoint) {
    closestPoint[0] = closest[0];
    closestPoint[1] = closest[1];
    closestPoint[2] = closest[2];
  }
  outObj.distance = distance2BetweenPoints(closest, x);
  return outObj;
}
function intersection2(a1, a2, b1, b2, u, v) {
  const a21 = [];
  const b21 = [];
  const b1a1 = [];
  u[0] = 0;
  v[0] = 0;
  subtract(a2, a1, a21);
  subtract(b2, b1, b21);
  subtract(b1, a1, b1a1);
  const A2 = [dot(a21, a21), -dot(a21, b21), -dot(a21, b21), dot(b21, b21)];
  const c = [];
  c[0] = dot(a21, b1a1);
  c[1] = -dot(b21, b1a1);
  if (solveLinearSystem(A2, c, 2) === 0) {
    let minDist = Number.MAX_VALUE;
    const p = [a1, a2, b1, b2];
    const l1 = [b1, b1, a1, a1];
    const l2 = [b2, b2, a2, a2];
    [v[0], v[0], u[0], u[0]];
    [u[0], u[0], v[0], v[0]];
    let obj2;
    for (let i = 0; i < 4; i++) {
      obj2 = distanceToLine(p[i], l1[i], l2[i]);
      if (obj2.distance < minDist) {
        minDist = obj2.distance;
        obj2.t;
      }
    }
    return IntersectionState2.ON_LINE;
  }
  u[0] = c[0];
  v[0] = c[1];
  if (u[0] >= 0 && u[0] <= 1 && v[0] >= 0 && v[0] <= 1) {
    return IntersectionState2.YES_INTERSECTION;
  }
  return IntersectionState2.NO_INTERSECTION;
}
var STATIC6 = {
  distanceToLine,
  intersection: intersection2
};
function vtkLine(publicAPI, model) {
  model.classHierarchy.push("vtkLine");
  function isBetweenPoints(t) {
    return t >= 0 && t <= 1;
  }
  publicAPI.getCellDimension = () => 1;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    const outObj = {
      intersect: 0,
      t: Number.MAX_VALUE,
      subId: 0,
      betweenPoints: null
    };
    pcoords[1] = 0;
    pcoords[2] = 0;
    const projXYZ = [];
    const a1 = [];
    const a2 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a2);
    const u = [];
    const v = [];
    const intersect2 = intersection2(p1, p2, a1, a2, u, v);
    outObj.t = u[0];
    outObj.betweenPoints = isBetweenPoints(outObj.t);
    pcoords[0] = v[0];
    if (intersect2 === IntersectionState2.YES_INTERSECTION) {
      for (let i = 0; i < 3; i++) {
        x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
        projXYZ[i] = p1[i] + outObj.t * (p2[i] - p1[i]);
      }
      if (distance2BetweenPoints(x, projXYZ) <= tol * tol) {
        outObj.intersect = 1;
        return outObj;
      }
    } else {
      let outDistance;
      if (outObj.t < 0) {
        outDistance = distanceToLine(p1, a1, a2, x);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 0;
          outObj.intersect = 1;
          outObj.betweenPoints = true;
          return outObj;
        }
        return outObj;
      }
      if (outObj.t > 1) {
        outDistance = distanceToLine(p2, a1, a2, x);
        if (outDistance.distance <= tol * tol) {
          outObj.t = 1;
          outObj.intersect = 1;
          outObj.betweenPoints = true;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] < 0) {
        pcoords[0] = 0;
        outDistance = distanceToLine(a1, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
      if (pcoords[0] > 1) {
        pcoords[0] = 1;
        outDistance = distanceToLine(a2, p1, p2, x);
        outObj.t = outDistance.t;
        if (outDistance.distance <= tol * tol) {
          outObj.intersect = 1;
          return outObj;
        }
        return outObj;
      }
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (pcoords, x, weights) => {
    const a1 = [];
    const a2 = [];
    model.points.getPoint(0, a1);
    model.points.getPoint(1, a2);
    for (let i = 0; i < 3; i++) {
      x[i] = a1[i] + pcoords[0] * (a2[i] - a1[i]);
    }
    weights[0] = 1 - pcoords[0];
    weights[1] = pcoords[0];
  };
  publicAPI.evaluateOrientation = (pcoords, q, weights) => {
    if (model.orientations) {
      quat_exports.slerp(q, model.orientations[0], model.orientations[1], pcoords[0]);
      weights[0] = 1 - pcoords[0];
      weights[1] = pcoords[0];
      return true;
    }
    return false;
  };
}
var DEFAULT_VALUES30 = {
  orientations: null
  // an array of two quat or null
};
function extend33(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES30, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["orientations"]);
  vtkLine(publicAPI, model);
}
var newInstance32 = macro.newInstance(extend33, "vtkLine");
var vtkLine$1 = {
  newInstance: newInstance32,
  extend: extend33,
  ...STATIC6,
  ...Constants8
};

// node_modules/@kitware/vtk.js/Common/DataModel/PointSet.js
function vtkPointSet(publicAPI, model) {
  model.classHierarchy.push("vtkPointSet");
  if (!model.points) {
    model.points = vtkPoints$1.newInstance();
  } else {
    model.points = vtk(model.points);
  }
  publicAPI.getNumberOfPoints = () => model.points.getNumberOfPoints();
  publicAPI.getBounds = () => model.points.getBounds();
  publicAPI.computeBounds = () => {
    publicAPI.getBounds();
  };
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    model.points = vtkPoints$1.newInstance();
    model.points.shallowCopy(other.getPoints());
  };
  const superGetMTime = publicAPI.getMTime;
  publicAPI.getMTime = () => {
    var _a;
    const mTime = superGetMTime();
    return Math.max(mTime, ((_a = model.points) == null ? void 0 : _a.getMTime()) ?? mTime);
  };
  const superInitialize = publicAPI.initialize;
  publicAPI.initialize = () => {
    var _a;
    (_a = model.points) == null ? void 0 : _a.initialize();
    return superInitialize();
  };
}
var DEFAULT_VALUES31 = {
  // points: null,
};
function extend34(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES31, initialValues);
  vtkDataSet$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["points"]);
  vtkPointSet(publicAPI, model);
}
var newInstance33 = macro.newInstance(extend34, "vtkPointSet");
var vtkPointSet$1 = {
  newInstance: newInstance33,
  extend: extend34
};

// node_modules/@kitware/vtk.js/Common/DataModel/PolyLine.js
function vtkPolyLine(publicAPI, model) {
  model.classHierarchy.push("vtkPolyLine");
  const line = vtkLine$1.newInstance();
  line.getPoints().setNumberOfPoints(2);
  publicAPI.getCellDimension = () => 1;
  publicAPI.intersectWithLine = (t13, t22, p1, p2, tol, x, pcoords) => {
    const outObj = {
      intersect: 0,
      t: Number.MAX_VALUE,
      subId: 0,
      betweenPoints: null
    };
    const numLines = publicAPI.getNumberOfPoints() - 1;
    let pDistMin = Number.MAX_VALUE;
    for (let subId = 0; subId < numLines; subId++) {
      const pCoords = [0, 0, 0];
      line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));
      const lineIntersected = line.intersectWithLine(p1, p2, tol, x, pcoords);
      if (lineIntersected.intersect === 1 && lineIntersected.t <= outObj.t + tol && lineIntersected.t >= t13 && lineIntersected.t <= t22) {
        outObj.intersect = 1;
        const pDist = line.getParametricDistance(pCoords);
        if (pDist < pDistMin || pDist === pDistMin && lineIntersected.t < outObj.t) {
          outObj.subId = subId;
          outObj.t = lineIntersected.t;
          pDistMin = pDist;
          for (let k = 0; k < 3; k++) {
            x[k];
            pCoords[k];
          }
        }
      }
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (subId, pcoords, x, weights) => {
    line.getPoints().getData().set(model.points.getData().subarray(3 * subId, 3 * (subId + 2)));
    return line.evaluateLocation(pcoords, x, weights);
  };
  publicAPI.evaluateOrientation = (subId, pcoords, q, weights) => {
    if (model.orientations) {
      line.setOrientations([model.orientations[subId], model.orientations[subId + 1]]);
    } else {
      line.setOrientations(null);
    }
    return line.evaluateOrientation(pcoords, q, weights);
  };
  publicAPI.getDistancesToFirstPoint = () => {
    const dTime = model.distancesTime.getMTime();
    if (dTime < model.points.getMTime() || dTime < publicAPI.getMTime()) {
      const numPoints = publicAPI.getNumberOfPoints();
      if (!model.distances) {
        model.distances = new Array(numPoints);
      } else {
        model.distances.length = numPoints;
      }
      if (numPoints > 0) {
        const previousPoint = new Array(3);
        const currentPoint = new Array(3);
        let totalDistance = 0;
        model.distances[0] = totalDistance;
        model.points.getPoint(0, previousPoint);
        for (let i = 1; i < numPoints; ++i) {
          model.points.getPoint(i, currentPoint);
          totalDistance += model.distanceFunction(previousPoint, currentPoint);
          model.distances[i] = totalDistance;
          vec3_exports.copy(previousPoint, currentPoint);
        }
      }
      model.distancesTime.modified();
    }
    return model.distances;
  };
  publicAPI.findPointIdAtDistanceFromFirstPoint = (distance3) => {
    const distances = publicAPI.getDistancesToFirstPoint();
    if (distances.length < 2) {
      return -1;
    }
    let minId = 0;
    let maxId = distances.length - 1;
    if (distance3 < distances[minId] || distance3 > distances[maxId] || distances[maxId] === 0) {
      return -1;
    }
    while (maxId - minId > 1) {
      const midId = Math.floor((minId + maxId) / 2);
      if (distances[midId] <= distance3) {
        minId = midId;
      } else {
        maxId = midId;
      }
    }
    return minId;
  };
}
var DEFAULT_VALUES32 = {
  orientations: null,
  // an array of quat or null
  distanceFunction: vec3_exports.dist
};
function extend35(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES32, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["orientations", "distanceFunction"]);
  model.distancesTime = {};
  macro.obj(model.distancesTime, {
    mtime: 0
  });
  vtkPolyLine(publicAPI, model);
}
var newInstance34 = macro.newInstance(extend35, "vtkPolyLine");
var vtkPolyLine$1 = {
  newInstance: newInstance34,
  extend: extend35
};

// node_modules/@kitware/vtk.js/Common/Core/PriorityQueue.js
function vtkPriorityQueue(publicAPI, model) {
  model.classHierarchy.push("vtkPriorityQueue");
  publicAPI.push = (priority, element) => {
    const i = model.elements.findIndex((e) => e.priority > priority);
    model.elements.splice(i, 0, {
      priority,
      element
    });
  };
  publicAPI.pop = () => {
    if (model.elements.length > 0) {
      return model.elements.shift().element;
    }
    return null;
  };
  publicAPI.deleteById = (id) => {
    model.elements = model.elements.filter((_ref) => {
      let {
        element
      } = _ref;
      return element.id !== id;
    });
  };
  publicAPI.length = () => model.elements.length;
}
var DEFAULT_VALUES33 = {
  elements: []
};
function extend36(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES33, initialValues);
  macro.obj(publicAPI, model);
  vtkPriorityQueue(publicAPI, model);
}
var newInstance35 = macro.newInstance(extend36, "vtkPriorityQueue");
var vtkPriorityQueue$1 = {
  newInstance: newInstance35,
  extend: extend36
};

// node_modules/@kitware/vtk.js/Common/DataModel/Polygon/Constants.js
var EPSILON2 = 1e-6;
var FLOAT_EPSILON = 11920929e-14;
var TOLERANCE = 1e-8;
var PolygonWithPointIntersectionState = {
  FAILURE: -1,
  OUTSIDE: 0,
  INSIDE: 1,
  INTERSECTION: 2,
  ON_LINE: 3
};

// node_modules/@kitware/vtk.js/Common/DataModel/Polygon.js
function pointLocation(axis0, axis1, p0, p1, point2) {
  return (p1[axis0] - p0[axis0]) * (point2[axis1] - p0[axis1]) - (point2[axis0] - p0[axis0]) * (p1[axis1] - p0[axis1]);
}
function pointInPolygon(point2, vertices, bounds, normal) {
  if (point2[0] < bounds[0] || point2[0] > bounds[1] || point2[1] < bounds[2] || point2[1] > bounds[3] || point2[2] < bounds[4] || point2[2] > bounds[5]) {
    return PolygonWithPointIntersectionState.OUTSIDE;
  }
  if (normalize(normal) <= FLOAT_EPSILON) {
    return PolygonWithPointIntersectionState.FAILURE;
  }
  let tol2 = TOLERANCE * ((bounds[1] - bounds[0]) * (bounds[1] - bounds[0]) + (bounds[3] - bounds[2]) * (bounds[3] - bounds[2]) + (bounds[5] - bounds[4]) * (bounds[5] - bounds[4]));
  tol2 *= tol2;
  tol2 = tol2 === 0 ? FLOAT_EPSILON : tol2;
  const p0 = [];
  const p1 = [];
  for (let i = 0; i < vertices.length; ) {
    p0[0] = vertices[i++];
    p0[1] = vertices[i++];
    p0[2] = vertices[i++];
    if (distance2BetweenPoints(point2, p0) <= tol2) {
      return PolygonWithPointIntersectionState.INSIDE;
    }
    const {
      distance: distance3,
      t
    } = vtkLine$1.distanceToLine(point2, p0, p1);
    if (distance3 <= tol2 && t > 0 && t < 1) {
      return PolygonWithPointIntersectionState.INSIDE;
    }
  }
  let axis0;
  let axis1;
  if (Math.abs(normal[0]) > Math.abs(normal[1])) {
    if (Math.abs(normal[0]) > Math.abs(normal[2])) {
      axis0 = 1;
      axis1 = 2;
    } else {
      axis0 = 0;
      axis1 = 1;
    }
  } else if (Math.abs(normal[1]) > Math.abs(normal[2])) {
    axis0 = 0;
    axis1 = 2;
  } else {
    axis0 = 0;
    axis1 = 1;
  }
  let wn = 0;
  for (let i = 0; i < vertices.length; ) {
    p0[0] = vertices[i++];
    p0[1] = vertices[i++];
    p0[2] = vertices[i++];
    if (i < vertices.length) {
      p1[0] = vertices[i];
      p1[1] = vertices[i + 1];
      p1[2] = vertices[i + 2];
    } else {
      p1[0] = vertices[0];
      p1[1] = vertices[1];
      p1[2] = vertices[2];
    }
    if (p0[axis1] <= point2[axis1]) {
      if (p1[axis1] > point2[axis1]) {
        if (pointLocation(axis0, axis1, p0, p1, point2) > 0) {
          ++wn;
        }
      }
    } else if (p1[axis1] <= point2[axis1]) {
      if (pointLocation(axis0, axis1, p0, p1, point2) < 0) {
        --wn;
      }
    }
  }
  return wn === 0 ? PolygonWithPointIntersectionState.OUTSIDE : PolygonWithPointIntersectionState.INSIDE;
}
function getBounds(poly, points, bounds) {
  const n = poly.length;
  const p = [];
  points.getPoint(poly[0], p);
  bounds[0] = p[0];
  bounds[1] = p[0];
  bounds[2] = p[1];
  bounds[3] = p[1];
  bounds[4] = p[2];
  bounds[5] = p[2];
  for (let j = 1; j < n; j++) {
    points.getPoint(poly[j], p);
    vtkBoundingBox.addPoint(bounds, ...p);
  }
  const length4 = vtkBoundingBox.getLengths(bounds);
  return dot(length4, length4);
}
function getNormal(poly, points, normal) {
  normal.length = 3;
  normal[0] = 0;
  normal[1] = 0;
  normal[2] = 0;
  const p0 = [];
  let p1 = [];
  let p2 = [];
  const v1 = [];
  const v2 = [];
  points.getPoint(poly[0], p0);
  points.getPoint(poly[1], p1);
  for (let j = 2; j < poly.length; j++) {
    points.getPoint(poly[j], p2);
    subtract(p2, p1, v1);
    subtract(p0, p1, v2);
    const n = [0, 0, 0];
    cross(v1, v2, n);
    add(normal, n, normal);
    [p1, p2] = [p2, p1];
  }
  return normalize(normal);
}
function computeCentroid(poly, points) {
  let centroid = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [0, 0, 0];
  centroid[0] = 0;
  centroid[1] = 0;
  centroid[2] = 0;
  const n = poly.length;
  const p = [];
  for (let i = 0; i < n; i++) {
    points.getPoint(poly[i], p);
    centroid[0] += p[0];
    centroid[1] += p[1];
    centroid[2] += p[2];
  }
  centroid[0] /= n;
  centroid[1] /= n;
  centroid[2] /= n;
  return centroid;
}
var STATIC7 = {
  PolygonWithPointIntersectionState,
  pointInPolygon,
  getBounds,
  getNormal,
  computeCentroid
};
function vtkPolygon(publicAPI, model) {
  model.classHierarchy.push("vtkPolygon");
  function computeNormal2() {
    const v1 = [0, 0, 0];
    const v2 = [0, 0, 0];
    model.normal = [0, 0, 0];
    const anchor = [...model.firstPoint.point];
    let point2 = model.firstPoint;
    for (let i = 0; i < model.pointCount; i++) {
      subtract(point2.point, anchor, v1);
      subtract(point2.next.point, anchor, v2);
      const n = [0, 0, 0];
      cross(v1, v2, n);
      add(model.normal, n, model.normal);
      point2 = point2.next;
    }
    return normalize(model.normal);
  }
  function computeMeasure(point2) {
    const v1 = [0, 0, 0];
    const v2 = [0, 0, 0];
    const v3 = [0, 0, 0];
    const v4 = [0, 0, 0];
    subtract(point2.point, point2.previous.point, v1);
    subtract(point2.next.point, point2.point, v2);
    subtract(point2.previous.point, point2.next.point, v3);
    cross(v1, v2, v4);
    const area = dot(v4, model.normal);
    if (area <= 0) {
      return -1;
    }
    const perimeter = norm(v1) + norm(v2) + norm(v3);
    return perimeter * perimeter / area;
  }
  function canRemoveVertex(point2) {
    if (model.pointCount <= 3) {
      return true;
    }
    const previous = point2.previous;
    const next = point2.next;
    const v = [0, 0, 0];
    subtract(next.point, previous.point, v);
    const sN = [0, 0, 0];
    cross(v, model.normal, sN);
    normalize(sN);
    if (norm(sN) === 0) {
      return false;
    }
    let val = vtkPlane$1.evaluate(sN, previous.point, next.next.point);
    let currentSign = val > EPSILON2 ? 1 : val < -EPSILON2 ? -1 : 0;
    let oneNegative = currentSign < 0 ? 1 : 0;
    for (let vertex = next.next.next; vertex.id !== previous.id; vertex = vertex.next) {
      const previousVertex = vertex.previous;
      val = vtkPlane$1.evaluate(sN, previous.point, vertex.point);
      const sign = val > EPSILON2 ? 1 : val < -EPSILON2 ? -1 : 0;
      if (sign !== currentSign) {
        if (!oneNegative) {
          oneNegative = sign <= 0 ? 1 : 0;
        }
        if (vtkLine$1.intersection(previous.point, next.point, vertex.point, previousVertex.point, [0], [0]) === IntersectionState.YES_INTERSECTION) {
          return false;
        }
        currentSign = sign;
      }
    }
    return oneNegative === 1;
  }
  function removePoint(point2, queue) {
    model.pointCount -= 1;
    const previous = point2.previous;
    const next = point2.next;
    model.tris = model.tris.concat(point2.point);
    model.tris = model.tris.concat(next.point);
    model.tris = model.tris.concat(previous.point);
    previous.next = next;
    next.previous = previous;
    queue.deleteById(previous.id);
    queue.deleteById(next.id);
    const previousMeasure = computeMeasure(previous);
    if (previousMeasure > 0) {
      queue.push(previousMeasure, previous);
    }
    const nextMeasure = computeMeasure(next);
    if (nextMeasure > 0) {
      queue.push(nextMeasure, next);
    }
    if (point2.id === model.firstPoint.id) {
      model.firstPoint = next;
    }
  }
  function earCutTriangulation() {
    computeNormal2();
    const vertexQueue = vtkPriorityQueue$1.newInstance();
    let point2 = model.firstPoint;
    for (let i = 0; i < model.pointCount; i++) {
      const measure = computeMeasure(point2);
      if (measure > 0) {
        vertexQueue.push(measure, point2);
      }
      point2 = point2.next;
    }
    while (model.pointCount > 2 && vertexQueue.length() > 0) {
      if (model.pointCount === vertexQueue.length()) {
        const pointToRemove = vertexQueue.pop();
        removePoint(pointToRemove, vertexQueue);
      } else {
        const pointToRemove = vertexQueue.pop();
        if (canRemoveVertex(pointToRemove)) {
          removePoint(pointToRemove, vertexQueue);
        }
      }
    }
    return model.pointCount <= 2;
  }
  publicAPI.triangulate = () => {
    if (!model.firstPoint) {
      return null;
    }
    return earCutTriangulation();
  };
  publicAPI.setPoints = (points) => {
    model.pointCount = points.length;
    model.firstPoint = {
      id: 0,
      point: points[0],
      next: null,
      previous: null
    };
    let currentPoint = model.firstPoint;
    for (let i = 1; i < model.pointCount; i++) {
      currentPoint.next = {
        id: i,
        point: points[i],
        next: null,
        previous: currentPoint
      };
      currentPoint = currentPoint.next;
    }
    model.firstPoint.previous = currentPoint;
    currentPoint.next = model.firstPoint;
  };
  publicAPI.getPointArray = () => model.tris;
}
var DEFAULT_VALUES34 = {
  firstPoint: null,
  pointCount: 0,
  tris: []
};
function extend37(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES34, initialValues);
  macro.obj(publicAPI, model);
  vtkPolygon(publicAPI, model);
}
var newInstance36 = macro.newInstance(extend37, "vtkPolygon");
var vtkPolygon$1 = {
  newInstance: newInstance36,
  extend: extend37,
  ...STATIC7
};

// node_modules/@kitware/vtk.js/Common/DataModel/Triangle.js
function computeNormalDirection(v1, v2, v3, n) {
  const ax = v3[0] - v2[0];
  const ay = v3[1] - v2[1];
  const az = v3[2] - v2[2];
  const bx = v1[0] - v2[0];
  const by = v1[1] - v2[1];
  const bz = v1[2] - v2[2];
  n[0] = ay * bz - az * by;
  n[1] = az * bx - ax * bz;
  n[2] = ax * by - ay * bx;
}
function computeNormal(v1, v2, v3, n) {
  computeNormalDirection(v1, v2, v3, n);
  const length4 = Math.sqrt(n[0] * n[0] + n[1] * n[1] + n[2] * n[2]);
  if (length4 !== 0) {
    n[0] /= length4;
    n[1] /= length4;
    n[2] /= length4;
  }
}
function interpolationDerivs(derivs) {
  derivs[0] = -1;
  derivs[1] = 1;
  derivs[2] = 0;
  derivs[3] = -1;
  derivs[4] = 0;
  derivs[5] = 1;
}
function intersectWithTriangle(p1, q1, r1, p2, q2, r2) {
  let tolerance = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 1e-6;
  let coplanar = false;
  const pt1 = [];
  const pt2 = [];
  const surfaceId = [];
  const n1 = [];
  const n2 = [];
  computeNormal(p1, q1, r1, n1);
  computeNormal(p2, q2, r2, n2);
  const s1 = -dot(n1, p1);
  const s2 = -dot(n2, p2);
  const dist1 = [dot(n2, p1) + s2, dot(n2, q1) + s2, dot(n2, r1) + s2];
  if (dist1[0] * dist1[1] > tolerance && dist1[0] * dist1[2] > tolerance) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  const dist22 = [dot(n1, p2) + s1, dot(n1, q2) + s1, dot(n1, r2) + s1];
  if (dist22[0] * dist22[1] > tolerance && dist22[0] * dist22[2] > tolerance) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (Math.abs(n1[0] - n2[0]) < 1e-9 && Math.abs(n1[1] - n2[1]) < 1e-9 && Math.abs(n1[2] - n2[2]) < 1e-9 && Math.abs(s1 - s2) < 1e-9) {
    coplanar = true;
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  const pts1 = [p1, q1, r1];
  const pts2 = [p2, q2, r2];
  const n1n2 = dot(n1, n2);
  const a = (s1 - s2 * n1n2) / (n1n2 * n1n2 - 1);
  const b = (s2 - s1 * n1n2) / (n1n2 * n1n2 - 1);
  const p = [a * n1[0] + b * n2[0], a * n1[1] + b * n2[1], a * n1[2] + b * n2[2]];
  const v = cross(n1, n2, []);
  normalize(v);
  let index1 = 0;
  let index2 = 0;
  const t13 = [];
  const t22 = [];
  let ts1 = 50;
  let ts2 = 50;
  for (let i = 0; i < 3; i++) {
    const id1 = i;
    const id2 = (i + 1) % 3;
    const val1 = vtkPlane$1.intersectWithLine(pts1[id1], pts1[id2], p2, n2);
    if (val1.intersection && val1.t > 0 - tolerance && val1.t < 1 + tolerance) {
      if (val1.t < 1 + tolerance && val1.t > 1 - tolerance) {
        ts1 = index1;
      }
      t13[index1++] = dot(val1.x, v) - dot(p, v);
    }
    const val2 = vtkPlane$1.intersectWithLine(pts2[id1], pts2[id2], p1, n1);
    if (val2.intersection && val2.t > 0 - tolerance && val2.t < 1 + tolerance) {
      if (val2.t < 1 + tolerance && val2.t > 1 - tolerance) {
        ts2 = index2;
      }
      t22[index2++] = dot(val2.x, v) - dot(p, v);
    }
  }
  if (index1 > 2) {
    index1--;
    const t122 = t13[2];
    t13[2] = t13[ts1];
    t13[ts1] = t122;
  }
  if (index2 > 2) {
    index2--;
    const t222 = t22[2];
    t22[2] = t22[ts2];
    t22[ts2] = t222;
  }
  if (index1 !== 2 || index2 !== 2) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (Number.isNaN(t13[0]) || Number.isNaN(t13[1]) || Number.isNaN(t22[0]) || Number.isNaN(t22[1])) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (t13[0] > t13[1]) {
    const t11 = t13[1];
    t13[1] = t13[0];
    t13[0] = t11;
  }
  if (t22[0] > t22[1]) {
    const t21 = t22[1];
    t22[1] = t22[0];
    t22[0] = t21;
  }
  let tt1;
  let tt2;
  if (t13[1] < t22[0] || t22[1] < t13[0]) {
    return {
      intersect: false,
      coplanar,
      pt1,
      pt2,
      surfaceId
    };
  }
  if (t13[0] < t22[0]) {
    if (t13[1] < t22[1]) {
      surfaceId[0] = 2;
      surfaceId[1] = 1;
      tt1 = t22[0];
      tt2 = t13[1];
    } else {
      surfaceId[0] = 2;
      surfaceId[1] = 2;
      tt1 = t22[0];
      tt2 = t22[1];
    }
  } else if (t13[1] < t22[1]) {
    surfaceId[0] = 1;
    surfaceId[1] = 1;
    tt1 = t13[0];
    tt2 = t13[1];
  } else {
    surfaceId[0] = 1;
    surfaceId[1] = 2;
    tt1 = t13[0];
    tt2 = t22[1];
  }
  multiplyAccumulate(p, v, tt1, pt1);
  multiplyAccumulate(p, v, tt2, pt2);
  return {
    intersect: true,
    coplanar,
    pt1,
    pt2,
    surfaceId
  };
}
var STATIC8 = {
  computeNormalDirection,
  computeNormal,
  interpolationDerivs,
  intersectWithTriangle
};
function vtkTriangle(publicAPI, model) {
  model.classHierarchy.push("vtkTriangle");
  publicAPI.getCellDimension = () => 2;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    const outObj = {
      subId: 0,
      t: Number.MAX_VALUE,
      intersect: 0,
      betweenPoints: false
    };
    pcoords[2] = 0;
    const closestPoint = [];
    const tol2 = tol * tol;
    const pt1 = [];
    const pt2 = [];
    const pt3 = [];
    model.points.getPoint(0, pt1);
    model.points.getPoint(1, pt2);
    model.points.getPoint(2, pt3);
    const n = [];
    const weights = [];
    computeNormal(pt1, pt2, pt3, n);
    if (n[0] !== 0 || n[1] !== 0 || n[2] !== 0) {
      const plane = vtkPlane$1.intersectWithLine(p1, p2, pt1, n);
      outObj.betweenPoints = plane.betweenPoints;
      outObj.t = plane.t;
      x[0] = plane.x[0];
      x[1] = plane.x[1];
      x[2] = plane.x[2];
      if (!plane.intersection) {
        pcoords[0] = 0;
        pcoords[1] = 0;
        outObj.intersect = 0;
        return outObj;
      }
      const inside = publicAPI.evaluatePosition(x, closestPoint, pcoords, weights);
      if (inside.evaluation >= 0) {
        if (inside.dist2 <= tol2) {
          outObj.intersect = 1;
          return outObj;
        }
        outObj.intersect = inside.evaluation;
        return outObj;
      }
    }
    const dist2Pt1Pt2 = distance2BetweenPoints(pt1, pt2);
    const dist2Pt2Pt3 = distance2BetweenPoints(pt2, pt3);
    const dist2Pt3Pt1 = distance2BetweenPoints(pt3, pt1);
    if (!model.line) {
      model.line = vtkLine$1.newInstance();
    }
    if (dist2Pt1Pt2 > dist2Pt2Pt3 && dist2Pt1Pt2 > dist2Pt3Pt1) {
      model.line.getPoints().setPoint(0, pt1);
      model.line.getPoints().setPoint(1, pt2);
    } else if (dist2Pt2Pt3 > dist2Pt3Pt1 && dist2Pt2Pt3 > dist2Pt1Pt2) {
      model.line.getPoints().setPoint(0, pt2);
      model.line.getPoints().setPoint(1, pt3);
    } else {
      model.line.getPoints().setPoint(0, pt3);
      model.line.getPoints().setPoint(1, pt1);
    }
    const intersectLine = model.line.intersectWithLine(p1, p2, tol, x, pcoords);
    outObj.betweenPoints = intersectLine.betweenPoints;
    outObj.t = intersectLine.t;
    if (intersectLine.intersect) {
      const pt3Pt1 = [];
      const pt3Pt2 = [];
      const pt3X = [];
      for (let i = 0; i < 3; i++) {
        pt3Pt1[i] = pt1[i] - pt3[i];
        pt3Pt2[i] = pt2[i] - pt3[i];
        pt3X[i] = x[i] - pt3[i];
      }
      pcoords[0] = dot(pt3X, pt3Pt1) / dist2Pt3Pt1;
      pcoords[1] = dot(pt3X, pt3Pt2) / dist2Pt2Pt3;
      outObj.intersect = 1;
      return outObj;
    }
    pcoords[0] = 0;
    pcoords[1] = 0;
    outObj.intersect = 0;
    return outObj;
  };
  publicAPI.evaluatePosition = (x, closestPoint, pcoords, weights) => {
    const outObj = {
      subId: 0,
      dist2: 0,
      evaluation: -1
    };
    let i;
    let j;
    const pt1 = [];
    const pt2 = [];
    const pt3 = [];
    const n = [];
    let fabsn;
    const rhs = [];
    const c1 = [];
    const c2 = [];
    let det = 0;
    let idx = 0;
    const indices = [];
    let dist2Point;
    let dist2Line1;
    let dist2Line2;
    let closest = [];
    const closestPoint1 = [];
    const closestPoint2 = [];
    const cp = [];
    outObj.subId = 0;
    pcoords[2] = 0;
    model.points.getPoint(1, pt1);
    model.points.getPoint(2, pt2);
    model.points.getPoint(0, pt3);
    computeNormalDirection(pt1, pt2, pt3, n);
    vtkPlane$1.generalizedProjectPoint(x, pt1, n, cp);
    let maxComponent = 0;
    for (i = 0; i < 3; i++) {
      if (n[i] < 0) {
        fabsn = -n[i];
      } else {
        fabsn = n[i];
      }
      if (fabsn > maxComponent) {
        maxComponent = fabsn;
        idx = i;
      }
    }
    for (j = 0, i = 0; i < 3; i++) {
      if (i !== idx) {
        indices[j++] = i;
      }
    }
    for (i = 0; i < 2; i++) {
      rhs[i] = cp[indices[i]] - pt3[indices[i]];
      c1[i] = pt1[indices[i]] - pt3[indices[i]];
      c2[i] = pt2[indices[i]] - pt3[indices[i]];
    }
    det = determinant2x2(c1, c2);
    if (det === 0) {
      pcoords[0] = 0;
      pcoords[1] = 0;
      outObj.evaluation = -1;
      return outObj;
    }
    pcoords[0] = determinant2x2(rhs, c2) / det;
    pcoords[1] = determinant2x2(c1, rhs) / det;
    weights[0] = 1 - (pcoords[0] + pcoords[1]);
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
    if (weights[0] >= 0 && weights[0] <= 1 && weights[1] >= 0 && weights[1] <= 1 && weights[2] >= 0 && weights[2] <= 1) {
      if (closestPoint) {
        outObj.dist2 = distance2BetweenPoints(cp, x);
        closestPoint[0] = cp[0];
        closestPoint[1] = cp[1];
        closestPoint[2] = cp[2];
      }
      outObj.evaluation = 1;
    } else {
      let t;
      if (closestPoint) {
        if (weights[1] < 0 && weights[2] < 0) {
          dist2Point = distance2BetweenPoints(x, pt3);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt3, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt3;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[2] < 0 && weights[0] < 0) {
          dist2Point = distance2BetweenPoints(x, pt1);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt1, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt1;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[1] < 0 && weights[0] < 0) {
          dist2Point = distance2BetweenPoints(x, pt2);
          dist2Line1 = vtkLine$1.distanceToLine(x, pt2, pt3, t, closestPoint1);
          dist2Line2 = vtkLine$1.distanceToLine(x, pt1, pt2, t, closestPoint2);
          if (dist2Point < dist2Line1) {
            outObj.dist2 = dist2Point;
            closest = pt2;
          } else {
            outObj.dist2 = dist2Line1;
            closest = closestPoint1;
          }
          if (dist2Line2 < outObj.dist2) {
            outObj.dist2 = dist2Line2;
            closest = closestPoint2;
          }
          for (i = 0; i < 3; i++) {
            closestPoint[i] = closest[i];
          }
        } else if (weights[0] < 0) {
          const lineDistance = vtkLine$1.distanceToLine(x, pt1, pt2, closestPoint);
          outObj.dist2 = lineDistance.distance;
        } else if (weights[1] < 0) {
          const lineDistance = vtkLine$1.distanceToLine(x, pt2, pt3, closestPoint);
          outObj.dist2 = lineDistance.distance;
        } else if (weights[2] < 0) {
          const lineDistance = vtkLine$1.distanceToLine(x, pt1, pt3, closestPoint);
          outObj.dist2 = lineDistance.distance;
        }
      }
      outObj.evaluation = 0;
    }
    return outObj;
  };
  publicAPI.evaluateLocation = (pcoords, x, weights) => {
    const p0 = [];
    const p1 = [];
    const p2 = [];
    model.points.getPoint(0, p0);
    model.points.getPoint(1, p1);
    model.points.getPoint(2, p2);
    const u3 = 1 - pcoords[0] - pcoords[1];
    for (let i = 0; i < 3; i++) {
      x[i] = p0[i] * u3 + p1[i] * pcoords[0] + p2[i] * pcoords[1];
    }
    weights[0] = u3;
    weights[1] = pcoords[0];
    weights[2] = pcoords[1];
  };
  publicAPI.getParametricDistance = (pcoords) => {
    let pDist;
    let pDistMax = 0;
    const pc = [];
    pc[0] = pcoords[0];
    pc[1] = pcoords[1];
    pc[2] = 1 - pcoords[0] - pcoords[1];
    for (let i = 0; i < 3; i++) {
      if (pc[i] < 0) {
        pDist = -pc[i];
      } else if (pc[i] > 1) {
        pDist = pc[i] - 1;
      } else {
        pDist = 0;
      }
      if (pDist > pDistMax) {
        pDistMax = pDist;
      }
    }
    return pDistMax;
  };
  publicAPI.derivatives = (subId, pcoords, values, dim, derivs) => {
    const x0 = model.points.getPoint(0);
    const x1 = model.points.getPoint(1);
    const x2 = model.points.getPoint(2);
    const n = [];
    const v10 = [];
    const v20 = [];
    const v = [];
    computeNormal(x0, x1, x2, n);
    subtract(x1, x0, v10);
    subtract(x2, x0, v);
    cross(n, v10, v20);
    const lenX = normalize(v10);
    if (lenX <= 0 || normalize(v20) <= 0) {
      for (let j = 0; j < dim; j++) {
        for (let i = 0; i < 3; i++) {
          derivs[j * dim + i] = 0;
        }
      }
      return;
    }
    const v0 = [0, 0];
    const v1 = [lenX, 0];
    const v2 = [dot(v, v10), dot(v, v20)];
    const functionDerivs = new Array(6);
    interpolationDerivs(functionDerivs);
    const J = [v1[0] - v0[0], v1[1] - v0[1], v2[0] - v0[0], v2[1] - v0[1]];
    const JI = macro.newTypedArray(TYPED_ARRAYS.Float64Array, 4);
    invertMatrix(J, JI, 2);
    for (let j = 0; j < dim; j++) {
      let sum0 = 0;
      let sum1 = 0;
      for (let i = 0; i < 3; i++) {
        sum0 += functionDerivs[i] * values[dim * i + j];
        sum1 += functionDerivs[3 + i] * values[dim * i + j];
      }
      const dBydx = sum0 * JI[0] + sum1 * JI[1];
      const dBydy = sum0 * JI[2] + sum1 * JI[3];
      derivs[3 * j] = dBydx * v10[0] + dBydy * v20[0];
      derivs[3 * j + 1] = dBydx * v10[1] + dBydy * v20[1];
      derivs[3 * j + 2] = dBydx * v10[2] + dBydy * v20[2];
    }
  };
  publicAPI.cellBoundary = (subId, pcoords, pts) => {
    const t13 = pcoords[0] - pcoords[1];
    const t22 = 0.5 * (1 - pcoords[0]) - pcoords[1];
    const t32 = 2 * pcoords[0] + pcoords[1] - 1;
    if (t13 >= 0 && t22 >= 0) {
      pts[0] = model.pointsIds[0];
      pts[1] = model.pointsIds[1];
    } else if (t22 < 0 && t32 >= 0) {
      pts[0] = model.pointsIds[1];
      pts[1] = model.pointsIds[2];
    } else {
      pts[0] = model.pointsIds[2];
      pts[1] = model.pointsIds[0];
    }
    if (pcoords[0] < 0 || pcoords[1] < 0 || pcoords[0] > 1 || pcoords[1] > 1 || 1 - pcoords[0] - pcoords[1] < 0) {
      return false;
    }
    return true;
  };
}
var DEFAULT_VALUES35 = {};
function extend38(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES35, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  vtkTriangle(publicAPI, model);
}
var newInstance37 = macro.newInstance(extend38, "vtkTriangle");
var vtkTriangle$1 = {
  newInstance: newInstance37,
  extend: extend38,
  ...STATIC8
};

// node_modules/@kitware/vtk.js/Common/DataModel/Quad.js
function intersectionStruct() {
  return {
    intersected: false,
    subId: -1,
    x: [0, 0, 0],
    pCoords: [0, 0, 0],
    t: -1
  };
}
function vtkQuad(publicAPI, model) {
  model.classHierarchy.push("vtkQuad");
  publicAPI.getCellDimension = () => 2;
  publicAPI.getCellType = () => CellType.VTK_QUAD;
  publicAPI.getNumberOfEdges = () => 4;
  publicAPI.getNumberOfFaces = () => 0;
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    let outObj = {
      subId: 0,
      t: Number.MAX_VALUE,
      intersect: 0,
      betweenPoints: false
    };
    let diagonalCase;
    const point0 = model.points.getPoint(0, []);
    const point1 = model.points.getPoint(1, []);
    const point2 = model.points.getPoint(2, []);
    const point3 = model.points.getPoint(3, []);
    const d1 = distance2BetweenPoints(point0, point2);
    const d2 = distance2BetweenPoints(point1, point3);
    if (d1 === d2) {
      let id;
      let maxId = 0;
      let maxIdx = 0;
      for (let i = 0; i < 4; i++) {
        id = model.pointsIds[i];
        if (id > maxId) {
          maxId = id;
          maxIdx = i;
        }
      }
      if (maxIdx === 0 || maxIdx === 2) {
        diagonalCase = 0;
      } else {
        diagonalCase = 1;
      }
    } else if (d1 < d2) {
      diagonalCase = 0;
    } else {
      diagonalCase = 1;
    }
    let points = null;
    if (!model.triangle) {
      model.triangle = vtkTriangle$1.newInstance();
      points = vtkPoints$1.newInstance();
      points.setNumberOfPoints(3);
      model.triangle.initialize(points);
    } else {
      points = model.triangle.getPoints();
    }
    let firstIntersect;
    const firstIntersectTmpObj = intersectionStruct();
    let secondIntersect;
    const secondIntersectTmpObj = intersectionStruct();
    let useFirstIntersection;
    let useSecondIntersection;
    switch (diagonalCase) {
      case 0:
        points.setPoint(0, ...point0);
        points.setPoint(1, ...point1);
        points.setPoint(2, ...point2);
        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);
        points.setPoint(0, ...point2);
        points.setPoint(1, ...point3);
        points.setPoint(2, ...point0);
        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);
        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;
        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;
        if (useFirstIntersection) {
          outObj = firstIntersect;
          x[0] = firstIntersectTmpObj.x[0];
          x[1] = firstIntersectTmpObj.x[1];
          x[2] = firstIntersectTmpObj.x[2];
          pcoords[0] = firstIntersectTmpObj.pCoords[0] + firstIntersectTmpObj.pCoords[1];
          pcoords[1] = firstIntersectTmpObj.pCoords[1];
          pcoords[2] = firstIntersectTmpObj.pCoords[2];
        } else if (useSecondIntersection) {
          outObj = secondIntersect;
          x[0] = secondIntersectTmpObj.x[0];
          x[1] = secondIntersectTmpObj.x[1];
          x[2] = secondIntersectTmpObj.x[2];
          pcoords[0] = 1 - (secondIntersectTmpObj.pCoords[0] + secondIntersectTmpObj.pCoords[1]);
          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];
          pcoords[2] = secondIntersectTmpObj.pCoords[2];
        }
        break;
      case 1:
        points.setPoint(0, ...point0);
        points.setPoint(1, ...point1);
        points.setPoint(2, ...point3);
        firstIntersect = model.triangle.intersectWithLine(p1, p2, tol, firstIntersectTmpObj.x, firstIntersectTmpObj.pCoords);
        points.setPoint(0, ...point2);
        points.setPoint(1, ...point3);
        points.setPoint(2, ...point1);
        secondIntersect = model.triangle.intersectWithLine(p1, p2, tol, secondIntersectTmpObj.x, secondIntersectTmpObj.pCoords);
        useFirstIntersection = firstIntersect.intersect && secondIntersect.intersect ? firstIntersect.t <= secondIntersect.t : firstIntersect.intersect;
        useSecondIntersection = firstIntersect.intersect && secondIntersect.intersect ? secondIntersect.t < firstIntersect.t : secondIntersect.intersect;
        if (useFirstIntersection) {
          outObj = firstIntersect;
          x[0] = firstIntersectTmpObj.x[0];
          x[1] = firstIntersectTmpObj.x[1];
          x[2] = firstIntersectTmpObj.x[2];
          pcoords[0] = firstIntersectTmpObj.pCoords[0];
          pcoords[1] = firstIntersectTmpObj.pCoords[1];
          pcoords[2] = firstIntersectTmpObj.pCoords[2];
        } else if (useSecondIntersection) {
          outObj = secondIntersect;
          x[0] = secondIntersectTmpObj.x[0];
          x[1] = secondIntersectTmpObj.x[1];
          x[2] = secondIntersectTmpObj.x[2];
          pcoords[0] = 1 - secondIntersectTmpObj.pCoords[0];
          pcoords[1] = 1 - secondIntersectTmpObj.pCoords[1];
          pcoords[2] = secondIntersectTmpObj.pCoords[2];
        }
        break;
    }
    return outObj;
  };
  publicAPI.interpolationFunctions = (pcoords, weights) => {
    const rm = 1 - pcoords[0];
    const sm = 1 - pcoords[1];
    weights[0] = rm * sm;
    weights[1] = pcoords[0] * sm;
    weights[2] = pcoords[0] * pcoords[1];
    weights[3] = rm * pcoords[1];
  };
  publicAPI.evaluateLocation = (pcoords, x, weights) => {
    const point2 = [];
    publicAPI.interpolationFunctions(pcoords, weights);
    x[0] = 0;
    x[1] = 0;
    x[2] = 0;
    for (let i = 0; i < 4; i++) {
      model.points.getPoint(i, point2);
      for (let j = 0; j < 3; j++) {
        x[j] += point2[j] * weights[i];
      }
    }
  };
}
var DEFAULT_VALUES36 = {};
function extend39(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES36, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  vtkQuad(publicAPI, model);
}
var newInstance38 = macro.newInstance(extend39, "vtkQuad");
var vtkQuad$1 = {
  newInstance: newInstance38,
  extend: extend39
};

// node_modules/@kitware/vtk.js/Common/DataModel/TriangleStrip.js
var {
  vtkErrorMacro: vtkErrorMacro9
} = macro;
function notImplemented4(method) {
  return () => vtkErrorMacro9(`vtkTriangleStrip.${method} - NOT IMPLEMENTED`);
}
function decomposeStrip(pts, polys) {
  if (!Array.isArray(pts) || pts.length < 3) {
    vtkErrorMacro9("decomposeStrip - Invalid points array");
    return;
  }
  let p1 = pts[0];
  let p2 = pts[1];
  for (let i = 0; i < pts.length - 2; i++) {
    const p3 = pts[i + 2];
    if (i % 2) {
      polys.insertNextCell([p2, p1, p3]);
    } else {
      polys.insertNextCell([p1, p2, p3]);
    }
    p1 = p2;
    p2 = p3;
  }
}
var STATIC9 = {
  decomposeStrip
};
function vtkTriangleStrip(publicAPI, model) {
  model.classHierarchy.push("vtkTriangleStrip");
  const superInitialize = publicAPI.initialize;
  publicAPI.initialize = (points, pointsIds) => {
    model.triangle.initialize(points, pointsIds);
    superInitialize(points, pointsIds);
  };
  publicAPI.getCellType = () => CellType.VTK_TRIANGLE_STRIP;
  publicAPI.getCellDimension = () => 2;
  publicAPI.getNumberOfEdges = () => model.pointsIds.length;
  publicAPI.getNumberOfFaces = () => 0;
  publicAPI.evaluatePosition = (x, closestPoint, pcoords, dist22, weights) => {
    const pc = [0, 0, 0];
    let minDist2 = Number.MAX_VALUE;
    let returnStatus = 0;
    const tempWeights = [];
    const activeWeights = [];
    const closest = [];
    pcoords[2] = 0;
    activeWeights[0] = 0;
    activeWeights[1] = 0;
    activeWeights[2] = 0;
    const points = model.triangle.getPoints();
    points.setNumberOfPoints(3);
    const pointsIds = model.triangle.getPointsIds();
    const numPoints = pointsIds.length;
    for (let i = 0; i < numPoints; i++) {
      weights[i] = 0;
    }
    for (let i = 0; i < numPoints - 2; i++) {
      const pt0 = [];
      points.getPoint(i, pt0);
      const pt1 = [];
      points.getPoint(i + 1, pt1);
      const pt2 = [];
      points.getPoint(i + 2, pt2);
      points.setData(Float32Array.from([...pt0, ...pt1, ...pt2]), 3);
      const status = model.triangle.evaluatePosition(x, closest, pc, tempWeights);
      const currentDist2 = status.dist2;
      if (status.evaluation >= 0 && (currentDist2 < minDist2 || currentDist2 === minDist2 && returnStatus === 0)) {
        returnStatus = status;
        if (closestPoint) {
          closestPoint[0] = closest[0];
          closestPoint[1] = closest[1];
          closestPoint[2] = closest[2];
        }
        pcoords[0] = pc[0];
        pcoords[1] = pc[1];
        minDist2 = currentDist2;
        activeWeights[0] = tempWeights[0];
        activeWeights[1] = tempWeights[1];
        activeWeights[2] = tempWeights[2];
      }
    }
    dist22[0] = minDist2;
    weights[0] = activeWeights[0];
    weights[1] = activeWeights[1];
    weights[2] = activeWeights[2];
    return returnStatus;
  };
  publicAPI.evaluateLocation = (subId, pcoords, x, weights) => {
    const idx = [[0, 1, 2], [1, 0, 2]];
    const order = subId % 2;
    const numPoints = model.pointsIds.length;
    for (let i = 0; i < numPoints; i++) {
      weights[i] = 0;
    }
    const u3 = 1 - pcoords[0] - pcoords[1];
    weights[subId] = u3;
    weights[subId + 1] = pcoords[0];
    weights[subId + 2] = pcoords[1];
    const pt1 = [];
    model.points.getPoint(subId + idx[order][0], pt1);
    const pt2 = [];
    model.points.getPoint(subId + idx[order][1], pt2);
    const pt3 = [];
    model.points.getPoint(subId + idx[order][2], pt3);
    for (let i = 0; i < 3; i++) {
      x[i] = pt1[i] * weights[subId] + pt2[i] * weights[subId + 1] + pt3[i] * weights[subId + 2];
    }
  };
  publicAPI.cellBoundary = (subId, pcoords, pts) => {
    const idx = [[0, 1, 2], [1, 0, 2]];
    const order = subId % 2;
    const pointsIds = model.triangle.getPointsIds();
    pointsIds[0] = model.pointsIds[idx[order][0]];
    pointsIds[1] = model.pointsIds[idx[order][1]];
    pointsIds[2] = model.pointsIds[idx[order][2]];
    return model.triangle.cellBoundary(0, pcoords, pts);
  };
  publicAPI.getEdge = (edgeId) => {
    let id1;
    let id2;
    const numPoints = model.pointsIds.length;
    if (edgeId === 0) {
      id1 = 0;
      id2 = 1;
    } else if (edgeId === numPoints - 1) {
      id1 = edgeId - 1;
      id2 = edgeId;
    } else {
      id1 = edgeId - 1;
      id2 = edgeId + 1;
    }
    model.line.getPointsIds()[0] = model.pointsIds[id1];
    model.line.getPointsIds()[1] = model.pointsIds[id2];
    model.line.getPoints().setPoint(0, model.points.getPoint(id1));
    model.line.getPoints().setPoint(1, model.points.getPoint(id2));
    return model.line;
  };
  publicAPI.intersectWithLine = (p1, p2, tol, x, pcoords) => {
    const numTris = model.pointsIds.length - 2;
    const points = model.triangle.getPoints();
    points.setNumberOfPoints(3);
    for (let i = 0; i < numTris; i++) {
      const pt0 = [];
      model.points.getPoint(model.pointsIds[i], pt0);
      const pt1 = [];
      model.points.getPoint(model.pointsIds[i + 1], pt1);
      const pt2 = [];
      model.points.getPoint(model.pointsIds[i + 2], pt2);
      points.setData(Float32Array.from([...pt0, ...pt1, ...pt2]), 3);
      const ret = model.triangle.intersectWithLine(p1, p2, tol, x, pcoords);
      if (ret.intersect) {
        return ret;
      }
    }
    return false;
  };
  publicAPI.triangulate = () => {
    const numTris = model.points.getNumberOfPoints() - 2;
    model.tris = new Array(3 * numTris);
    const idx = [[0, 1, 2], [1, 0, 2]];
    for (let subId = 0; subId < numTris; subId++) {
      const order = subId % 2;
      for (let i = 0; i < 3; i++) {
        model.tris[subId * 3 + i] = subId + idx[order][i];
      }
    }
    return true;
  };
  publicAPI.getPointArray = () => model.tris;
  publicAPI.derivatives = (subId, pcoords, values, dim, derivs) => {
    const pt0 = [];
    model.points.getPoint(subId, pt0);
    const pt1 = [];
    model.points.getPoint(subId + 1, pt1);
    const pt2 = [];
    model.points.getPoint(subId + 2, pt2);
    const points = model.triangle.getPoints();
    points.setPoint(0, ...pt0);
    points.setPoint(1, ...pt1);
    points.setPoint(2, ...pt2);
    model.triangle.derivatives(0, pcoords, values, dim, derivs);
  };
  publicAPI.getParametricCenter = (pcoords) => {
    pcoords[0] = 0.333333;
    pcoords[1] = 0.333333;
    pcoords[2] = 0;
    return Math.floor((model.pointsIds.length - 2) / 2);
  };
  publicAPI.contour = (value, cellScalars, locator, verts, lines, polys, inPd, outPd, inCd, cellId, outCd) => notImplemented4("contour")();
  publicAPI.clip = (value, cellScalars, locator, tris, inPd, outPd, inCd, cellId, outCd, insideOut) => notImplemented4("clip")();
}
var DEFAULT_VALUES37 = {
  line: null,
  triangle: null,
  tris: null
};
function extend40(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES37, initialValues);
  vtkCell$1.extend(publicAPI, model, initialValues);
  if (!model.line) {
    model.line = vtkLine$1.newInstance();
  }
  if (!model.triangle) {
    model.triangle = vtkTriangle$1.newInstance();
  }
  vtkTriangleStrip(publicAPI, model);
}
var newInstance39 = macro.newInstance(extend40, "vtkTriangleStrip");
var vtkTriangleStrip$1 = {
  newInstance: newInstance39,
  extend: extend40,
  ...STATIC9
};

// node_modules/@kitware/vtk.js/Common/DataModel/PolyData/Constants.js
var POLYDATA_FIELDS = ["verts", "lines", "polys", "strips"];

// node_modules/@kitware/vtk.js/Common/DataModel/PolyData.js
var {
  vtkWarningMacro: vtkWarningMacro4
} = macro;
var CELL_FACTORY = {
  [CellType.VTK_LINE]: vtkLine$1,
  [CellType.VTK_QUAD]: vtkQuad$1,
  [CellType.VTK_POLY_LINE]: vtkLine$1,
  [CellType.VTK_TRIANGLE]: vtkTriangle$1,
  [CellType.VTK_TRIANGLE_STRIP]: vtkTriangleStrip$1,
  [CellType.VTK_POLY_LINE]: vtkPolyLine$1,
  [CellType.VTK_POLYGON]: vtkPolygon$1
};
function vtkPolyData(publicAPI, model) {
  model.classHierarchy.push("vtkPolyData");
  function camelize(str6) {
    return str6.replace(/(?:^\w|[A-Z]|\b\w)/g, (letter) => letter.toUpperCase()).replace(/\s+/g, "");
  }
  function clearCells() {
    model.cells = void 0;
    model.links = void 0;
  }
  POLYDATA_FIELDS.forEach((type) => {
    publicAPI[`getNumberOf${camelize(type)}`] = () => model[type].getNumberOfCells();
    if (!model[type]) {
      model[type] = vtkCellArray$1.newInstance();
    } else {
      model[type] = vtk(model[type]);
    }
    model[`_on${camelize(type)}Changed`] = clearCells;
  });
  publicAPI.getNumberOfCells = () => POLYDATA_FIELDS.reduce((num, cellType) => num + model[cellType].getNumberOfCells(), 0);
  const superShallowCopy = publicAPI.shallowCopy;
  publicAPI.shallowCopy = function(other) {
    let debug = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    superShallowCopy(other, debug);
    POLYDATA_FIELDS.forEach((type) => {
      model[type] = vtkCellArray$1.newInstance();
      model[type].shallowCopy(other.getReferenceByName(type));
    });
  };
  const superGetMTime = publicAPI.getMTime;
  publicAPI.getMTime = () => POLYDATA_FIELDS.reduce((mTime, type) => {
    var _a;
    return Math.max(mTime, ((_a = model[type]) == null ? void 0 : _a.getMTime()) ?? mTime);
  }, superGetMTime());
  const superInitialize = publicAPI.initialize;
  publicAPI.initialize = () => {
    POLYDATA_FIELDS.forEach((type) => {
      var _a;
      return (_a = model[type]) == null ? void 0 : _a.initialize();
    });
    clearCells();
    return superInitialize();
  };
  publicAPI.buildCells = () => {
    const nVerts = publicAPI.getNumberOfVerts();
    const nLines = publicAPI.getNumberOfLines();
    const nPolys = publicAPI.getNumberOfPolys();
    const nStrips = publicAPI.getNumberOfStrips();
    const nCells = nVerts + nLines + nPolys + nStrips;
    const types = new Uint8Array(nCells);
    let pTypes = types;
    const locs = new Uint32Array(nCells);
    let pLocs = locs;
    if (nVerts) {
      let nextCellPts = 0;
      model.verts.getCellSizes().forEach((numCellPts, index2) => {
        pLocs[index2] = nextCellPts;
        pTypes[index2] = numCellPts > 1 ? CellType.VTK_POLY_VERTEX : CellType.VTK_VERTEX;
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nVerts);
      pTypes = pTypes.subarray(nVerts);
    }
    if (nLines) {
      let nextCellPts = 0;
      model.lines.getCellSizes().forEach((numCellPts, index2) => {
        pLocs[index2] = nextCellPts;
        pTypes[index2] = numCellPts > 2 ? CellType.VTK_POLY_LINE : CellType.VTK_LINE;
        if (numCellPts === 1) {
          vtkWarningMacro4("Building VTK_LINE ", index2, " with only one point, but VTK_LINE needs at least two points. Check the input.");
        }
        nextCellPts += numCellPts + 1;
      });
      pLocs = pLocs.subarray(nLines);
      pTypes = pTypes.subarray(nLines);
    }
    if (nPolys) {
      let nextCellPts = 0;
      model.polys.getCellSizes().forEach((numCellPts, index2) => {
        pLocs[index2] = nextCellPts;
        switch (numCellPts) {
          case 3:
            pTypes[index2] = CellType.VTK_TRIANGLE;
            break;
          case 4:
            pTypes[index2] = CellType.VTK_QUAD;
            break;
          default:
            pTypes[index2] = CellType.VTK_POLYGON;
            break;
        }
        if (numCellPts < 3) {
          vtkWarningMacro4("Building VTK_TRIANGLE ", index2, " with less than three points, but VTK_TRIANGLE needs at least three points. Check the input.");
        }
        nextCellPts += numCellPts + 1;
      });
      pLocs += pLocs.subarray(nPolys);
      pTypes += pTypes.subarray(nPolys);
    }
    if (nStrips) {
      let nextCellPts = 0;
      pTypes.fill(CellType.VTK_TRIANGLE_STRIP, 0, nStrips);
      model.strips.getCellSizes().forEach((numCellPts, index2) => {
        pLocs[index2] = nextCellPts;
        nextCellPts += numCellPts + 1;
      });
    }
    model.cells = vtkCellTypes$1.newInstance();
    model.cells.setCellTypes(nCells, types, locs);
  };
  publicAPI.buildLinks = function() {
    let initialSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    if (model.cells == null) {
      publicAPI.buildCells();
    }
    model.links = vtkCellLinks$1.newInstance();
    if (initialSize > 0) {
      model.links.allocate(initialSize);
    } else {
      model.links.allocate(publicAPI.getPoints().getNumberOfPoints());
    }
    model.links.buildLinks(publicAPI);
  };
  publicAPI.getCellType = (cellId) => model.cells.getCellType(cellId);
  publicAPI.getCellPoints = (cellId) => {
    const cellType = publicAPI.getCellType(cellId);
    let cells = null;
    switch (cellType) {
      case CellType.VTK_VERTEX:
      case CellType.VTK_POLY_VERTEX:
        cells = model.verts;
        break;
      case CellType.VTK_LINE:
      case CellType.VTK_POLY_LINE:
        cells = model.lines;
        break;
      case CellType.VTK_TRIANGLE:
      case CellType.VTK_QUAD:
      case CellType.VTK_POLYGON:
        cells = model.polys;
        break;
      case CellType.VTK_TRIANGLE_STRIP:
        cells = model.strips;
        break;
      default:
        cells = null;
        return {
          type: 0,
          cellPointIds: null
        };
    }
    const loc = model.cells.getCellLocation(cellId);
    const cellPointIds = cells.getCell(loc);
    return {
      cellType,
      cellPointIds
    };
  };
  publicAPI.getPointCells = (ptId) => model.links.getCells(ptId);
  publicAPI.getCellEdgeNeighbors = (cellId, point1, point2) => {
    const link1 = model.links.getLink(point1);
    const link2 = model.links.getLink(point2);
    return link1.cells.filter((cell) => cell !== cellId && link2.cells.indexOf(cell) !== -1);
  };
  publicAPI.getCell = function(cellId) {
    let cellHint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const cellInfo = publicAPI.getCellPoints(cellId);
    const cell = cellHint || CELL_FACTORY[cellInfo.cellType].newInstance();
    cell.initialize(publicAPI.getPoints(), cellInfo.cellPointIds);
    return cell;
  };
  publicAPI.getMaxCellSize = () => POLYDATA_FIELDS.reduce((max4, type) => {
    var _a, _b;
    return Math.max(max4, ((_b = (_a = model[type]) == null ? void 0 : _a.getMaxCellSize) == null ? void 0 : _b.call(_a)) ?? 0);
  }, 0);
}
var DEFAULT_VALUES38 = {
  // verts: null,
  // lines: null,
  // polys: null,
  // strips: null,
  // cells: null,
  // links: null,
};
function extend41(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES38, initialValues);
  vtkPointSet$1.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ["cells", "links"]);
  macro.setGet(publicAPI, model, ["verts", "lines", "polys", "strips"]);
  vtkPolyData(publicAPI, model);
}
var newInstance40 = macro.newInstance(extend41, "vtkPolyData");
var vtkPolyData$1 = {
  newInstance: newInstance40,
  extend: extend41
};

// node_modules/@kitware/vtk.js/Rendering/Core/CubeAxesActor.js
var faceNormals = [[-1, 0, 0], [1, 0, 0], [0, -1, 0], [0, 1, 0], [0, 0, -1], [0, 0, 1]];
var faceEdges = [[8, 7, 11, 3], [9, 1, 10, 5], [4, 9, 0, 8], [2, 11, 6, 10], [0, 3, 2, 1], [4, 5, 6, 7]];
var edgePoints = [[0, 1], [1, 3], [2, 3], [0, 2], [4, 5], [5, 7], [6, 7], [4, 6], [0, 4], [1, 5], [3, 7], [2, 6]];
var edgeAxes = [0, 1, 0, 1, 0, 1, 0, 1, 2, 2, 2, 2];
var faceAxes = [[1, 2], [1, 2], [0, 2], [0, 2], [0, 1], [0, 1]];
var ptv3 = new Float64Array(3);
var pt2v3 = new Float64Array(3);
var tmpv3 = new Float64Array(3);
var tmp2v3 = new Float64Array(3);
var xDir = new Float64Array(3);
var yDir = new Float64Array(3);
var invmat = new Float64Array(16);
function applyTextStyle(ctx, style) {
  ctx.strokeStyle = style.strokeColor;
  ctx.lineWidth = style.strokeSize;
  ctx.fillStyle = style.fontColor;
  ctx.font = `${style.fontStyle} ${style.fontSize}px ${style.fontFamily}`;
}
function defaultGenerateTicks(dataBounds) {
  const ticks2 = [];
  const tickStrings = [];
  for (let i = 0; i < 3; i++) {
    const scale7 = linear2().domain([dataBounds[i * 2], dataBounds[i * 2 + 1]]);
    ticks2[i] = scale7.ticks(5);
    const format2 = scale7.tickFormat(5);
    tickStrings[i] = ticks2[i].map(format2);
  }
  return {
    ticks: ticks2,
    tickStrings
  };
}
function vtkCubeAxesActorHelper(publicAPI, model) {
  model.classHierarchy.push("vtkCubeAxesActorHelper");
  publicAPI.setRenderable = (renderable) => {
    if (model.renderable === renderable) {
      return;
    }
    model.renderable = renderable;
    model.tmActor.addTexture(model.renderable.getTmTexture());
    model.tmActor.setProperty(renderable.getProperty());
    model.tmActor.setParentProp(renderable);
    publicAPI.modified();
  };
  publicAPI.createPolyDataForOneLabel = (text, pos, cmat, imat, dir, offset, results) => {
    const value = model.renderable.get_tmAtlas().get(text);
    if (!value) {
      return;
    }
    const coords = model.renderable.getTextPolyData().getPoints().getData();
    const size = model.lastSize;
    ptv3[0] = coords[pos * 3];
    ptv3[1] = coords[pos * 3 + 1];
    ptv3[2] = coords[pos * 3 + 2];
    vec3_exports.transformMat4(tmpv3, ptv3, cmat);
    tmpv3[0] += 0.1;
    vec3_exports.transformMat4(pt2v3, tmpv3, imat);
    vec3_exports.subtract(xDir, pt2v3, ptv3);
    tmpv3[0] -= 0.1;
    tmpv3[1] += 0.1;
    vec3_exports.transformMat4(pt2v3, tmpv3, imat);
    vec3_exports.subtract(yDir, pt2v3, ptv3);
    for (let i = 0; i < 3; i++) {
      xDir[i] /= 0.5 * 0.1 * size[0];
      yDir[i] /= 0.5 * 0.1 * size[1];
    }
    let ptIdx = results.ptIdx;
    let cellIdx = results.cellIdx;
    ptv3[0] = coords[pos * 3];
    ptv3[1] = coords[pos * 3 + 1];
    ptv3[2] = coords[pos * 3 + 2];
    if (dir[0] < -0.5) {
      vec3_exports.scale(tmpv3, xDir, dir[0] * offset - value.width);
    } else if (dir[0] > 0.5) {
      vec3_exports.scale(tmpv3, xDir, dir[0] * offset);
    } else {
      vec3_exports.scale(tmpv3, xDir, dir[0] * offset - value.width / 2);
    }
    vec3_exports.add(ptv3, ptv3, tmpv3);
    vec3_exports.scale(tmpv3, yDir, dir[1] * offset - value.height / 2);
    vec3_exports.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[0];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];
    ptIdx++;
    vec3_exports.scale(tmpv3, xDir, value.width);
    vec3_exports.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[2];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];
    ptIdx++;
    vec3_exports.scale(tmpv3, yDir, value.height);
    vec3_exports.add(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[4];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];
    ptIdx++;
    vec3_exports.scale(tmpv3, xDir, value.width);
    vec3_exports.subtract(ptv3, ptv3, tmpv3);
    results.points[ptIdx * 3] = ptv3[0];
    results.points[ptIdx * 3 + 1] = ptv3[1];
    results.points[ptIdx * 3 + 2] = ptv3[2];
    results.tcoords[ptIdx * 2] = value.tcoords[6];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];
    ptIdx++;
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 3;
    results.polys[cellIdx * 4 + 3] = ptIdx - 2;
    cellIdx++;
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 2;
    results.polys[cellIdx * 4 + 3] = ptIdx - 1;
    results.ptIdx += 4;
    results.cellIdx += 2;
  };
  publicAPI.updateTexturePolyData = () => {
    const cmat = model.camera.getCompositeProjectionMatrix(model.lastAspectRatio, -1, 1);
    mat4_exports.transpose(cmat, cmat);
    const numLabels = model.renderable.getTextValues().length;
    const numPts = numLabels * 4;
    const numTris = numLabels * 2;
    const points = new Float64Array(numPts * 3);
    const polys = new Uint16Array(numTris * 4);
    const tcoords = new Float32Array(numPts * 2);
    mat4_exports.invert(invmat, cmat);
    const results = {
      ptIdx: 0,
      cellIdx: 0,
      polys,
      points,
      tcoords
    };
    let ptIdx = 0;
    let textIdx = 0;
    let axisIdx = 0;
    const coords = model.renderable.getTextPolyData().getPoints().getData();
    const textValues = model.renderable.getTextValues();
    while (ptIdx < coords.length / 3) {
      ptv3[0] = coords[ptIdx * 3];
      ptv3[1] = coords[ptIdx * 3 + 1];
      ptv3[2] = coords[ptIdx * 3 + 2];
      vec3_exports.transformMat4(tmpv3, ptv3, cmat);
      ptv3[0] = coords[ptIdx * 3 + 3];
      ptv3[1] = coords[ptIdx * 3 + 4];
      ptv3[2] = coords[ptIdx * 3 + 5];
      vec3_exports.transformMat4(tmp2v3, ptv3, cmat);
      vec3_exports.subtract(tmpv3, tmpv3, tmp2v3);
      const dir = [tmpv3[0], tmpv3[1]];
      normalize2D(dir);
      publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getAxisTitlePixelOffset(), results);
      ptIdx += 2;
      textIdx++;
      for (let t = 0; t < model.renderable.getTickCounts()[axisIdx]; t++) {
        publicAPI.createPolyDataForOneLabel(textValues[textIdx], ptIdx, cmat, invmat, dir, model.renderable.getTickLabelPixelOffset(), results);
        ptIdx++;
        textIdx++;
      }
      axisIdx++;
    }
    const tcoordDA = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcoords,
      name: "TextureCoordinates"
    });
    model.tmPolyData.getPointData().setTCoords(tcoordDA);
    model.tmPolyData.getPoints().setData(points, 3);
    model.tmPolyData.getPoints().modified();
    model.tmPolyData.getPolys().setData(polys, 1);
    model.tmPolyData.getPolys().modified();
    model.tmPolyData.modified();
  };
  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {
    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {
      model.lastSize[0] = size[0];
      model.lastSize[1] = size[1];
      model.lastAspectRatio = size[0] / size[1];
      model.forceUpdate = true;
    }
    model.camera = camera;
    publicAPI.updateTexturePolyData();
  };
}
var newCubeAxesActorHelper = macro.newInstance(function(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    renderable: null
  };
  Object.assign(model, {}, initialValues);
  macro.obj(publicAPI, model);
  model.tmPolyData = vtkPolyData$1.newInstance();
  model.tmMapper = vtkMapper$1.newInstance();
  model.tmMapper.setInputData(model.tmPolyData);
  model.tmActor = vtkActor$1.newInstance({
    parentProp: publicAPI
  });
  model.tmActor.setMapper(model.tmMapper);
  macro.setGet(publicAPI, model, ["renderable"]);
  macro.get(publicAPI, model, ["lastSize", "lastAspectRatio", "axisTextStyle", "tickTextStyle", "tmActor", "ticks"]);
  model.forceUpdate = false;
  model.lastRedrawTime = {};
  macro.obj(model.lastRedrawTime, {
    mtime: 0
  });
  model.lastRebuildTime = {};
  macro.obj(model.lastRebuildTime, {
    mtime: 0
  });
  model.lastSize = [-1, -1];
  model.lastTickBounds = [];
  vtkCubeAxesActorHelper(publicAPI, model);
}, "vtkCubeAxesActorHelper");
function vtkCubeAxesActor(publicAPI, model) {
  model.classHierarchy.push("vtkCubeAxesActor");
  publicAPI.setCamera = (cam) => {
    if (model.camera === cam) {
      return;
    }
    if (model.cameraModifiedSub) {
      model.cameraModifiedSub.unsubscribe();
      model.cameraModifiedSub = null;
    }
    model.camera = cam;
    if (cam) {
      model.cameraModifiedSub = cam.onModified(publicAPI.update);
    }
    publicAPI.update();
    publicAPI.modified();
  };
  publicAPI.computeFacesToDraw = () => {
    const cmat = model.camera.getViewMatrix();
    mat4_exports.transpose(cmat, cmat);
    let changed = false;
    const length4 = vtkBoundingBox.getDiagonalLength(model.dataBounds);
    const faceDot = Math.sin(model.faceVisibilityAngle * Math.PI / 180);
    for (let f = 0; f < 6; f++) {
      let drawit = false;
      const faceAxis = Math.floor(f / 2);
      const otherAxis1 = (faceAxis + 1) % 3;
      const otherAxis2 = (faceAxis + 2) % 3;
      if (model.dataBounds[otherAxis1 * 2] !== model.dataBounds[otherAxis1 * 2 + 1] && model.dataBounds[otherAxis2 * 2] !== model.dataBounds[otherAxis2 * 2 + 1]) {
        ptv3[faceAxis] = model.dataBounds[f] - 0.1 * length4 * faceNormals[f][faceAxis];
        ptv3[otherAxis1] = 0.5 * (model.dataBounds[otherAxis1 * 2] + model.dataBounds[otherAxis1 * 2 + 1]);
        ptv3[otherAxis2] = 0.5 * (model.dataBounds[otherAxis2 * 2] + model.dataBounds[otherAxis2 * 2 + 1]);
        vec3_exports.transformMat4(tmpv3, ptv3, cmat);
        ptv3[faceAxis] = model.dataBounds[f];
        vec3_exports.transformMat4(tmp2v3, ptv3, cmat);
        vec3_exports.subtract(tmpv3, tmp2v3, tmpv3);
        vec3_exports.normalize(tmpv3, tmpv3);
        drawit = tmpv3[2] > faceDot;
        if (!model.camera.getParallelProjection()) {
          vec3_exports.normalize(tmp2v3, tmp2v3);
          drawit = vec3_exports.dot(tmp2v3, tmpv3) > faceDot;
        }
      }
      if (drawit !== model.lastFacesToDraw[f]) {
        model.lastFacesToDraw[f] = drawit;
        changed = true;
      }
    }
    return changed;
  };
  publicAPI.updatePolyData = (facesToDraw, edgesToDraw, ticks2) => {
    let numPts = 0;
    let numLines = 0;
    numPts += 8;
    let numEdgesToDraw = 0;
    for (let e = 0; e < 12; e++) {
      if (edgesToDraw[e] > 0) {
        numEdgesToDraw++;
      }
    }
    numLines += numEdgesToDraw;
    if (model.gridLines) {
      for (let f = 0; f < 6; f++) {
        if (facesToDraw[f]) {
          numPts += ticks2[faceAxes[f][0]].length * 2 + ticks2[faceAxes[f][1]].length * 2;
          numLines += ticks2[faceAxes[f][0]].length + ticks2[faceAxes[f][1]].length;
        }
      }
    }
    const points = new Float64Array(numPts * 3);
    const lines = new Uint32Array(numLines * 3);
    let ptIdx = 0;
    let lineIdx = 0;
    for (let z = 0; z < 2; z++) {
      for (let y = 0; y < 2; y++) {
        for (let x = 0; x < 2; x++) {
          points[ptIdx * 3] = model.dataBounds[x];
          points[ptIdx * 3 + 1] = model.dataBounds[2 + y];
          points[ptIdx * 3 + 2] = model.dataBounds[4 + z];
          ptIdx++;
        }
      }
    }
    for (let e = 0; e < 12; e++) {
      if (edgesToDraw[e] > 0) {
        lines[lineIdx * 3] = 2;
        lines[lineIdx * 3 + 1] = edgePoints[e][0];
        lines[lineIdx * 3 + 2] = edgePoints[e][1];
        lineIdx++;
      }
    }
    if (model.gridLines) {
      for (let f = 0; f < 6; f++) {
        if (facesToDraw[f]) {
          const faceIdx = Math.floor(f / 2);
          let aticks = ticks2[faceAxes[f][0]];
          for (let t = 0; t < aticks.length; t++) {
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2];
            ptIdx++;
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][0]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][1]] = model.dataBounds[faceAxes[f][1] * 2 + 1];
            ptIdx++;
            lines[lineIdx * 3] = 2;
            lines[lineIdx * 3 + 1] = ptIdx - 2;
            lines[lineIdx * 3 + 2] = ptIdx - 1;
            lineIdx++;
          }
          aticks = ticks2[faceAxes[f][1]];
          for (let t = 0; t < aticks.length; t++) {
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2];
            ptIdx++;
            points[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            points[ptIdx * 3 + faceAxes[f][1]] = aticks[t];
            points[ptIdx * 3 + faceAxes[f][0]] = model.dataBounds[faceAxes[f][0] * 2 + 1];
            ptIdx++;
            lines[lineIdx * 3] = 2;
            lines[lineIdx * 3 + 1] = ptIdx - 2;
            lines[lineIdx * 3 + 2] = ptIdx - 1;
            lineIdx++;
          }
        }
      }
    }
    model.polyData.getPoints().setData(points, 3);
    model.polyData.getPoints().modified();
    model.polyData.getLines().setData(lines, 1);
    model.polyData.getLines().modified();
    model.polyData.modified();
  };
  publicAPI.updateTextData = (facesToDraw, edgesToDraw, ticks2, tickStrings) => {
    let textPointCount = 0;
    for (let e = 0; e < 12; e++) {
      if (edgesToDraw[e] === 1) {
        textPointCount += 2;
        textPointCount += ticks2[edgeAxes[e]].length;
      }
    }
    const points = model.polyData.getPoints().getData();
    const textPoints = new Float64Array(textPointCount * 3);
    let ptIdx = 0;
    let textIdx = 0;
    let axisCount = 0;
    for (let f = 0; f < 6; f++) {
      if (facesToDraw[f]) {
        for (let e = 0; e < 4; e++) {
          const edgeIdx = faceEdges[f][e];
          if (edgesToDraw[edgeIdx] === 1) {
            const edgeAxis = edgeAxes[edgeIdx];
            const ptIdx1 = edgePoints[edgeIdx][0] * 3;
            const ptIdx2 = edgePoints[edgeIdx][1] * 3;
            textPoints[ptIdx * 3] = 0.5 * (points[ptIdx1] + points[ptIdx2]);
            textPoints[ptIdx * 3 + 1] = 0.5 * (points[ptIdx1 + 1] + points[ptIdx2 + 1]);
            textPoints[ptIdx * 3 + 2] = 0.5 * (points[ptIdx1 + 2] + points[ptIdx2 + 2]);
            ptIdx++;
            const faceIdx = Math.floor(f / 2);
            textPoints[ptIdx * 3 + faceIdx] = model.dataBounds[f];
            textPoints[ptIdx * 3 + faceAxes[f][0]] = 0.5 * (model.dataBounds[faceAxes[f][0] * 2] + model.dataBounds[faceAxes[f][0] * 2 + 1]);
            textPoints[ptIdx * 3 + faceAxes[f][1]] = 0.5 * (model.dataBounds[faceAxes[f][1] * 2] + model.dataBounds[faceAxes[f][1] * 2 + 1]);
            ptIdx++;
            model.textValues[textIdx] = model.axisLabels[edgeAxis];
            textIdx++;
            const otherAxis1 = (edgeAxis + 1) % 3;
            const otherAxis2 = (edgeAxis + 2) % 3;
            const aticks = ticks2[edgeAxis];
            const atickStrings = tickStrings[edgeAxis];
            model.tickCounts[axisCount] = aticks.length;
            for (let t = 0; t < aticks.length; t++) {
              textPoints[ptIdx * 3 + edgeAxis] = aticks[t];
              textPoints[ptIdx * 3 + otherAxis1] = points[ptIdx1 + otherAxis1];
              textPoints[ptIdx * 3 + otherAxis2] = points[ptIdx1 + otherAxis2];
              ptIdx++;
              model.textValues[textIdx] = atickStrings[t];
              textIdx++;
            }
            axisCount++;
          }
        }
      }
    }
    model.textPolyData.getPoints().setData(textPoints, 3);
    model.textPolyData.modified();
  };
  publicAPI.update = () => {
    if (!model.camera) {
      return;
    }
    const facesChanged = publicAPI.computeFacesToDraw();
    const facesToDraw = model.lastFacesToDraw;
    let boundsChanged = false;
    for (let i = 0; i < 6; i++) {
      if (model.dataBounds[i] !== model.lastTickBounds[i]) {
        boundsChanged = true;
        model.lastTickBounds[i] = model.dataBounds[i];
      }
    }
    if (facesChanged || boundsChanged || model.forceUpdate) {
      const edgesToDraw = new Array(12).fill(0);
      for (let f = 0; f < 6; f++) {
        if (facesToDraw[f]) {
          for (let e = 0; e < 4; e++) {
            edgesToDraw[faceEdges[f][e]]++;
          }
        }
      }
      const t = model.generateTicks(model.dataBounds);
      publicAPI.updatePolyData(facesToDraw, edgesToDraw, t.ticks);
      publicAPI.updateTextData(facesToDraw, edgesToDraw, t.ticks, t.tickStrings);
      if (boundsChanged || model.forceUpdate) {
        publicAPI.updateTextureAtlas(t.tickStrings);
      }
    }
    model.forceUpdate = false;
  };
  publicAPI.updateTextureAtlas = (tickStrings) => {
    model.tmContext.textBaseline = "bottom";
    model.tmContext.textAlign = "left";
    model._tmAtlas.clear();
    let maxWidth = 0;
    let totalHeight = 1;
    for (let i = 0; i < 3; i++) {
      if (!model._tmAtlas.has(model.axisLabels[i])) {
        applyTextStyle(model.tmContext, model.axisTextStyle);
        const metrics = model.tmContext.measureText(model.axisLabels[i]);
        const entry = {
          height: metrics.actualBoundingBoxAscent + 2,
          startingHeight: totalHeight,
          width: metrics.width + 2,
          textStyle: model.axisTextStyle
        };
        model._tmAtlas.set(model.axisLabels[i], entry);
        totalHeight += entry.height;
        if (maxWidth < entry.width) {
          maxWidth = entry.width;
        }
      }
      applyTextStyle(model.tmContext, model.tickTextStyle);
      for (let t = 0; t < tickStrings[i].length; t++) {
        if (!model._tmAtlas.has(tickStrings[i][t])) {
          const metrics = model.tmContext.measureText(tickStrings[i][t]);
          const entry = {
            height: metrics.actualBoundingBoxAscent + 2,
            startingHeight: totalHeight,
            width: metrics.width + 2,
            textStyle: model.tickTextStyle
          };
          model._tmAtlas.set(tickStrings[i][t], entry);
          totalHeight += entry.height;
          if (maxWidth < entry.width) {
            maxWidth = entry.width;
          }
        }
      }
    }
    maxWidth = nearestPowerOfTwo(maxWidth);
    totalHeight = nearestPowerOfTwo(totalHeight);
    model._tmAtlas.forEach((value) => {
      value.tcoords = [0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0, (totalHeight - value.startingHeight) / totalHeight];
    });
    model.tmCanvas.width = maxWidth;
    model.tmCanvas.height = totalHeight;
    model.tmContext.textBaseline = "bottom";
    model.tmContext.textAlign = "left";
    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);
    model._tmAtlas.forEach((value, key) => {
      applyTextStyle(model.tmContext, value.textStyle);
      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);
    });
    model.tmTexture.setCanvas(model.tmCanvas);
    model.tmTexture.modified();
  };
  publicAPI.onModified(() => {
    model.forceUpdate = true;
    publicAPI.update();
  });
  publicAPI.setTickTextStyle = (tickStyle) => {
    model.tickTextStyle = {
      ...model.tickTextStyle,
      ...tickStyle
    };
    publicAPI.modified();
  };
  publicAPI.setAxisTextStyle = (axisStyle) => {
    model.axisTextStyle = {
      ...model.axisTextStyle,
      ...axisStyle
    };
    publicAPI.modified();
  };
  publicAPI.get_tmAtlas = () => model._tmAtlas;
  publicAPI.getBounds = () => {
    publicAPI.update();
    vtkBoundingBox.setBounds(model.bounds, model.gridActor.getBounds());
    vtkBoundingBox.scaleAboutCenter(model.bounds, model.boundsScaleFactor, model.boundsScaleFactor, model.boundsScaleFactor);
    return model.bounds;
  };
  const _setProp = macro.chain(publicAPI.setProperty, model.gridActor.setProperty);
  publicAPI.setProperty = (p) => _setProp(p)[0];
}
function defaultValues3(publicAPI, model, initialValues) {
  return {
    boundsScaleFactor: 1.3,
    camera: null,
    dataBounds: [...vtkBoundingBox.INIT_BOUNDS],
    faceVisibilityAngle: 8,
    gridLines: true,
    axisLabels: null,
    axisTitlePixelOffset: 35,
    tickLabelPixelOffset: 12,
    generateTicks: defaultGenerateTicks,
    ...initialValues,
    axisTextStyle: {
      fontColor: "white",
      fontStyle: "normal",
      fontSize: 18,
      fontFamily: "serif",
      ...initialValues == null ? void 0 : initialValues.axisTextStyle
    },
    tickTextStyle: {
      fontColor: "white",
      fontStyle: "normal",
      fontSize: 14,
      fontFamily: "serif",
      ...initialValues == null ? void 0 : initialValues.tickTextStyle
    }
  };
}
function extend42(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  vtkActor$1.extend(publicAPI, model, defaultValues3(publicAPI, model, initialValues));
  model.lastFacesToDraw = [false, false, false, false, false, false];
  model.axisLabels = ["X-Axis", "Y-Axis", "Z-Axis"];
  model.tickCounts = [];
  model.textValues = [];
  model.lastTickBounds = [];
  model.tmCanvas = document.createElement("canvas");
  model.tmContext = model.tmCanvas.getContext("2d");
  model._tmAtlas = /* @__PURE__ */ new Map();
  model.tmTexture = vtkTexture$1.newInstance({
    resizable: true
  });
  model.tmTexture.setInterpolate(false);
  publicAPI.getProperty().setDiffuse(0);
  publicAPI.getProperty().setAmbient(1);
  model.gridMapper = vtkMapper$1.newInstance();
  model.polyData = vtkPolyData$1.newInstance();
  model.gridMapper.setInputData(model.polyData);
  model.gridActor = vtkActor$1.newInstance();
  model.gridActor.setMapper(model.gridMapper);
  model.gridActor.setProperty(publicAPI.getProperty());
  model.gridActor.setParentProp(publicAPI);
  model.textPolyData = vtkPolyData$1.newInstance();
  macro.setGet(publicAPI, model, ["axisTitlePixelOffset", "boundsScaleFactor", "faceVisibilityAngle", "gridLines", "tickLabelPixelOffset", "generateTicks"]);
  macro.setGetArray(publicAPI, model, ["dataBounds"], 6);
  macro.setGetArray(publicAPI, model, ["axisLabels"], 3);
  macro.get(publicAPI, model, ["axisTextStyle", "tickTextStyle", "camera", "tmTexture", "textValues", "textPolyData", "tickCounts", "gridActor"]);
  vtkCubeAxesActor(publicAPI, model);
}
var newInstance41 = macro.newInstance(extend42, "vtkCubeAxesActor");
var vtkCubeAxesActor$1 = {
  newInstance: newInstance41,
  extend: extend42,
  newCubeAxesActorHelper,
  defaultGenerateTicks
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/CubeAxesActor.js
function vtkOpenGLCubeAxesActor(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCubeAxesActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      if (!model.CubeAxesActorHelper.getRenderable()) {
        model.CubeAxesActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());
      publicAPI.addMissingNode(model.renderable.getGridActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());
    }
  };
}
var DEFAULT_VALUES39 = {};
function extend43(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES39, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.CubeAxesActorHelper = vtkCubeAxesActor$1.newCubeAxesActorHelper();
  vtkOpenGLCubeAxesActor(publicAPI, model);
}
var newInstance42 = newInstance(extend43, "vtkOpenGLCubeAxesActor");
registerOverride("vtkCubeAxesActor", newInstance42);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject/Constants.js
var ObjectType = {
  ARRAY_BUFFER: 0,
  ELEMENT_ARRAY_BUFFER: 1,
  TEXTURE_BUFFER: 2
};
var Constants9 = {
  ObjectType
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/BufferObject.js
var {
  ObjectType: ObjectType2
} = Constants9;
var STATIC10 = {};
function vtkOpenGLBufferObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLBufferObject");
  function convertType(type) {
    switch (type) {
      case ObjectType2.ELEMENT_ARRAY_BUFFER:
        return model.context.ELEMENT_ARRAY_BUFFER;
      case ObjectType2.TEXTURE_BUFFER:
        if ("TEXTURE_BUFFER" in model.context) {
          return model.context.TEXTURE_BUFFER;
        }
      case ObjectType2.ARRAY_BUFFER:
      default:
        return model.context.ARRAY_BUFFER;
    }
  }
  let internalType = null;
  let internalHandle = null;
  let dirty = true;
  let error = "";
  publicAPI.getType = () => internalType;
  publicAPI.setType = (value) => {
    internalType = value;
  };
  publicAPI.getHandle = () => internalHandle;
  publicAPI.isReady = () => dirty === false;
  publicAPI.generateBuffer = (type) => {
    const objectTypeGL = convertType(type);
    if (internalHandle === null) {
      internalHandle = model.context.createBuffer();
      internalType = type;
    }
    return convertType(internalType) === objectTypeGL;
  };
  publicAPI.upload = (data, type) => {
    const alreadyGenerated = publicAPI.generateBuffer(type);
    if (!alreadyGenerated) {
      error = "Trying to upload array buffer to incompatible buffer.";
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    model.context.bufferData(convertType(internalType), data, model.context.STATIC_DRAW);
    model.allocatedGPUMemoryInBytes = data.length * data.BYTES_PER_ELEMENT;
    dirty = false;
    return true;
  };
  publicAPI.bind = () => {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), internalHandle);
    return true;
  };
  publicAPI.release = () => {
    if (!internalHandle) {
      return false;
    }
    model.context.bindBuffer(convertType(internalType), null);
    return true;
  };
  publicAPI.releaseGraphicsResources = () => {
    if (internalHandle !== null) {
      model.context.bindBuffer(convertType(internalType), null);
      model.context.deleteBuffer(internalHandle);
      internalHandle = null;
      model.allocatedGPUMemoryInBytes = 0;
    }
  };
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
  publicAPI.getError = () => error;
}
var DEFAULT_VALUES40 = {
  objectType: ObjectType2.ARRAY_BUFFER,
  // _openGLRenderWindow: null,
  context: null,
  allocatedGPUMemoryInBytes: 0
};
function extend44(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES40, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["_openGLRenderWindow", "allocatedGPUMemoryInBytes"]);
  macro.moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkOpenGLBufferObject(publicAPI, model);
}
var newInstance43 = macro.newInstance(extend44);
var vtkBufferObject = {
  newInstance: newInstance43,
  extend: extend44,
  ...STATIC10,
  ...Constants9
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject/helpers.js
function computeCoordShiftAndScale(points) {
  let diagSq = 0;
  let distSq = 0;
  for (let i = 0; i < 3; ++i) {
    const range2 = points.getRange(i);
    const delta = range2[1] - range2[0];
    diagSq += delta * delta;
    const distShift = 0.5 * (range2[1] + range2[0]);
    distSq += distShift * distShift;
  }
  const useShiftAndScale = diagSq > 0 && (Math.abs(distSq) / diagSq > 1e6 || // If data is far from the origin relative to its size
  Math.abs(Math.log10(diagSq)) > 3 || // If the size is huge when not far from the origin
  diagSq === 0 && distSq > 1e6);
  if (useShiftAndScale) {
    const coordShift = new Float64Array(3);
    const coordScale = new Float64Array(3);
    for (let i = 0; i < 3; ++i) {
      const range2 = points.getRange(i);
      const delta = range2[1] - range2[0];
      coordShift[i] = 0.5 * (range2[1] + range2[0]);
      coordScale[i] = delta > 0 ? 1 / delta : 1;
    }
    return {
      useShiftAndScale,
      coordShift,
      coordScale
    };
  }
  return {
    useShiftAndScale,
    coordShift: new Float32Array([0, 0, 0]),
    coordScale: new Float32Array([1, 1, 1])
  };
}

// node_modules/@kitware/vtk.js/Rendering/OpenGL/CellArrayBufferObject.js
var {
  vtkErrorMacro: vtkErrorMacro10
} = macro;
function computeInverseShiftAndScaleMatrix(coordShift, coordScale) {
  const inverseScale = new Float64Array(3);
  vec3_exports.inverse(inverseScale, coordScale);
  const matrix = new Float64Array(16);
  mat4_exports.fromRotationTranslationScale(matrix, quat_exports.create(), coordShift, inverseScale);
  return matrix;
}
function shouldApplyCoordShiftAndScale(coordShift, coordScale) {
  if (coordShift === null || coordScale === null) {
    return false;
  }
  return !(vec3_exports.exactEquals(coordShift, [0, 0, 0]) && vec3_exports.exactEquals(coordScale, [1, 1, 1]));
}
function vtkOpenGLCellArrayBufferObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLCellArrayBufferObject");
  publicAPI.setType(ObjectType.ARRAY_BUFFER);
  publicAPI.createVBO = function(cellArray, inRep, outRep, options) {
    let selectionMaps = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : null;
    if (!cellArray.getData() || !cellArray.getData().length) {
      model.elementCount = 0;
      return 0;
    }
    model.blockSize = 3;
    model.vertexOffset = 0;
    model.normalOffset = 0;
    model.tCoordOffset = 0;
    model.tCoordComponents = 0;
    model.colorComponents = 0;
    model.colorOffset = 0;
    model.customData = [];
    const pointData = options.points.getData();
    let normalData = null;
    let tcoordData = null;
    let colorData = null;
    const colorComponents = options.colors ? options.colors.getNumberOfComponents() : 0;
    const textureComponents = options.tcoords ? options.tcoords.getNumberOfComponents() : 0;
    if (options.normals) {
      model.normalOffset = 4 * model.blockSize;
      model.blockSize += 3;
      normalData = options.normals.getData();
    }
    if (options.customAttributes) {
      options.customAttributes.forEach((a) => {
        if (a) {
          model.customData.push({
            data: a.getData(),
            offset: 4 * model.blockSize,
            components: a.getNumberOfComponents(),
            name: a.getName()
          });
          model.blockSize += a.getNumberOfComponents();
        }
      });
    }
    if (options.tcoords) {
      model.tCoordOffset = 4 * model.blockSize;
      model.tCoordComponents = textureComponents;
      model.blockSize += textureComponents;
      tcoordData = options.tcoords.getData();
    }
    if (options.colors) {
      model.colorComponents = options.colors.getNumberOfComponents();
      model.colorOffset = 0;
      colorData = options.colors.getData();
      if (!model.colorBO) {
        model.colorBO = vtkBufferObject.newInstance();
      }
      model.colorBO.setOpenGLRenderWindow(model._openGLRenderWindow);
    } else {
      model.colorBO = null;
    }
    model.stride = 4 * model.blockSize;
    let pointIdx = 0;
    let normalIdx = 0;
    let tcoordIdx = 0;
    let colorIdx = 0;
    let custIdx = 0;
    let cellCount = 0;
    let addAPoint;
    const cellBuilders = {
      // easy, every input point becomes an output point
      anythingToPoints(numPoints, cellPts, offset, cellId) {
        for (let i = 0; i < numPoints; ++i) {
          addAPoint(cellPts[offset + i], cellId);
        }
      },
      linesToWireframe(numPoints, cellPts, offset, cellIdx) {
        for (let i = 0; i < numPoints - 1; ++i) {
          addAPoint(cellPts[offset + i], cellIdx);
          addAPoint(cellPts[offset + i + 1], cellIdx);
        }
      },
      polysToWireframe(numPoints, cellPts, offset, cellIdx) {
        if (numPoints > 2) {
          for (let i = 0; i < numPoints; ++i) {
            addAPoint(cellPts[offset + i], cellIdx);
            addAPoint(cellPts[offset + (i + 1) % numPoints], cellIdx);
          }
        }
      },
      stripsToWireframe(numPoints, cellPts, offset, cellIdx) {
        if (numPoints > 2) {
          for (let i = 0; i < numPoints - 1; ++i) {
            addAPoint(cellPts[offset + i], cellIdx);
            addAPoint(cellPts[offset + i + 1], cellIdx);
          }
          for (let i = 0; i < numPoints - 2; i++) {
            addAPoint(cellPts[offset + i], cellIdx);
            addAPoint(cellPts[offset + i + 2], cellIdx);
          }
        }
      },
      polysToSurface(npts, cellPts, offset, cellIdx) {
        for (let i = 0; i < npts - 2; i++) {
          addAPoint(cellPts[offset + 0], cellIdx);
          addAPoint(cellPts[offset + i + 1], cellIdx);
          addAPoint(cellPts[offset + i + 2], cellIdx);
        }
      },
      stripsToSurface(npts, cellPts, offset, cellIdx) {
        for (let i = 0; i < npts - 2; i++) {
          addAPoint(cellPts[offset + i], cellIdx);
          addAPoint(cellPts[offset + i + 1 + i % 2], cellIdx);
          addAPoint(cellPts[offset + i + 1 + (i + 1) % 2], cellIdx);
        }
      }
    };
    const cellCounters = {
      // easy, every input point becomes an output point
      anythingToPoints(numPoints, cellPts) {
        return numPoints;
      },
      linesToWireframe(numPoints, cellPts) {
        if (numPoints > 1) {
          return (numPoints - 1) * 2;
        }
        return 0;
      },
      polysToWireframe(numPoints, cellPts) {
        if (numPoints > 2) {
          return numPoints * 2;
        }
        return 0;
      },
      stripsToWireframe(numPoints, cellPts) {
        if (numPoints > 2) {
          return numPoints * 4 - 6;
        }
        return 0;
      },
      polysToSurface(npts, cellPts) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      },
      stripsToSurface(npts, cellPts, offset) {
        if (npts > 2) {
          return (npts - 2) * 3;
        }
        return 0;
      }
    };
    let func = null;
    let countFunc = null;
    if (outRep === Representation.POINTS || inRep === "verts") {
      func = cellBuilders.anythingToPoints;
      countFunc = cellCounters.anythingToPoints;
    } else if (outRep === Representation.WIREFRAME || inRep === "lines") {
      func = cellBuilders[`${inRep}ToWireframe`];
      countFunc = cellCounters[`${inRep}ToWireframe`];
    } else {
      func = cellBuilders[`${inRep}ToSurface`];
      countFunc = cellCounters[`${inRep}ToSurface`];
    }
    const array2 = cellArray.getData();
    const size = array2.length;
    let caboCount = 0;
    for (let index2 = 0; index2 < size; ) {
      caboCount += countFunc(array2[index2], array2);
      index2 += array2[index2] + 1;
    }
    let packedUCVBO = null;
    const packedVBO = new Float32Array(caboCount * model.blockSize);
    if (colorData) {
      packedUCVBO = new Uint8Array(caboCount * 4);
    }
    let vboidx = 0;
    let ucidx = 0;
    const {
      useShiftAndScale,
      coordShift,
      coordScale
    } = computeCoordShiftAndScale(options.points);
    if (useShiftAndScale) {
      publicAPI.setCoordShiftAndScale(coordShift, coordScale);
    } else if (model.coordShiftAndScaleEnabled === true) {
      publicAPI.setCoordShiftAndScale(null, null);
    }
    if (selectionMaps) {
      if (!selectionMaps.points && !selectionMaps.cells) {
        selectionMaps.points = new Int32Array(caboCount);
        selectionMaps.cells = new Int32Array(caboCount);
      } else {
        const newPoints = new Int32Array(caboCount + selectionMaps.points.length);
        newPoints.set(selectionMaps.points);
        selectionMaps.points = newPoints;
        const newCells = new Int32Array(caboCount + selectionMaps.cells.length);
        newCells.set(selectionMaps.cells);
        selectionMaps.cells = newCells;
      }
    }
    let pointCount = options.vertexOffset;
    addAPoint = function addAPointFunc(pointId, cellId) {
      if (selectionMaps) {
        selectionMaps.points[pointCount] = pointId;
        selectionMaps.cells[pointCount] = cellCount + options.cellOffset;
      }
      ++pointCount;
      pointIdx = pointId * 3;
      if (!model.coordShiftAndScaleEnabled) {
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
        packedVBO[vboidx++] = pointData[pointIdx++];
      } else {
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[0]) * model.coordScale[0];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[1]) * model.coordScale[1];
        packedVBO[vboidx++] = (pointData[pointIdx++] - model.coordShift[2]) * model.coordScale[2];
      }
      if (normalData !== null) {
        if (options.haveCellNormals) {
          normalIdx = (cellCount + options.cellOffset) * 3;
        } else {
          normalIdx = pointId * 3;
        }
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
        packedVBO[vboidx++] = normalData[normalIdx++];
      }
      model.customData.forEach((attr) => {
        custIdx = pointId * attr.components;
        for (let j = 0; j < attr.components; ++j) {
          packedVBO[vboidx++] = attr.data[custIdx++];
        }
      });
      if (tcoordData !== null) {
        if (options.useTCoordsPerCell) {
          tcoordIdx = cellId * textureComponents;
        } else {
          tcoordIdx = pointId * textureComponents;
        }
        for (let j = 0; j < textureComponents; ++j) {
          packedVBO[vboidx++] = tcoordData[tcoordIdx++];
        }
      }
      if (colorData !== null) {
        if (options.haveCellScalars) {
          colorIdx = (cellCount + options.cellOffset) * colorComponents;
        } else {
          colorIdx = pointId * colorComponents;
        }
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorData[colorIdx++];
        packedUCVBO[ucidx++] = colorComponents === 4 ? colorData[colorIdx++] : 255;
      }
    };
    for (let index2 = 0; index2 < size; index2 += array2[index2] + 1, cellCount++) {
      func(array2[index2], array2, index2 + 1, cellCount + options.cellOffset);
    }
    model.elementCount = caboCount;
    publicAPI.upload(packedVBO, ObjectType.ARRAY_BUFFER);
    if (model.colorBO) {
      model.colorBOStride = 4;
      model.colorBO.upload(packedUCVBO, ObjectType.ARRAY_BUFFER);
    }
    return cellCount;
  };
  publicAPI.setCoordShiftAndScale = (coordShift, coordScale) => {
    if (coordShift !== null && (coordShift.constructor !== Float64Array || coordShift.length !== 3)) {
      vtkErrorMacro10("Wrong type for coordShift, expected vec3 or null");
      return;
    }
    if (coordScale !== null && (coordScale.constructor !== Float64Array || coordScale.length !== 3)) {
      vtkErrorMacro10("Wrong type for coordScale, expected vec3 or null");
      return;
    }
    if (model.coordShift === null || coordShift === null || !vec3_exports.equals(coordShift, model.coordShift)) {
      model.coordShift = coordShift;
    }
    if (model.coordScale === null || coordScale === null || !vec3_exports.equals(coordScale, model.coordScale)) {
      model.coordScale = coordScale;
    }
    model.coordShiftAndScaleEnabled = shouldApplyCoordShiftAndScale(model.coordShift, model.coordScale);
    if (model.coordShiftAndScaleEnabled) {
      model.inverseShiftAndScaleMatrix = computeInverseShiftAndScaleMatrix(model.coordShift, model.coordScale);
    } else {
      model.inverseShiftAndScaleMatrix = null;
    }
  };
}
var DEFAULT_VALUES41 = {
  elementCount: 0,
  stride: 0,
  colorBOStride: 0,
  vertexOffset: 0,
  normalOffset: 0,
  tCoordOffset: 0,
  tCoordComponents: 0,
  colorOffset: 0,
  colorComponents: 0,
  tcoordBO: null,
  customData: [],
  coordShift: null,
  coordScale: null,
  coordShiftAndScaleEnabled: false,
  inverseShiftAndScaleMatrix: null
};
function extend45(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES41, initialValues);
  vtkBufferObject.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["colorBO", "elementCount", "stride", "colorBOStride", "vertexOffset", "normalOffset", "tCoordOffset", "tCoordComponents", "colorOffset", "colorComponents", "customData"]);
  macro.get(publicAPI, model, ["coordShift", "coordScale", "coordShiftAndScaleEnabled", "inverseShiftAndScaleMatrix"]);
  vtkOpenGLCellArrayBufferObject(publicAPI, model);
}
var newInstance44 = macro.newInstance(extend45);
var vtkCellArrayBufferObject = {
  newInstance: newInstance44,
  extend: extend45
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Shader.js
var {
  vtkErrorMacro: vtkErrorMacro11
} = macro;
function vtkShader(publicAPI, model) {
  model.classHierarchy.push("vtkShader");
  publicAPI.compile = () => {
    let stype = model.context.VERTEX_SHADER;
    if (!model.source || !model.source.length || model.shaderType === "Unknown") {
      return false;
    }
    if (model.handle !== 0) {
      model.context.deleteShader(model.handle);
      model.handle = 0;
    }
    switch (model.shaderType) {
      case "Fragment":
        stype = model.context.FRAGMENT_SHADER;
        break;
      case "Vertex":
      default:
        stype = model.context.VERTEX_SHADER;
        break;
    }
    model.handle = model.context.createShader(stype);
    model.context.shaderSource(model.handle, model.source);
    model.context.compileShader(model.handle);
    const isCompiled = model.context.getShaderParameter(model.handle, model.context.COMPILE_STATUS);
    if (!isCompiled) {
      const lastError = model.context.getShaderInfoLog(model.handle);
      vtkErrorMacro11(`Error compiling shader '${model.source}': ${lastError}`);
      model.context.deleteShader(model.handle);
      model.handle = 0;
      return false;
    }
    return true;
  };
  publicAPI.cleanup = () => {
    if (model.shaderType === "Unknown" || model.handle === 0) {
      return;
    }
    model.context.deleteShader(model.handle);
    model.handle = 0;
    model.dirty = true;
  };
}
var DEFAULT_VALUES42 = {
  shaderType: "Unknown",
  source: "",
  error: "",
  handle: 0,
  dirty: false,
  context: null
};
function extend46(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES42, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["shaderType", "source", "error", "handle", "context"]);
  vtkShader(publicAPI, model);
}
var newInstance45 = macro.newInstance(extend46, "vtkShader");
var vtkShader$1 = {
  newInstance: newInstance45,
  extend: extend46
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ShaderProgram.js
var {
  vtkErrorMacro: vtkErrorMacro12
} = macro;
function substitute(source, search, replace, all) {
  const replaceStr = typeof replace === "string" ? replace : replace.join("\n");
  const replaceSearch = all === false ? search : new RegExp(search, "g");
  const resultstr = source.replace(replaceSearch, replaceStr);
  return {
    // If the result is different than the input, we did perform a replacement
    replace: resultstr !== replaceStr,
    result: resultstr
  };
}
function vtkShaderProgram(publicAPI, model) {
  model.classHierarchy.push("vtkShaderProgram");
  publicAPI.compileShader = () => {
    if (!model.vertexShader.compile()) {
      vtkErrorMacro12(model.vertexShader.getSource().split("\n").map((line, index2) => `${index2}: ${line}`).join("\n"));
      vtkErrorMacro12(model.vertexShader.getError());
      return 0;
    }
    if (!model.fragmentShader.compile()) {
      vtkErrorMacro12(model.fragmentShader.getSource().split("\n").map((line, index2) => `${index2}: ${line}`).join("\n"));
      vtkErrorMacro12(model.fragmentShader.getError());
      return 0;
    }
    if (!publicAPI.attachShader(model.vertexShader)) {
      vtkErrorMacro12(model.error);
      return 0;
    }
    if (!publicAPI.attachShader(model.fragmentShader)) {
      vtkErrorMacro12(model.error);
      return 0;
    }
    if (!publicAPI.link()) {
      vtkErrorMacro12(`Links failed: ${model.error}`);
      return 0;
    }
    publicAPI.setCompiled(true);
    return 1;
  };
  publicAPI.cleanup = () => {
    if (model.shaderType === "Unknown" || model.handle === 0) {
      return;
    }
    publicAPI.release();
    if (model.vertexShaderHandle !== 0) {
      model.context.detachShader(model.handle, model.vertexShaderHandle);
      model.vertexShaderHandle = 0;
    }
    if (model.fragmentShaderHandle !== 0) {
      model.context.detachShader(model.handle, model.fragmentShaderHandle);
      model.fragmentShaderHandle = 0;
    }
    model.context.deleteProgram(model.handle);
    model.handle = 0;
    publicAPI.setCompiled(false);
  };
  publicAPI.bind = () => {
    if (!model.linked && !publicAPI.link()) {
      return false;
    }
    model.context.useProgram(model.handle);
    publicAPI.setBound(true);
    return true;
  };
  publicAPI.isBound = () => !!model.bound;
  publicAPI.release = () => {
    model.context.useProgram(null);
    publicAPI.setBound(false);
  };
  publicAPI.setContext = (ctx) => {
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.link = () => {
    if (model.linked) {
      return true;
    }
    if (model.handle === 0) {
      model.error = "Program has not been initialized, and/or does not have shaders.";
      return false;
    }
    model.uniformLocs = {};
    model.context.linkProgram(model.handle);
    const isCompiled = model.context.getProgramParameter(model.handle, model.context.LINK_STATUS);
    if (!isCompiled) {
      const lastError = model.context.getProgramInfoLog(model.handle);
      vtkErrorMacro12(`Error linking shader ${lastError}`);
      model.handle = 0;
      return false;
    }
    publicAPI.setLinked(true);
    model.attributeLocs = {};
    return true;
  };
  publicAPI.setUniformMatrix = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    const f32 = new Float32Array(v);
    model.context.uniformMatrix4fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformMatrix3x3 = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    const f32 = new Float32Array(v);
    model.context.uniformMatrix3fv(location, false, f32);
    return true;
  };
  publicAPI.setUniformf = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1f(location, v);
    return true;
  };
  publicAPI.setUniformfv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1fv(location, v);
    return true;
  };
  publicAPI.setUniformi = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1i(location, v);
    return true;
  };
  publicAPI.setUniformiv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform1iv(location, v);
    return true;
  };
  publicAPI.setUniform2f = (name, v1, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (v2 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform2f(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform2fv(location, v);
    return true;
  };
  publicAPI.setUniform2i = (name, v1, v2) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (v2 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform2i(location, v1, v2);
    return true;
  };
  publicAPI.setUniform2iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform2iv(location, v);
    return true;
  };
  publicAPI.setUniform3f = (name, a1, a2, a3) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (a3 === void 0) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3f(location, a1, a2, a3);
    return true;
  };
  publicAPI.setUniform3fArray = (name, a) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    if (!Array.isArray(a) || a.length !== 3) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3f(location, a[0], a[1], a[2]);
    return true;
  };
  publicAPI.setUniform3fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform3fv(location, v);
    return true;
  };
  publicAPI.setUniform3i = function(name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    let array2 = args;
    if (array2.length === 1 && Array.isArray(array2[0])) {
      array2 = array2[0];
    }
    if (array2.length !== 3) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform3i(location, array2[0], array2[1], array2[2]);
    return true;
  };
  publicAPI.setUniform3iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform3iv(location, v);
    return true;
  };
  publicAPI.setUniform4f = function(name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    let array2 = args;
    if (array2.length === 1 && Array.isArray(array2[0])) {
      array2 = array2[0];
    }
    if (array2.length !== 4) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform4f(location, array2[0], array2[1], array2[2], array2[3]);
    return true;
  };
  publicAPI.setUniform4fv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform4fv(location, v);
    return true;
  };
  publicAPI.setUniform4i = function(name) {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    let array2 = args;
    if (array2.length === 1 && Array.isArray(array2[0])) {
      array2 = array2[0];
    }
    if (array2.length !== 4) {
      throw new RangeError("Invalid number of values for array");
    }
    model.context.uniform4i(location, array2[0], array2[1], array2[2], array2[3]);
    return true;
  };
  publicAPI.setUniform4iv = (name, v) => {
    const location = publicAPI.findUniform(name);
    if (location === -1) {
      model.error = `Could not set uniform ${name} . No such uniform.`;
      return false;
    }
    model.context.uniform4iv(location, v);
    return true;
  };
  publicAPI.findUniform = (name) => {
    if (!name || !model.linked) {
      return -1;
    }
    let loc = model.uniformLocs[name];
    if (loc !== void 0) {
      return loc;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    if (loc === null) {
      model.error = `Uniform ${name} not found in current shader program.`;
      model.uniformLocs[name] = -1;
      return -1;
    }
    model.uniformLocs[name] = loc;
    return loc;
  };
  publicAPI.isUniformUsed = (name) => {
    if (!name) {
      return false;
    }
    let loc = model.uniformLocs[name];
    if (loc !== void 0) {
      return loc !== null;
    }
    if (!model.linked) {
      vtkErrorMacro12("attempt to find uniform when the shader program is not linked");
      return false;
    }
    loc = model.context.getUniformLocation(model.handle, name);
    model.uniformLocs[name] = loc;
    if (loc === null) {
      return false;
    }
    return true;
  };
  publicAPI.isAttributeUsed = (name) => {
    if (!name) {
      return false;
    }
    if (name in model.attributeLocs) {
      return true;
    }
    if (!model.linked) {
      vtkErrorMacro12("attempt to find uniform when the shader program is not linked");
      return false;
    }
    const loc = model.context.getAttribLocation(model.handle, name);
    if (loc === -1) {
      return false;
    }
    model.attributeLocs[name] = loc;
    return true;
  };
  publicAPI.attachShader = (shader) => {
    if (shader.getHandle() === 0) {
      model.error = "Shader object was not initialized, cannot attach it.";
      return false;
    }
    if (shader.getShaderType() === "Unknown") {
      model.error = "Shader object is of type Unknown and cannot be used.";
      return false;
    }
    if (model.handle === 0) {
      const thandle = model.context.createProgram();
      if (thandle === 0) {
        model.error = "Could not create shader program.";
        return false;
      }
      model.handle = thandle;
      model.linked = false;
    }
    if (shader.getShaderType() === "Vertex") {
      if (model.vertexShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.vertexShaderHandle);
      }
      model.vertexShaderHandle = shader.getHandle();
    }
    if (shader.getShaderType() === "Fragment") {
      if (model.fragmentShaderHandle !== 0) {
        model.context.detachShader(model.handle, model.fragmentShaderHandle);
      }
      model.fragmentShaderHandle = shader.getHandle();
    }
    model.context.attachShader(model.handle, shader.getHandle());
    publicAPI.setLinked(false);
    return true;
  };
  publicAPI.detachShader = (shader) => {
    if (shader.getHandle() === 0) {
      model.error = "shader object was not initialized, cannot attach it.";
      return false;
    }
    if (shader.getShaderType() === "Unknown") {
      model.error = "Shader object is of type Unknown and cannot be used.";
      return false;
    }
    if (model.handle === 0) {
      model.error = "This shader program has not been initialized yet.";
    }
    switch (shader.getShaderType()) {
      case "Vertex":
        if (model.vertexShaderHandle !== shader.getHandle()) {
          model.error = "The supplied shader was not attached to this program.";
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.vertexShaderHandle = 0;
        model.linked = false;
        return true;
      case "Fragment":
        if (model.fragmentShaderHandle !== shader.getHandle()) {
          model.error = "The supplied shader was not attached to this program.";
          return false;
        }
        model.context.detachShader(model.handle, shader.getHandle());
        model.fragmentShaderHandle = 0;
        model.linked = false;
        return true;
      default:
        return false;
    }
  };
  publicAPI.setContext = (ctx) => {
    model.context = ctx;
    model.vertexShader.setContext(ctx);
    model.fragmentShader.setContext(ctx);
    model.geometryShader.setContext(ctx);
  };
  publicAPI.setLastCameraMTime = (mtime) => {
    model.lastCameraMTime = mtime;
  };
}
var DEFAULT_VALUES43 = {
  vertexShaderHandle: 0,
  fragmentShaderHandle: 0,
  geometryShaderHandle: 0,
  vertexShader: null,
  fragmentShader: null,
  geometryShader: null,
  linked: false,
  bound: false,
  compiled: false,
  error: "",
  handle: 0,
  numberOfOutputs: 0,
  attributesLocs: null,
  uniformLocs: null,
  md5Hash: 0,
  context: null,
  lastCameraMTime: null
};
function extend47(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES43, initialValues);
  model.attributesLocs = {};
  model.uniformLocs = {};
  model.vertexShader = vtkShader$1.newInstance();
  model.vertexShader.setShaderType("Vertex");
  model.fragmentShader = vtkShader$1.newInstance();
  model.fragmentShader.setShaderType("Fragment");
  model.geometryShader = vtkShader$1.newInstance();
  model.geometryShader.setShaderType("Geometry");
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["lastCameraMTime"]);
  macro.setGet(publicAPI, model, ["error", "handle", "compiled", "bound", "md5Hash", "vertexShader", "fragmentShader", "geometryShader", "linked"]);
  vtkShaderProgram(publicAPI, model);
}
var newInstance46 = macro.newInstance(extend47, "vtkShaderProgram");
var vtkShaderProgram$1 = {
  newInstance: newInstance46,
  extend: extend47,
  substitute
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/VertexArrayObject.js
function vtkOpenGLVertexArrayObject(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLVertexArrayObject");
  publicAPI.exposedMethod = () => {
  };
  publicAPI.initialize = () => {
    model.instancingExtension = null;
    if (!model._openGLRenderWindow.getWebgl2()) {
      model.instancingExtension = model.context.getExtension("ANGLE_instanced_arrays");
    }
    if (!model.forceEmulation && model._openGLRenderWindow && model._openGLRenderWindow.getWebgl2()) {
      model.extension = null;
      model.supported = true;
      model.handleVAO = model.context.createVertexArray();
    } else {
      model.extension = model.context.getExtension("OES_vertex_array_object");
      if (!model.forceEmulation && model.extension) {
        model.supported = true;
        model.handleVAO = model.extension.createVertexArrayOES();
      } else {
        model.supported = false;
      }
    }
  };
  publicAPI.isReady = () => (
    // We either probed and allocated a VAO, or are falling back as the current
    // hardware does not support VAOs.
    model.handleVAO !== 0 || model.supported === false
  );
  publicAPI.bind = () => {
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(model.handleVAO);
      } else {
        model.context.bindVertexArray(model.handleVAO);
      }
    } else if (publicAPI.isReady()) {
      const gl = model.context;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (let i = 0; i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 1);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 1);
              }
            }
          }
        }
      }
    }
  };
  publicAPI.release = () => {
    if (publicAPI.isReady() && model.supported) {
      if (model.extension) {
        model.extension.bindVertexArrayOES(null);
      } else {
        model.context.bindVertexArray(null);
      }
    } else if (publicAPI.isReady()) {
      const gl = model.context;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        model.context.bindBuffer(gl.ARRAY_BUFFER, buff.buffer);
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          const matrixCount = attrIt.isMatrix ? attrIt.size : 1;
          for (let i = 0; i < matrixCount; ++i) {
            gl.enableVertexAttribArray(attrIt.index + i);
            gl.vertexAttribPointer(attrIt.index + i, attrIt.size, attrIt.type, attrIt.normalize, attrIt.stride, attrIt.offset + attrIt.stride * i / attrIt.size);
            if (attrIt.divisor > 0) {
              if (model.instancingExtension) {
                model.instancingExtension.vertexAttribDivisorANGLE(attrIt.index + i, 0);
              } else {
                gl.vertexAttribDivisor(attrIt.index + i, 0);
              }
            }
            gl.disableVertexAttribArray(attrIt.index + i);
          }
        }
      }
    }
  };
  publicAPI.shaderProgramChanged = () => {
    publicAPI.release();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.handleProgram = 0;
  };
  publicAPI.releaseGraphicsResources = () => {
    publicAPI.shaderProgramChanged();
    if (model.handleVAO) {
      if (model.extension) {
        model.extension.deleteVertexArrayOES(model.handleVAO);
      } else {
        model.context.deleteVertexArray(model.handleVAO);
      }
    }
    model.handleVAO = 0;
    model.supported = true;
    model.handleProgram = 0;
  };
  publicAPI.addAttributeArray = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6) => publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6, 0, false);
  publicAPI.addAttributeArrayWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6, divisor, isMatrix) => {
    if (!program) {
      return false;
    }
    if (!program.isBound() || buffer.getHandle() === 0 || buffer.getType() !== ObjectType.ARRAY_BUFFER) {
      return false;
    }
    if (model.handleProgram === 0) {
      model.handleProgram = program.getHandle();
    }
    if (!publicAPI.isReady()) {
      publicAPI.initialize();
    }
    if (!publicAPI.isReady() || model.handleProgram !== program.getHandle()) {
      return false;
    }
    const gl = model.context;
    const attribs = {};
    attribs.name = name;
    attribs.index = gl.getAttribLocation(model.handleProgram, name);
    attribs.offset = offset;
    attribs.stride = stride;
    attribs.type = elementType;
    attribs.size = elementTupleSize;
    attribs.normalize = normalize6;
    attribs.isMatrix = isMatrix;
    attribs.divisor = divisor;
    if (attribs.Index === -1) {
      return false;
    }
    buffer.bind();
    gl.enableVertexAttribArray(attribs.index);
    gl.vertexAttribPointer(attribs.index, attribs.size, attribs.type, attribs.normalize, attribs.stride, attribs.offset);
    if (divisor > 0) {
      if (model.instancingExtension) {
        model.instancingExtension.vertexAttribDivisorANGLE(attribs.index, 1);
      } else {
        gl.vertexAttribDivisor(attribs.index, 1);
      }
    }
    attribs.buffer = buffer.getHandle();
    if (!model.supported) {
      let buffFound = false;
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        if (buff.buffer === attribs.buffer) {
          buffFound = true;
          let found = false;
          for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
            const attrIt = buff.attributes[iatt];
            if (attrIt.name === name) {
              found = true;
              buff.attributes[iatt] = attribs;
            }
          }
          if (!found) {
            buff.attributes.push(attribs);
          }
        }
      }
      if (!buffFound) {
        model.buffers.push({
          buffer: attribs.buffer,
          attributes: [attribs]
        });
      }
    }
    return true;
  };
  publicAPI.addAttributeMatrixWithDivisor = (program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6, divisor) => {
    const result = publicAPI.addAttributeArrayWithDivisor(program, buffer, name, offset, stride, elementType, elementTupleSize, normalize6, divisor, true);
    if (!result) {
      return result;
    }
    const gl = model.context;
    const index2 = gl.getAttribLocation(model.handleProgram, name);
    for (let i = 1; i < elementTupleSize; i++) {
      gl.enableVertexAttribArray(index2 + i);
      gl.vertexAttribPointer(index2 + i, elementTupleSize, elementType, normalize6, stride, offset + stride * i / elementTupleSize);
      if (divisor > 0) {
        if (model.instancingExtension) {
          model.instancingExtension.vertexAttribDivisorANGLE(index2 + i, 1);
        } else {
          gl.vertexAttribDivisor(index2 + i, 1);
        }
      }
    }
    return true;
  };
  publicAPI.removeAttributeArray = (name) => {
    if (!publicAPI.isReady() || model.handleProgram === 0) {
      return false;
    }
    if (!model.supported) {
      for (let ibuff = 0; ibuff < model.buffers.length; ++ibuff) {
        const buff = model.buffers[ibuff];
        for (let iatt = 0; iatt < buff.attributes.length; ++iatt) {
          const attrIt = buff.attributes[iatt];
          if (attrIt.name === name) {
            buff.attributes.splice(iatt, 1);
            if (!buff.attributes.length) {
              model.buffers.splice(ibuff, 1);
            }
            return true;
          }
        }
      }
    }
    return true;
  };
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}
var DEFAULT_VALUES44 = {
  forceEmulation: false,
  handleVAO: 0,
  handleProgram: 0,
  supported: true,
  buffers: null,
  context: null
  // _openGLRenderWindow: null,
};
function extend48(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES44, initialValues);
  model.buffers = [];
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["supported"]);
  macro.setGet(publicAPI, model, ["forceEmulation"]);
  vtkOpenGLVertexArrayObject(publicAPI, model);
}
var newInstance47 = macro.newInstance(extend48, "vtkOpenGLVertexArrayObject");
var vtkVertexArrayObject = {
  newInstance: newInstance47,
  extend: extend48
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Helper.js
var primTypes = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Tris: 2,
  TriStrips: 3,
  TrisEdges: 4,
  TriStripsEdges: 5,
  End: 6
};
function vtkOpenGLHelper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLHelper");
  publicAPI.setOpenGLRenderWindow = (win) => {
    model.context = win.getContext();
    model.program.setContext(model.context);
    model.VAO.setOpenGLRenderWindow(win);
    model.CABO.setOpenGLRenderWindow(win);
  };
  publicAPI.releaseGraphicsResources = (oglwin) => {
    model.VAO.releaseGraphicsResources();
    model.CABO.releaseGraphicsResources();
    model.CABO.setElementCount(0);
  };
  publicAPI.drawArrays = (ren, actor, rep, oglMapper) => {
    if (model.CABO.getElementCount()) {
      const mode2 = publicAPI.getOpenGLMode(rep);
      const wideLines = publicAPI.haveWideLines(ren, actor);
      const gl = model.context;
      const depthMask = gl.getParameter(gl.DEPTH_WRITEMASK);
      if (model.pointPicking) {
        gl.depthMask(false);
      }
      const drawingLines = mode2 === gl.LINES;
      if (drawingLines && wideLines) {
        publicAPI.updateShaders(ren, actor, oglMapper);
        gl.drawArraysInstanced(mode2, 0, model.CABO.getElementCount(), 2 * Math.ceil(actor.getProperty().getLineWidth()));
      } else {
        gl.lineWidth(actor.getProperty().getLineWidth());
        publicAPI.updateShaders(ren, actor, oglMapper);
        gl.drawArrays(mode2, 0, model.CABO.getElementCount());
        gl.lineWidth(1);
      }
      const stride = (mode2 === gl.POINTS ? 1 : 0) || (mode2 === gl.LINES ? 2 : 3);
      if (model.pointPicking) {
        gl.depthMask(depthMask);
      }
      return model.CABO.getElementCount() / stride;
    }
    return 0;
  };
  publicAPI.getOpenGLMode = (rep) => {
    if (model.pointPicking) {
      return model.context.POINTS;
    }
    const type = model.primitiveType;
    if (rep === Representation.POINTS || type === primTypes.Points) {
      return model.context.POINTS;
    }
    if (rep === Representation.WIREFRAME || type === primTypes.Lines || type === primTypes.TrisEdges || type === primTypes.TriStripsEdges) {
      return model.context.LINES;
    }
    return model.context.TRIANGLES;
  };
  publicAPI.haveWideLines = (ren, actor) => {
    if (actor.getProperty().getLineWidth() > 1) {
      if (model.CABO.getOpenGLRenderWindow()) {
        if (model.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth() >= actor.getProperty().getLineWidth()) {
          return false;
        }
      }
      return true;
    }
    return false;
  };
  publicAPI.getNeedToRebuildShaders = (ren, actor, oglMapper) => {
    if (oglMapper.getNeedToRebuildShaders(publicAPI, ren, actor) || publicAPI.getProgram() === 0 || publicAPI.getShaderSourceTime().getMTime() < oglMapper.getMTime() || publicAPI.getShaderSourceTime().getMTime() < actor.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.updateShaders = (ren, actor, oglMapper) => {
    if (publicAPI.getNeedToRebuildShaders(ren, actor, oglMapper)) {
      const shaders = {
        Vertex: null,
        Fragment: null,
        Geometry: null
      };
      oglMapper.buildShaders(shaders, ren, actor);
      const newShader = model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(shaders.Vertex, shaders.Fragment, shaders.Geometry);
      if (newShader !== publicAPI.getProgram()) {
        publicAPI.setProgram(newShader);
        publicAPI.getVAO().releaseGraphicsResources();
      }
      publicAPI.getShaderSourceTime().modified();
    } else {
      model.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(publicAPI.getProgram());
    }
    publicAPI.getVAO().bind();
    oglMapper.setMapperShaderParameters(publicAPI, ren, actor);
    oglMapper.setPropertyShaderParameters(publicAPI, ren, actor);
    oglMapper.setCameraShaderParameters(publicAPI, ren, actor);
    oglMapper.setLightingShaderParameters(publicAPI, ren, actor);
    oglMapper.invokeShaderCallbacks(publicAPI, ren, actor);
  };
  publicAPI.setMapperShaderParameters = (ren, actor, size) => {
    if (publicAPI.haveWideLines(ren, actor)) {
      publicAPI.getProgram().setUniform2f("viewportSize", size.usize, size.vsize);
      const lineWidth = parseFloat(actor.getProperty().getLineWidth());
      const halfLineWidth = lineWidth / 2;
      publicAPI.getProgram().setUniformf("lineWidthStepSize", lineWidth / Math.ceil(lineWidth));
      publicAPI.getProgram().setUniformf("halfLineWidth", halfLineWidth);
    }
    if (model.primitiveType === primTypes.Points || actor.getProperty().getRepresentation() === Representation.POINTS) {
      publicAPI.getProgram().setUniformf("pointSize", actor.getProperty().getPointSize());
    } else if (model.pointPicking) {
      publicAPI.getProgram().setUniformf("pointSize", publicAPI.getPointPickingPrimitiveSize());
    }
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["//VTK::PositionVC::Dec", "uniform float pointSize;"]).result;
    VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["//VTK::PositionVC::Impl", "  gl_PointSize = pointSize;"], false).result;
    if (publicAPI.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES && publicAPI.haveWideLines(ren, actor)) {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["//VTK::PositionVC::Dec", "uniform vec2 viewportSize;", "uniform float lineWidthStepSize;", "uniform float halfLineWidth;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["//VTK::PositionVC::Impl", " if (halfLineWidth > 0.0)", "   {", "   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;", "   vec4 tmpPos = gl_Position;", "   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;", "   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];", "   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];", "   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);", "   }"]).result;
    }
    shaders.Vertex = VSSource;
  };
  publicAPI.getPointPickingPrimitiveSize = () => {
    if (model.primitiveType === primTypes.Points) {
      return 2;
    }
    if (model.primitiveType === primTypes.Lines) {
      return 4;
    }
    return 6;
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => publicAPI.getCABO().getAllocatedGPUMemoryInBytes();
}
var DEFAULT_VALUES45 = {
  context: null,
  program: null,
  shaderSourceTime: null,
  VAO: null,
  attributeUpdateTime: null,
  CABO: null,
  primitiveType: 0,
  pointPicking: false
};
function extend49(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES45, initialValues);
  macro.obj(publicAPI, model);
  model.shaderSourceTime = {};
  macro.obj(model.shaderSourceTime);
  model.attributeUpdateTime = {};
  macro.obj(model.attributeUpdateTime);
  macro.setGet(publicAPI, model, ["program", "shaderSourceTime", "VAO", "attributeUpdateTime", "CABO", "primitiveType", "pointPicking"]);
  model.program = vtkShaderProgram$1.newInstance();
  model.VAO = vtkVertexArrayObject.newInstance();
  model.CABO = vtkCellArrayBufferObject.newInstance();
  vtkOpenGLHelper(publicAPI, model);
}
var newInstance48 = macro.newInstance(extend49);
var vtkHelper = {
  newInstance: newInstance48,
  extend: extend49,
  primTypes
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataVS.glsl.js
var vtkPolyDataVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyDataFS.glsl.js
var vtkPolyDataFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ReplacementShaderMapper.js
function implementReplaceShaderCoincidentOffset(publicAPI, model) {
  publicAPI.replaceShaderCoincidentOffset = (shaders, ren, actor) => {
    const cp = publicAPI.getCoincidentParameters(ren, actor);
    if (cp && (cp.factor !== 0 || cp.offset !== 0)) {
      let FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Coincident::Dec", ["uniform float cfactor;", "uniform float coffset;"]).result;
      if (model.context.getExtension("EXT_frag_depth")) {
        if (cp.factor !== 0) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));", "//VTK::UniformFlow::Impl"], false).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result;
        } else {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result;
        }
      }
      if (model._openGLRenderWindow.getWebgl2()) {
        if (cp.factor !== 0) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::UniformFlow::Impl", ["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));", "//VTK::UniformFlow::Impl"], false).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result;
        } else {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Depth::Impl", "gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result;
        }
      }
      shaders.Fragment = FSSource;
    }
  };
}
function implementBuildShadersWithReplacements(publicAPI, model) {
  publicAPI.applyShaderReplacements = (shaders, viewSpec, pre) => {
    let shaderReplacements = null;
    if (viewSpec) {
      shaderReplacements = viewSpec.ShaderReplacements;
    }
    if (shaderReplacements) {
      for (let i = 0; i < shaderReplacements.length; i++) {
        const currReplacement = shaderReplacements[i];
        if (pre && currReplacement.replaceFirst || !pre && !currReplacement.replaceFirst) {
          const shaderType = currReplacement.shaderType;
          const ssrc = shaders[shaderType];
          const substituteRes = vtkShaderProgram$1.substitute(ssrc, currReplacement.originalValue, currReplacement.replacementValue, currReplacement.replaceAll);
          shaders[shaderType] = substituteRes.result;
        }
      }
    }
  };
  publicAPI.buildShaders = (shaders, ren, actor) => {
    publicAPI.getReplacedShaderTemplate(shaders, ren, actor);
    model.lastRenderPassShaderReplacement = model.currentRenderPass ? model.currentRenderPass.getShaderReplacement() : null;
    if (model.lastRenderPassShaderReplacement) {
      model.lastRenderPassShaderReplacement(shaders);
    }
    const openGLSpec = model.renderable.getViewSpecificProperties().OpenGL;
    publicAPI.applyShaderReplacements(shaders, openGLSpec, true);
    publicAPI.replaceShaderValues(shaders, ren, actor);
    publicAPI.applyShaderReplacements(shaders, openGLSpec);
  };
  publicAPI.getReplacedShaderTemplate = (shaders, ren, actor) => {
    const openGLSpecProp = model.renderable.getViewSpecificProperties().OpenGL;
    publicAPI.getShaderTemplate(shaders, ren, actor);
    let vertexShaderCode = shaders.Vertex;
    if (openGLSpecProp) {
      const vertexSpecProp = openGLSpecProp.VertexShaderCode;
      if (vertexSpecProp !== void 0 && vertexSpecProp !== "") {
        vertexShaderCode = vertexSpecProp;
      }
    }
    shaders.Vertex = vertexShaderCode;
    let fragmentShaderCode = shaders.Fragment;
    if (openGLSpecProp) {
      const fragmentSpecProp = openGLSpecProp.FragmentShaderCode;
      if (fragmentSpecProp !== void 0 && fragmentSpecProp !== "") {
        fragmentShaderCode = fragmentSpecProp;
      }
    }
    shaders.Fragment = fragmentShaderCode;
    let geometryShaderCode = shaders.Geometry;
    if (openGLSpecProp) {
      const geometrySpecProp = openGLSpecProp.GeometryShaderCode;
      if (geometrySpecProp !== void 0) {
        geometryShaderCode = geometrySpecProp;
      }
    }
    shaders.Geometry = geometryShaderCode;
  };
}
var vtkReplacementShaderMapper = {
  implementReplaceShaderCoincidentOffset,
  implementBuildShadersWithReplacements
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper.js
var {
  FieldAssociations: FieldAssociations3
} = vtkDataSet$1;
var {
  primTypes: primTypes2
} = vtkHelper;
var {
  Representation: Representation3,
  Shading: Shading2
} = vtkProperty$1;
var {
  ScalarMode: ScalarMode3
} = vtkMapper$1;
var {
  Filter: Filter3,
  Wrap: Wrap3
} = vtkOpenGLTexture$1;
var {
  vtkErrorMacro: vtkErrorMacro13
} = macro$1;
var StartEvent = {
  type: "StartEvent"
};
var EndEvent = {
  type: "EndEvent"
};
var {
  CoordinateSystem: CoordinateSystem3
} = vtkProp$1;
function getPickState(renderer) {
  const selector = renderer.getSelector();
  if (selector) {
    return selector.getCurrentPass();
  }
  return PassTypes.MIN_KNOWN_PASS - 1;
}
function vtkOpenGLPolyDataMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLPolyDataMapper");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.currentRenderPass = null;
      model.openGLActor = publicAPI.getFirstAncestorOfType("vtkOpenGLActor");
      model._openGLRenderer = model.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera(), model.openGLCamera);
    }
  };
  publicAPI.translucentPass = (prepass, renderPass) => {
    if (prepass) {
      model.currentRenderPass = renderPass;
      publicAPI.render();
    }
  };
  publicAPI.zBufferPass = (prepass) => {
    if (prepass) {
      model.haveSeenDepthRequest = true;
      model.renderDepth = true;
      publicAPI.render();
      model.renderDepth = false;
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.render = () => {
    const ctx = model._openGLRenderWindow.getContext();
    if (model.context !== ctx) {
      model.context = ctx;
      for (let i = primTypes2.Start; i < primTypes2.End; i++) {
        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
      }
    }
    const actor = model.openGLActor.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyDataVS;
    shaders.Fragment = vtkPolyDataFS;
    shaders.Geometry = "";
  };
  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    let colorDec = ["uniform float ambient;", "uniform float diffuse;", "uniform float specular;", "uniform float opacityUniform; // the fragment opacity", "uniform vec3 ambientColorUniform;", "uniform vec3 diffuseColorUniform;"];
    if (lastLightComplexity) {
      colorDec = colorDec.concat(["uniform vec3 specularColorUniform;", "uniform float specularPowerUniform;"]);
    }
    let colorImpl = ["vec3 ambientColor;", "  vec3 diffuseColor;", "  float opacity;"];
    if (lastLightComplexity) {
      colorImpl = colorImpl.concat(["  vec3 specularColor;", "  float specularPower;"]);
    }
    colorImpl = colorImpl.concat(["  ambientColor = ambientColorUniform;", "  diffuseColor = diffuseColorUniform;", "  opacity = opacityUniform;"]);
    if (lastLightComplexity) {
      colorImpl = colorImpl.concat(["  specularColor = specularColorUniform;", "  specularPower = specularPowerUniform;"]);
    }
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
      colorDec = colorDec.concat(["varying vec4 vertexColorVSOutput;"]);
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Dec", ["attribute vec4 scalarColor;", "varying vec4 vertexColorVSOutput;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Impl", ["vertexColorVSOutput =  scalarColor;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Dec", ["in vec4 vertexColorVSOutput[];", "out vec4 vertexColorGSOutput;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Impl", ["vertexColorGSOutput = vertexColorVSOutput[i];"]).result;
    }
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0 && !model.drawingEdges) {
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl.concat(["  diffuseColor = vertexColorVSOutput.rgb;", "  ambientColor = vertexColorVSOutput.rgb;", "  opacity = opacity*vertexColorVSOutput.a;"])).result;
    } else {
      if ((model.renderable.getAreScalarsMappedFromCells() || model.renderable.getInterpolateScalarsBeforeMapping()) && model.renderable.getColorCoordinates() && !model.drawingEdges) {
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);", "  diffuseColor = texColor.rgb;", "  ambientColor = texColor.rgb;", "  opacity = opacity*texColor.a;"])).result;
      } else {
        if (actor.getBackfaceProperty() && !model.drawingEdges) {
          colorDec = colorDec.concat(["uniform float opacityUniformBF; // the fragment opacity", "uniform float ambientIntensityBF; // the material ambient", "uniform float diffuseIntensityBF; // the material diffuse", "uniform vec3 ambientColorUniformBF; // ambient material color", "uniform vec3 diffuseColorUniformBF; // diffuse material color"]);
          if (lastLightComplexity) {
            colorDec = colorDec.concat(["uniform float specularIntensityBF; // the material specular intensity", "uniform vec3 specularColorUniformBF; // intensity weighted color", "uniform float specularPowerUniformBF;"]);
            colorImpl = colorImpl.concat(["if (gl_FrontFacing == false) {", "  ambientColor = ambientIntensityBF * ambientColorUniformBF;", "  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;", "  specularColor = specularIntensityBF * specularColorUniformBF;", "  specularPower = specularPowerUniformBF;", "  opacity = opacityUniformBF; }"]);
          } else {
            colorImpl = colorImpl.concat(["if (gl_FrontFacing == false) {", "  ambientColor = ambientIntensityBF * ambientColorUniformBF;", "  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;", "  opacity = opacityUniformBF; }"]);
          }
        }
        if (model.haveCellScalars && !model.drawingEdges) {
          colorDec = colorDec.concat(["uniform samplerBuffer texture1;"]);
        }
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl).result;
      }
    }
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Dec", colorDec).result;
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderLight = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    const shadowFactor = "";
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    const lastLightCount = model.lastBoundBO.getReferenceByName("lastLightCount");
    let sstring = [];
    switch (lastLightComplexity) {
      case 0:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", ["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);", "  //VTK::Light::Impl"], false).result;
        break;
      case 1:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", ["  float df = max(0.0, normalVCVSOutput.z);", "  float sf = pow(df, specularPower);", "  vec3 diffuseL = df * diffuseColor;", "  vec3 specularL = sf * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"], false).result;
        break;
      case 2:
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`]);
        }
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", sstring).result;
        sstring = ["vec3 diffuseL = vec3(0,0,0);", "  vec3 specularL = vec3(0,0,0);", "  float df;"];
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${lc}));`, `  diffuseL += ((df${shadowFactor}) * lightColor${lc});`, `  if (dot(normalVCVSOutput, lightDirectionVC${lc}) < 0.0)`, "    {", `    float sf = sign(df)*pow(max(1e-5,
                                              dot(reflect(lightDirectionVC${lc},normalVCVSOutput),
                                                  normalize(-vertexVC.xyz))),
                                         specularPower);`, `    specularL += (sf${shadowFactor} * lightColor${lc});`, "    }"]);
        }
        sstring = sstring.concat(["  diffuseL = diffuseL * diffuseColor;", "  specularL = specularL * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"]);
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", sstring, false).result;
        break;
      case 3:
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat([`uniform vec3 lightColor${lc};`, `uniform vec3 lightDirectionVC${lc}; // normalized`, `uniform vec3 lightHalfAngleVC${lc}; // normalized`, `uniform vec3 lightPositionVC${lc};`, `uniform vec3 lightAttenuation${lc};`, `uniform float lightConeAngle${lc};`, `uniform float lightExponent${lc};`, `uniform int lightPositional${lc};`]);
        }
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Dec", sstring).result;
        sstring = ["vec3 diffuseL = vec3(0,0,0);", "  vec3 specularL = vec3(0,0,0);", "  vec3 vertLightDirectionVC;", "  float attenuation;", "  float df;"];
        for (let lc = 0; lc < lastLightCount; ++lc) {
          sstring = sstring.concat(["  attenuation = 1.0;", `  if (lightPositional${lc} == 0)`, "    {", `      vertLightDirectionVC = lightDirectionVC${lc};`, "    }", "  else", "    {", `    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${lc};`, "    float distanceVC = length(vertLightDirectionVC);", "    vertLightDirectionVC = normalize(vertLightDirectionVC);", "    attenuation = 1.0 /", `      (lightAttenuation${lc}.x`, `       + lightAttenuation${lc}.y * distanceVC`, `       + lightAttenuation${lc}.z * distanceVC * distanceVC);`, "    // per OpenGL standard cone angle is 90 or less for a spot light", `    if (lightConeAngle${lc} <= 90.0)`, "      {", `      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${lc});`, "      // if inside the cone", `      if (coneDot >= cos(radians(lightConeAngle${lc})))`, "        {", `        attenuation = attenuation * pow(coneDot, lightExponent${lc});`, "        }", "      else", "        {", "        attenuation = 0.0;", "        }", "      }", "    }", "    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));", `    diffuseL += ((df${shadowFactor}) * lightColor${lc});`, "    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)", "      {", `      float sf = sign(df)*attenuation*pow(max(1e-5,
                                                           dot(reflect(lightDirectionVC${lc},
                                                                       normalVCVSOutput),
                                                               normalize(-vertexVC.xyz))),
                                                       specularPower);`, `    specularL += ((sf${shadowFactor}) * lightColor${lc});`, "    }"]);
        }
        sstring = sstring.concat(["  diffuseL = diffuseL * diffuseColor;", "  specularL = specularL * specularColor;", "  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);", "  //VTK::Light::Impl"]);
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Light::Impl", sstring, false).result;
        break;
      default:
        vtkErrorMacro13("bad light complexity");
    }
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderNormal = (shaders, ren, actor) => {
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity > 0) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      if (model.lastBoundBO.getCABO().getNormalOffset()) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Dec", ["attribute vec3 normalMC;", "uniform mat3 normalMatrix;", "varying vec3 normalVCVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Normal::Impl", ["normalVCVSOutput = normalMatrix * normalMC;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Normal::Dec", ["in vec3 normalVCVSOutput[];", "out vec3 normalVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Normal::Impl", ["normalVCGSOutput = normalVCVSOutput[i];"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["varying vec3 normalVCVSOutput;"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", [
          "vec3 normalVCVSOutput = normalize(normalVCVSOutput);",
          //  if (!gl_FrontFacing) does not work in intel hd4000 mac
          //  if (int(gl_FrontFacing) == 0) does not work on mesa
          "  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"
        ]).result;
      } else {
        if (model.haveCellNormals) {
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["uniform mat3 normalMatrix;", "uniform samplerBuffer textureN;"]).result;
          FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", ["vec3 normalVCVSOutput = normalize(normalMatrix *", "    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);", "  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result;
        } else {
          if (model.lastBoundBO.getOpenGLMode(actor.getProperty().getRepresentation()) === model.context.LINES) {
            FSSource = vtkShaderProgram$1.substitute(
              FSSource,
              "//VTK::UniformFlow::Impl",
              ["  vec3 fdx = dFdx(vertexVC.xyz);", "  vec3 fdy = dFdy(vertexVC.xyz);", "  //VTK::UniformFlow::Impl"]
              // For further replacements
            ).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", ["vec3 normalVCVSOutput;", "  if (abs(fdx.x) > 0.0)", "    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }", "  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result;
          } else {
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Dec", ["uniform int cameraParallel;"]).result;
            FSSource = vtkShaderProgram$1.substitute(
              FSSource,
              "//VTK::UniformFlow::Impl",
              [
                // '  vec3 fdx = vec3(dFdx(vertexVC.x),dFdx(vertexVC.y),dFdx(vertexVC.z));',
                // '  vec3 fdy = vec3(dFdy(vertexVC.x),dFdy(vertexVC.y),dFdy(vertexVC.z));',
                "  vec3 fdx = dFdx(vertexVC.xyz);",
                "  vec3 fdy = dFdy(vertexVC.xyz);",
                "  //VTK::UniformFlow::Impl"
              ]
              // For further replacements
            ).result;
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Normal::Impl", [
              "  fdx = normalize(fdx);",
              "  fdy = normalize(fdy);",
              "  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));",
              // the code below is faster, but does not work on some devices
              // 'vec3 normalVC = normalize(cross(dFdx(vertexVC.xyz), dFdy(vertexVC.xyz)));',
              "  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }",
              "  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"
            ]).result;
          }
        }
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity > 0) {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Dec", ["varying vec4 vertexVCVSOutput;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["vertexVCVSOutput = MCVCMatrix * vertexMC;", "  gl_Position = MCPCMatrix * vertexMC;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;", "uniform mat4 MCVCMatrix;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::PositionVC::Dec", ["in vec4 vertexVCVSOutput[];", "out vec4 vertexVCGSOutput;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::PositionVC::Impl", ["vertexVCGSOutput = vertexVCVSOutput[i];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Dec", ["varying vec4 vertexVCVSOutput;"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::PositionVC::Impl", ["vec4 vertexVC = vertexVCVSOutput;"]).result;
    } else {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Camera::Dec", ["uniform mat4 MCPCMatrix;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::PositionVC::Impl", ["  gl_Position = MCPCMatrix * vertexMC;"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    if (model.lastBoundBO.getCABO().getTCoordOffset()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      if (model.drawingEdges) {
        return;
      }
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", "tcoordVCVSOutput = tcoordMC;").result;
      const tus = model.openGLActor.getActiveTextures();
      let tNumComp = 2;
      let tcdim = 2;
      if (tus && tus.length > 0) {
        tNumComp = tus[0].getComponents();
        if (tus[0].getTarget() === model.context.TEXTURE_CUBE_MAP) {
          tcdim = 3;
        }
      }
      if (model.renderable.getColorTextureMap()) {
        tNumComp = model.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents();
        tcdim = 2;
      }
      if (tcdim === 2) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordVCVSOutput[];", "out vec2 tcoordVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];").result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["varying vec2 tcoordVCVSOutput;", "uniform sampler2D texture1;"]).result;
        if (tus && tus.length >= 1) {
          switch (tNumComp) {
            case 1:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;"]).result;
              break;
            case 2:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;", "  opacity = opacity * tcolor.g;"]).result;
              break;
            default:
              FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.rgb;", "  diffuseColor = diffuseColor*tcolor.rgb;", "  opacity = opacity * tcolor.a;"]).result;
          }
        }
      } else {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", "attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in vec3 tcoordVCVSOutput[];", "out vec3 tcoordVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];").result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["varying vec3 tcoordVCVSOutput;", "uniform samplerCube texture1;"]).result;
        switch (tNumComp) {
          case 1:
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;"]).result;
            break;
          case 2:
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.r;", "  diffuseColor = diffuseColor*tcolor.r;", "  opacity = opacity * tcolor.g;"]).result;
            break;
          default:
            FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);", "  ambientColor = ambientColor*tcolor.rgb;", "  diffuseColor = diffuseColor*tcolor.rgb;", "  opacity = opacity * tcolor.a;"]).result;
        }
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderClip = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let FSSource = shaders.Fragment;
    if (model.renderable.getNumberOfClippingPlanes()) {
      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", `uniform vec4 clipPlanes[${numClipPlanes}];`, `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Clip::Impl", [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);", "    }"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Dec", ["uniform int numClipPlanes;", `varying float clipDistancesVSOutput[${numClipPlanes}];`]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Clip::Impl", [`for (int planeNum = 0; planeNum < ${numClipPlanes}; planeNum++)`, "    {", "    if (planeNum >= numClipPlanes)", "        {", "        break;", "        }", "    if (clipDistancesVSOutput[planeNum] < 0.0) discard;", "    }"]).result;
    }
    shaders.Vertex = VSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.getCoincidentParameters = (ren, actor) => {
    let cp = {
      factor: 0,
      offset: 0
    };
    const prop = actor.getProperty();
    if (
      // backwards compat with code that (errorneously) set this to boolean
      // eslint-disable-next-line eqeqeq
      model.renderable.getResolveCoincidentTopology() == Resolve.PolygonOffset || prop.getEdgeVisibility() && prop.getRepresentation() === Representation3.SURFACE
    ) {
      const primType = model.lastBoundBO.getPrimitiveType();
      if (primType === primTypes2.Points || prop.getRepresentation() === Representation3.POINTS) {
        cp = model.renderable.getCoincidentTopologyPointOffsetParameter();
      } else if (primType === primTypes2.Lines || prop.getRepresentation() === Representation3.WIREFRAME) {
        cp = model.renderable.getCoincidentTopologyLineOffsetParameters();
      } else if (primType === primTypes2.Tris || primType === primTypes2.TriStrips) {
        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
      }
      if (primType === primTypes2.TrisEdges || primType === primTypes2.TriStripsEdges) {
        cp = model.renderable.getCoincidentTopologyPolygonOffsetParameters();
        cp.factor /= 2;
        cp.offset /= 2;
      }
    }
    const selector = model._openGLRenderer.getSelector();
    if (selector && selector.getFieldAssociation() === FieldAssociations3.FIELD_ASSOCIATION_POINTS) {
      cp.offset -= 2;
    }
    return cp;
  };
  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    let VSSource = shaders.Vertex;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", ["uniform int picking;", "//VTK::Picking::Dec"]).result;
    if (!model._openGLRenderer.getSelector()) {
      return;
    }
    if (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24) {
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Picking::Dec", ["flat out int vertexIDVSOutput;\n", "uniform int VertexIDOffset;\n"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Picking::Impl", "  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", "flat in int vertexIDVSOutput;\n").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", ["  int idx = vertexIDVSOutput;", "//VTK::Picking::Impl"]).result;
    }
    switch (model.lastSelectionState) {
      case PassTypes.ID_LOW24:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;
        break;
      case PassTypes.ID_HIGH24:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;
        break;
      default:
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", "uniform vec3 mapperIndex;").result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result;
    }
    shaders.Fragment = FSSource;
    shaders.Vertex = VSSource;
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderColor(shaders, ren, actor);
    publicAPI.replaceShaderNormal(shaders, ren, actor);
    publicAPI.replaceShaderLight(shaders, ren, actor);
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPicking(shaders, ren, actor);
    publicAPI.replaceShaderClip(shaders, ren, actor);
    publicAPI.replaceShaderCoincidentOffset(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
    if (model.haveSeenDepthRequest) {
      let FSSource = shaders.Fragment;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Dec", "uniform int depthRequest;").result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::ZBuffer::Impl", ["if (depthRequest == 1) {", "float iz = floor(gl_FragCoord.z*65535.0 + 0.1);", "float rf = floor(iz/256.0)/255.0;", "float gf = mod(iz,256.0)/255.0;", "gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    let lightComplexity = 0;
    let numberOfLights = 0;
    const primType = cellBO.getPrimitiveType();
    const poly = model.currentInput;
    let needLighting = false;
    const pointNormals = poly.getPointData().getNormals();
    const cellNormals = poly.getCellData().getNormals();
    const flat = actor.getProperty().getInterpolation() === Shading2.FLAT;
    const representation = actor.getProperty().getRepresentation();
    const mode2 = cellBO.getOpenGLMode(representation, primType);
    if (mode2 === model.context.TRIANGLES) {
      needLighting = true;
    } else if (cellNormals && !pointNormals) {
      needLighting = true;
    } else if (!flat && pointNormals) {
      needLighting = true;
    } else if (!flat && mode2 === model.context.LINES) {
      needLighting = true;
    }
    if (actor.getProperty().getLighting() && needLighting) {
      lightComplexity = 0;
      const lights = ren.getLightsByReference();
      for (let index2 = 0; index2 < lights.length; ++index2) {
        const light = lights[index2];
        const status = light.getSwitch();
        if (status > 0) {
          numberOfLights++;
          if (lightComplexity === 0) {
            lightComplexity = 1;
          }
        }
        if (lightComplexity === 1 && (numberOfLights > 1 || light.getIntensity() !== 1 || !light.lightTypeIsHeadLight())) {
          lightComplexity = 2;
        }
        if (lightComplexity < 3 && light.getPositional()) {
          lightComplexity = 3;
        }
      }
    }
    let needRebuild = false;
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    const lastLightCount = model.lastBoundBO.getReferenceByName("lastLightCount");
    if (lastLightComplexity !== lightComplexity || lastLightCount !== numberOfLights) {
      model.lastBoundBO.set({
        lastLightComplexity: lightComplexity
      }, true);
      model.lastBoundBO.set({
        lastLightCount: numberOfLights
      }, true);
      needRebuild = true;
    }
    if (!model.currentRenderPass && model.lastRenderPassShaderReplacement || model.currentRenderPass && model.currentRenderPass.getShaderReplacement() !== model.lastRenderPassShaderReplacement) {
      needRebuild = true;
    }
    if (model.lastHaveSeenDepthRequest !== model.haveSeenDepthRequest || cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.selectionStateChanged.getMTime() || needRebuild) {
      model.lastHaveSeenDepthRequest = model.haveSeenDepthRequest;
      return true;
    }
    return false;
  };
  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {
    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
    if (listCallbacks) {
      listCallbacks.forEach((object) => {
        object.callback(object.userData, cellBO, ren, actor);
      });
    }
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getProgram().isUniformUsed("PrimitiveIDOffset")) {
      cellBO.getProgram().setUniformi("PrimitiveIDOffset", model.primitiveIDOffset);
    }
    if (cellBO.getProgram().isUniformUsed("VertexIDOffset")) {
      cellBO.getProgram().setUniformi("VertexIDOffset", model.vertexIDOffset);
    }
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
      if (cellBO.getProgram().isAttributeUsed("vertexMC")) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexMC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro13("Error setting vertexMC in shader VAO.");
        }
      }
      if (cellBO.getProgram().isAttributeUsed("normalMC") && cellBO.getCABO().getNormalOffset() && lastLightComplexity > 0) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "normalMC", cellBO.getCABO().getNormalOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
          vtkErrorMacro13("Error setting normalMC in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("normalMC");
      }
      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
            vtkErrorMacro13(`Error setting ${attrName}MC in shader VAO.`);
          }
        }
      });
      if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
          vtkErrorMacro13("Error setting tcoordMC in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("tcoordMC");
      }
      if (cellBO.getProgram().isAttributeUsed("scalarColor") && cellBO.getCABO().getColorComponents()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), "scalarColor", cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {
          vtkErrorMacro13("Error setting scalarColor in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("scalarColor");
      }
      cellBO.getAttributeUpdateTime().modified();
    }
    if (model.renderable.getNumberOfClippingPlanes()) {
      const numClipPlanes = model.renderable.getNumberOfClippingPlanes();
      const planeEquations = [];
      const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
      const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
      const mat = inverseShiftScaleMatrix ? mat4_exports.copy(model.tmpMat4, actor.getMatrix()) : actor.getMatrix();
      if (inverseShiftScaleMatrix) {
        mat4_exports.transpose(mat, mat);
        mat4_exports.multiply(mat, mat, inverseShiftScaleMatrix);
        mat4_exports.transpose(mat, mat);
      }
      for (let i = 0; i < numClipPlanes; i++) {
        const planeEquation = [];
        model.renderable.getClippingPlaneInDataCoords(mat, i, planeEquation);
        for (let j = 0; j < 4; j++) {
          planeEquations.push(planeEquation[j]);
        }
      }
      cellBO.getProgram().setUniformi("numClipPlanes", numClipPlanes);
      cellBO.getProgram().setUniform4fv("clipPlanes", planeEquations);
    }
    if (model.internalColorTexture && cellBO.getProgram().isUniformUsed("texture1")) {
      cellBO.getProgram().setUniformi("texture1", model.internalColorTexture.getTextureUnit());
    }
    const tus = model.openGLActor.getActiveTextures();
    if (tus) {
      for (let index2 = 0; index2 < tus.length; ++index2) {
        const tex = tus[index2];
        const texUnit = tex.getTextureUnit();
        const tname = `texture${texUnit + 1}`;
        if (cellBO.getProgram().isUniformUsed(tname)) {
          cellBO.getProgram().setUniformi(tname, texUnit);
        }
      }
    }
    if (model.haveSeenDepthRequest) {
      cellBO.getProgram().setUniformi("depthRequest", model.renderDepth ? 1 : 0);
    }
    if (cellBO.getProgram().isUniformUsed("coffset")) {
      const cp = publicAPI.getCoincidentParameters(ren, actor);
      cellBO.getProgram().setUniformf("coffset", cp.offset);
      if (cellBO.getProgram().isUniformUsed("cfactor")) {
        cellBO.getProgram().setUniformf("cfactor", cp.factor);
      }
    }
    cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());
    const selector = model._openGLRenderer.getSelector();
    cellBO.getProgram().setUniform3fArray("mapperIndex", selector ? selector.getPropColorValue() : [0, 0, 0]);
    cellBO.getProgram().setUniformi("picking", selector ? selector.getCurrentPass() + 1 : 0);
  };
  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity < 2) {
      return;
    }
    const program = cellBO.getProgram();
    let numberOfLights = 0;
    const lights = ren.getLightsByReference();
    for (let index2 = 0; index2 < lights.length; ++index2) {
      const light = lights[index2];
      const status = light.getSwitch();
      if (status > 0) {
        const dColor = light.getColorByReference();
        const intensity = light.getIntensity();
        model.lightColor[0] = dColor[0] * intensity;
        model.lightColor[1] = dColor[1] * intensity;
        model.lightColor[2] = dColor[2] * intensity;
        const ld = light.getDirection();
        const transform = ren.getActiveCamera().getViewMatrix();
        const newLightDirection = [...ld];
        if (light.lightTypeIsSceneLight()) {
          newLightDirection[0] = transform[0] * ld[0] + transform[1] * ld[1] + transform[2] * ld[2];
          newLightDirection[1] = transform[4] * ld[0] + transform[5] * ld[1] + transform[6] * ld[2];
          newLightDirection[2] = transform[8] * ld[0] + transform[9] * ld[1] + transform[10] * ld[2];
          normalize(newLightDirection);
        }
        model.lightDirection[0] = newLightDirection[0];
        model.lightDirection[1] = newLightDirection[1];
        model.lightDirection[2] = newLightDirection[2];
        normalize(model.lightDirection);
        program.setUniform3fArray(`lightColor${numberOfLights}`, model.lightColor);
        program.setUniform3fArray(`lightDirectionVC${numberOfLights}`, model.lightDirection);
        numberOfLights++;
      }
    }
    if (lastLightComplexity < 3) {
      return;
    }
    const cam = ren.getActiveCamera();
    const viewTF = cam.getViewMatrix();
    mat4_exports.transpose(viewTF, viewTF);
    numberOfLights = 0;
    for (let index2 = 0; index2 < lights.length; ++index2) {
      const light = lights[index2];
      const status = light.getSwitch();
      if (status > 0) {
        const lp = light.getTransformedPosition();
        const np = new Float64Array(3);
        vec3_exports.transformMat4(np, lp, viewTF);
        program.setUniform3fArray(`lightAttenuation${numberOfLights}`, light.getAttenuationValuesByReference());
        program.setUniformi(`lightPositional${numberOfLights}`, light.getPositional());
        program.setUniformf(`lightExponent${numberOfLights}`, light.getExponent());
        program.setUniformf(`lightConeAngle${numberOfLights}`, light.getConeAngle());
        program.setUniform3fArray(`lightPositionVC${numberOfLights}`, [np[0], np[1], np[2]]);
        numberOfLights++;
      }
    }
  };
  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
    matrixType.identity(tmpMat);
    return matrixArray.reduce((res, matrix, index2) => {
      if (index2 === 0) {
        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
      }
      return matrix ? matrixType.multiply(res, res, matrix) : res;
    }, tmpMat);
  }
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const keyMats = model.openGLCamera.getKeyMatrices(ren);
    const cam = ren.getActiveCamera();
    const camm = model.openGLCamera.getKeyMatrixTime().getMTime();
    const progm = program.getLastCameraMTime();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
    const actorIsIdentity = actor.getIsIdentity();
    const actMats = actorIsIdentity ? {
      mcwc: null,
      normalMatrix: null
    } : model.openGLActor.getKeyMatrices();
    if (actor.getCoordinateSystem() === CoordinateSystem3.DISPLAY) {
      const size = model._openGLRenderer.getTiledSizeAndOrigin();
      mat4_exports.identity(model.tmpMat4);
      model.tmpMat4[0] = 2 / size.usize;
      model.tmpMat4[12] = -1;
      model.tmpMat4[5] = 2 / size.vsize;
      model.tmpMat4[13] = -1;
      mat4_exports.multiply(model.tmpMat4, model.tmpMat4, inverseShiftScaleMatrix);
      program.setUniformMatrix("MCPCMatrix", model.tmpMat4);
    } else {
      program.setUniformMatrix("MCPCMatrix", safeMatrixMultiply([keyMats.wcpc, actMats.mcwc, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
    }
    if (program.isUniformUsed("MCVCMatrix")) {
      program.setUniformMatrix("MCVCMatrix", safeMatrixMultiply([keyMats.wcvc, actMats.mcwc, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
    }
    if (program.isUniformUsed("normalMatrix")) {
      program.setUniformMatrix3x3("normalMatrix", safeMatrixMultiply([keyMats.normalMatrix, actMats.normalMatrix], mat3_exports, model.tmpMat3));
    }
    if (progm !== camm) {
      if (program.isUniformUsed("cameraParallel")) {
        program.setUniformi("cameraParallel", cam.getParallelProjection());
      }
      program.setLastCameraMTime(camm);
    }
    if (!actorIsIdentity) {
      program.setLastCameraMTime(0);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    let ppty = actor.getProperty();
    let opacity = ppty.getOpacity();
    let aColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getAmbientColorByReference();
    let dColor = model.drawingEdges ? ppty.getEdgeColorByReference() : ppty.getDiffuseColorByReference();
    let aIntensity = model.drawingEdges ? 1 : ppty.getAmbient();
    let dIntensity = model.drawingEdges ? 0 : ppty.getDiffuse();
    let sIntensity = model.drawingEdges ? 0 : ppty.getSpecular();
    const specularPower = ppty.getSpecularPower();
    program.setUniformf("opacityUniform", opacity);
    program.setUniform3fArray("ambientColorUniform", aColor);
    program.setUniform3fArray("diffuseColorUniform", dColor);
    program.setUniformf("ambient", aIntensity);
    program.setUniformf("diffuse", dIntensity);
    const lastLightComplexity = model.lastBoundBO.getReferenceByName("lastLightComplexity");
    if (lastLightComplexity < 1) {
      return;
    }
    let sColor = ppty.getSpecularColorByReference();
    program.setUniform3fArray("specularColorUniform", sColor);
    program.setUniformf("specularPowerUniform", specularPower);
    program.setUniformf("specular", sIntensity);
    if (program.isUniformUsed("ambientIntensityBF")) {
      ppty = actor.getBackfaceProperty();
      opacity = ppty.getOpacity();
      aColor = ppty.getAmbientColor();
      aIntensity = ppty.getAmbient();
      dColor = ppty.getDiffuseColor();
      dIntensity = ppty.getDiffuse();
      sColor = ppty.getSpecularColor();
      sIntensity = ppty.getSpecular();
      program.setUniformf("ambientIntensityBF", aIntensity);
      program.setUniformf("diffuseIntensityBF", dIntensity);
      program.setUniformf("opacityUniformBF", opacity);
      program.setUniform3fArray("ambientColorUniformBF", aColor);
      program.setUniform3fArray("diffuseColorUniformBF", dColor);
      if (lastLightComplexity < 1) {
        return;
      }
      program.setUniformf("specularIntensityBF", sIntensity);
      program.setUniform3fArray("specularColorUniformBF", sColor);
      program.setUniformf("specularPowerUniformBF", specularPower);
    }
  };
  publicAPI.updateMaximumPointCellIds = (ren, actor) => {
    var _a, _b, _c, _d;
    const selector = model._openGLRenderer.getSelector();
    if (!selector) {
      return;
    }
    if ((_b = (_a = model.selectionWebGLIdsToVTKIds) == null ? void 0 : _a.points) == null ? void 0 : _b.length) {
      const length4 = model.selectionWebGLIdsToVTKIds.points.length;
      selector.setMaximumPointId(length4 - 1);
    }
    if ((_d = (_c = model.selectionWebGLIdsToVTKIds) == null ? void 0 : _c.cells) == null ? void 0 : _d.length) {
      const length4 = model.selectionWebGLIdsToVTKIds.cells.length;
      selector.setMaximumCellId(length4 - 1);
    }
    const fieldAssociation = selector.getFieldAssociation();
    if (fieldAssociation === FieldAssociations3.FIELD_ASSOCIATION_POINTS) {
      model.pointPicking = true;
    }
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    model.primitiveIDOffset = 0;
    model.vertexIDOffset = 0;
    const picking = getPickState(model._openGLRenderer);
    if (model.lastSelectionState !== picking) {
      model.selectionStateChanged.modified();
      model.lastSelectionState = picking;
    }
    if (model._openGLRenderer.getSelector()) {
      switch (picking) {
        default:
          model._openGLRenderer.getSelector().renderProp(actor);
      }
    }
    publicAPI.updateBufferObjects(ren, actor);
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.activate();
    }
    model.lastBoundBO = null;
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();
    const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation3.SURFACE;
    const selector = model._openGLRenderer.getSelector();
    const pointPicking = selector && selector.getFieldAssociation() === FieldAssociations3.FIELD_ASSOCIATION_POINTS && (model.lastSelectionState === PassTypes.ID_LOW24 || model.lastSelectionState === PassTypes.ID_HIGH24);
    for (let i = primTypes2.Start; i < primTypes2.End; i++) {
      model.primitives[i].setPointPicking(pointPicking);
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        model.drawingEdges = drawSurfaceWithEdges && (i === primTypes2.TrisEdges || i === primTypes2.TriStripsEdges);
        if (!model.drawingEdges || !(model.renderDepth || model.lastSelectionState >= 0)) {
          model.lastBoundBO = model.primitives[i];
          model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);
          model.vertexIDOffset += model.primitives[i].getCABO().getElementCount();
        }
      }
    }
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    if (model.LastBoundBO) {
      model.LastBoundBO.getVAO().release();
    }
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.deactivate();
    }
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent(StartEvent);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent(EndEvent);
    if (!model.currentInput) {
      vtkErrorMacro13("No input!");
      return;
    }
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }
    const gl = model.context;
    const backfaceCulling = actor.getProperty().getBackfaceCulling();
    const frontfaceCulling = actor.getProperty().getFrontfaceCulling();
    if (!backfaceCulling && !frontfaceCulling) {
      model._openGLRenderWindow.disableCullFace();
    } else if (frontfaceCulling) {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.FRONT);
    } else {
      model._openGLRenderWindow.enableCullFace();
      gl.cullFace(gl.BACK);
    }
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
    publicAPI.updateMaximumPointCellIds();
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < publicAPI.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, 1);
    const c = model.renderable.getColorMapColors();
    model.haveCellScalars = false;
    const scalarMode = model.renderable.getScalarMode();
    if (model.renderable.getScalarVisibility()) {
      if ((scalarMode === ScalarMode3.USE_CELL_DATA || scalarMode === ScalarMode3.USE_CELL_FIELD_DATA || scalarMode === ScalarMode3.USE_FIELD_DATA || !poly.getPointData().getScalars()) && scalarMode !== ScalarMode3.USE_POINT_FIELD_DATA && c) {
        model.haveCellScalars = true;
      }
    }
    let n = actor.getProperty().getInterpolation() !== Shading2.FLAT ? poly.getPointData().getNormals() : null;
    if (n === null && poly.getCellData().getNormals()) {
      model.haveCellNormals = true;
      n = poly.getCellData().getNormals();
    }
    const representation = actor.getProperty().getRepresentation();
    let tcoords = poly.getPointData().getTCoords();
    if (!model.openGLActor.getActiveTextures()) {
      tcoords = null;
    }
    let useTCoordsPerCell = false;
    if (model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
      useTCoordsPerCell = model.renderable.getAreScalarsMappedFromCells();
      if (!model.internalColorTexture) {
        model.internalColorTexture = vtkOpenGLTexture$1.newInstance({
          resizable: true
        });
      }
      const tex = model.internalColorTexture;
      tex.setMinificationFilter(Filter3.NEAREST);
      tex.setMagnificationFilter(Filter3.NEAREST);
      tex.setWrapS(Wrap3.CLAMP_TO_EDGE);
      tex.setWrapT(Wrap3.CLAMP_TO_EDGE);
      tex.setOpenGLRenderWindow(model._openGLRenderWindow);
      const input = model.renderable.getColorTextureMap();
      const ext = input.getExtent();
      const inScalars = input.getPointData().getScalars();
      tex.create2DFromRaw({
        width: ext[1] - ext[0] + 1,
        height: ext[3] - ext[2] + 1,
        numComps: inScalars.getNumberOfComponents(),
        dataType: inScalars.getDataType(),
        data: inScalars.getData()
      });
      tex.activate();
      tex.sendParameters();
      tex.deactivate();
    }
    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}C${n ? n.getMTime() : 1}D${c ? c.getMTime() : 1}E${actor.getProperty().getEdgeVisibility()}F${tcoords ? tcoords.getMTime() : 1}`;
    if (model.VBOBuildString !== toString) {
      const points = poly.getPoints();
      const options = {
        points,
        normals: n,
        tcoords,
        colors: c,
        cellOffset: 0,
        vertexOffset: 0,
        // Used to keep track of vertex ids across primitives for selection
        useTCoordsPerCell,
        haveCellScalars: model.haveCellScalars,
        haveCellNormals: model.haveCellNormals,
        customAttributes: model.renderable.getCustomShaderAttributes().map((arrayName) => poly.getPointData().getArrayByName(arrayName))
      };
      if (model.renderable.getPopulateSelectionSettings()) {
        model.selectionWebGLIdsToVTKIds = {
          points: null,
          cells: null
        };
      }
      const primitives = [{
        inRep: "verts",
        cells: poly.getVerts()
      }, {
        inRep: "lines",
        cells: poly.getLines()
      }, {
        inRep: "polys",
        cells: poly.getPolys()
      }, {
        inRep: "strips",
        cells: poly.getStrips()
      }, {
        inRep: "polys",
        cells: poly.getPolys()
      }, {
        inRep: "strips",
        cells: poly.getStrips()
      }];
      const drawSurfaceWithEdges = actor.getProperty().getEdgeVisibility() && representation === Representation3.SURFACE;
      for (let i = primTypes2.Start; i < primTypes2.End; i++) {
        if (i !== primTypes2.TrisEdges && i !== primTypes2.TriStripsEdges) {
          options.cellOffset += model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, representation, options, model.selectionWebGLIdsToVTKIds);
          options.vertexOffset += model.primitives[i].getCABO().getElementCount();
        } else {
          if (drawSurfaceWithEdges) {
            model.primitives[i].getCABO().createVBO(primitives[i].cells, primitives[i].inRep, Representation3.WIREFRAME, {
              ...options,
              tcoords: null,
              colors: null,
              haveCellScalars: false,
              haveCellNormals: false
            });
          } else {
            model.primitives[i].releaseGraphicsResources();
          }
        }
      }
      if (model.renderable.getPopulateSelectionSettings()) {
        model.renderable.setSelectionWebGLIdsToVTKIds(model.selectionWebGLIdsToVTKIds);
      }
      model.VBOBuildString = toString;
    }
    model.VBOBuildTime.modified();
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => {
    let memUsed = 0;
    model.primitives.forEach((prim) => {
      memUsed += prim.getAllocatedGPUMemoryInBytes();
    });
    return memUsed;
  };
}
var DEFAULT_VALUES46 = {
  context: null,
  VBOBuildTime: 0,
  VBOBuildString: null,
  primitives: null,
  primTypes: null,
  shaderRebuildString: null,
  tmpMat4: null,
  ambientColor: [],
  // used internally
  diffuseColor: [],
  // used internally
  specularColor: [],
  // used internally
  lightColor: [],
  // used internally
  lightDirection: [],
  // used internally
  lastHaveSeenDepthRequest: false,
  haveSeenDepthRequest: false,
  lastSelectionState: PassTypes.MIN_KNOWN_PASS - 1,
  selectionStateChanged: null,
  selectionWebGLIdsToVTKIds: null,
  pointPicking: false
};
function extend50(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES46, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.primitives = [];
  model.primTypes = primTypes2;
  model.tmpMat3 = mat3_exports.identity(new Float64Array(9));
  model.tmpMat4 = mat4_exports.identity(new Float64Array(16));
  for (let i = primTypes2.Start; i < primTypes2.End; i++) {
    model.primitives[i] = vtkHelper.newInstance();
    model.primitives[i].setPrimitiveType(i);
    model.primitives[i].set({
      lastLightComplexity: 0,
      lastLightCount: 0,
      lastSelectionPass: false
    }, true);
  }
  setGet(publicAPI, model, ["context"]);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime, {
    mtime: 0
  });
  model.selectionStateChanged = {};
  obj(model.selectionStateChanged, {
    mtime: 0
  });
  vtkOpenGLPolyDataMapper(publicAPI, model);
}
var newInstance49 = newInstance(extend50, "vtkOpenGLPolyDataMapper");
var vtkOpenGLPolyDataMapper$1 = {
  newInstance: newInstance49,
  extend: extend50
};
registerOverride("vtkMapper", newInstance49);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/PixelSpaceCallbackMapper.js
var {
  vtkDebugMacro: vtkDebugMacro2
} = macro$1;
function vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper");
  publicAPI.opaquePass = (prepass, renderPass) => {
    model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
    model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
    const aspectRatio = model._openGLRenderer.getAspectRatio();
    const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
    const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
    let texels = null;
    if (model.renderable.getUseZValues()) {
      const zbt = renderPass.getZBufferTexture();
      const width = Math.floor(zbt.getWidth());
      const height = Math.floor(zbt.getHeight());
      const gl = model._openGLRenderWindow.getContext();
      zbt.bind();
      const fb = renderPass.getFramebuffer();
      if (!fb) {
        vtkDebugMacro2("No framebuffer to save/restore");
      } else {
        fb.saveCurrentBindingsAndBuffers();
      }
      const framebuffer = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, zbt.getHandle(), 0);
      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
        texels = new Uint8Array(width * height * 4);
        gl.viewport(0, 0, width, height);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, texels);
      }
      if (fb) {
        fb.restorePreviousBindingsAndBuffers();
      }
      gl.deleteFramebuffer(framebuffer);
    }
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (model.renderable.getUseZValues()) {
        renderPass.requestDepth();
      }
    }
  };
}
var DEFAULT_VALUES47 = {};
function extend51(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES47, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkOpenGLPixelSpaceCallbackMapper(publicAPI, model);
}
var newInstance50 = newInstance(extend51, "vtkOpenGLPixelSpaceCallbackMapper");
var vtkPixelSpaceCallbackMapper = {
  newInstance: newInstance50,
  extend: extend51
};
registerOverride("vtkPixelSpaceCallbackMapper", newInstance50);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyData2DFS.glsl.js
var vtkPolyData2DFS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n";

// node_modules/@kitware/vtk.js/Rendering/OpenGL/glsl/vtkPolyData2DVS.glsl.js
var vtkPolyData2DVS = "//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n";

// node_modules/@kitware/vtk.js/Rendering/Core/Property2D/Constants.js
var DisplayLocation = {
  BACKGROUND: 0,
  FOREGROUND: 1
};
var Constants10 = {
  DisplayLocation
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/PolyDataMapper2D.js
var {
  primTypes: primTypes3
} = vtkHelper;
var {
  Filter: Filter4,
  Wrap: Wrap4
} = vtkOpenGLTexture$1;
var {
  vtkErrorMacro: vtkErrorMacro14
} = macro$1;
var StartEvent2 = {
  type: "StartEvent"
};
var EndEvent2 = {
  type: "EndEvent"
};
function vtkOpenGLPolyDataMapper2D(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLPolyDataMapper2D");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.openGLActor2D = publicAPI.getFirstAncestorOfType("vtkOpenGLActor2D");
      model._openGLRenderer = model.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(model._openGLRenderer.getRenderable().getActiveCamera(), model.openGLCamera);
    }
  };
  publicAPI.overlayPass = (prepass) => {
    if (prepass) {
      publicAPI.render();
    }
  };
  publicAPI.getShaderTemplate = (shaders, ren, actor) => {
    shaders.Vertex = vtkPolyData2DVS;
    shaders.Fragment = vtkPolyData2DFS;
    shaders.Geometry = "";
  };
  publicAPI.render = () => {
    const ctx = model._openGLRenderWindow.getContext();
    if (model.context !== ctx) {
      model.context = ctx;
      for (let i = primTypes3.Start; i < primTypes3.End; i++) {
        model.primitives[i].setOpenGLRenderWindow(model._openGLRenderWindow);
      }
    }
    const actor = model.openGLActor2D.getRenderable();
    const ren = model._openGLRenderer.getRenderable();
    publicAPI.renderPiece(ren, actor);
  };
  publicAPI.renderPiece = (ren, actor) => {
    publicAPI.invokeEvent(StartEvent2);
    if (!model.renderable.getStatic()) {
      model.renderable.update();
    }
    model.currentInput = model.renderable.getInputData();
    publicAPI.invokeEvent(EndEvent2);
    if (!model.currentInput) {
      vtkErrorMacro14("No input!");
      return;
    }
    if (!model.currentInput.getPoints || !model.currentInput.getPoints().getNumberOfValues()) {
      return;
    }
    const gl = model.context;
    model._openGLRenderWindow.enableCullFace();
    gl.cullFace(gl.BACK);
    publicAPI.renderPieceStart(ren, actor);
    publicAPI.renderPieceDraw(ren, actor);
    publicAPI.renderPieceFinish(ren, actor);
  };
  publicAPI.renderPieceStart = (ren, actor) => {
    model.primitiveIDOffset = 0;
    if (model._openGLRenderer.getSelector()) {
      switch (model._openGLRenderer.getSelector().getCurrentPass()) {
        default:
          model._openGLRenderer.getSelector().renderProp(actor);
      }
    }
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.activate();
    }
    publicAPI.updateBufferObjects(ren, actor);
    model.lastBoundBO = null;
  };
  publicAPI.getNeedToRebuildShaders = (cellBO, ren, actor) => {
    if (cellBO.getShaderSourceTime().getMTime() < model.renderable.getMTime() || cellBO.getShaderSourceTime().getMTime() < model.currentInput.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.updateBufferObjects = (ren, actor) => {
    if (publicAPI.getNeedToRebuildBufferObjects(ren, actor)) {
      publicAPI.buildBufferObjects(ren, actor);
    }
  };
  publicAPI.getNeedToRebuildBufferObjects = (ren, actor) => {
    const vmtime = model.VBOBuildTime.getMTime();
    if (vmtime < publicAPI.getMTime() || vmtime < model._openGLRenderWindow.getMTime() || vmtime < model.renderable.getMTime() || vmtime < actor.getMTime() || vmtime < model.currentInput.getMTime() || model.renderable.getTransformCoordinate() && vmtime < ren.getMTime()) {
      return true;
    }
    return false;
  };
  publicAPI.buildBufferObjects = (ren, actor) => {
    const poly = model.currentInput;
    if (poly === null) {
      return;
    }
    model.renderable.mapScalars(poly, actor.getProperty().getOpacity());
    const c = model.renderable.getColorMapColors();
    const representation = actor.getProperty().getRepresentation();
    let tcoords = poly.getPointData().getTCoords();
    if (!model.openGLActor2D.getActiveTextures()) {
      tcoords = null;
    }
    let useTCoordsPerCell = false;
    if (model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
      useTCoordsPerCell = model.renderable.getAreScalarsMappedFromCells();
      if (!model.internalColorTexture) {
        model.internalColorTexture = vtkOpenGLTexture$1.newInstance({
          resizable: true
        });
      }
      const tex = model.internalColorTexture;
      tex.setMinificationFilter(Filter4.NEAREST);
      tex.setMagnificationFilter(Filter4.NEAREST);
      tex.setWrapS(Wrap4.CLAMP_TO_EDGE);
      tex.setWrapT(Wrap4.CLAMP_TO_EDGE);
      tex.setOpenGLRenderWindow(model._openGLRenderWindow);
      const input = model.renderable.getColorTextureMap();
      const ext = input.getExtent();
      const inScalars = input.getPointData().getScalars();
      tex.create2DFromRaw({
        width: ext[1] - ext[0] + 1,
        height: ext[3] - ext[2] + 1,
        numComps: inScalars.getNumberOfComponents(),
        dataType: inScalars.getDataType(),
        data: inScalars.getData()
      });
      tex.activate();
      tex.sendParameters();
      tex.deactivate();
    }
    const transformCoordinate = model.renderable.getTransformCoordinate();
    const view = ren.getRenderWindow().getViews()[0];
    const vsize = view.getViewportSize(ren);
    const toString = `${poly.getMTime()}A${representation}B${poly.getMTime()}C${c ? c.getMTime() : 1}D${tcoords ? tcoords.getMTime() : 1}E${transformCoordinate ? ren.getMTime() : 1}F${vsize}`;
    if (model.VBOBuildString !== toString) {
      let points = poly.getPoints();
      if (transformCoordinate) {
        const p = vtkPoints$1.newInstance();
        const numPts = points.getNumberOfPoints();
        p.setNumberOfPoints(numPts);
        const point2 = [];
        for (let i = 0; i < numPts; ++i) {
          points.getPoint(i, point2);
          transformCoordinate.setValue(point2);
          const v = transformCoordinate.getComputedDoubleViewportValue(ren);
          p.setPoint(i, v[0], v[1], 0);
        }
        points = p;
      }
      const options = {
        points,
        tcoords,
        colors: c,
        cellOffset: 0,
        useTCoordsPerCell,
        haveCellScalars: model.renderable.getAreScalarsMappedFromCells(),
        customAttributes: model.renderable.getCustomShaderAttributes().map((arrayName) => poly.getPointData().getArrayByName(arrayName))
      };
      options.cellOffset += model.primitives[primTypes3.Points].getCABO().createVBO(poly.getVerts(), "verts", representation, options);
      options.cellOffset += model.primitives[primTypes3.Lines].getCABO().createVBO(poly.getLines(), "lines", representation, options);
      options.cellOffset += model.primitives[primTypes3.Tris].getCABO().createVBO(poly.getPolys(), "polys", representation, options);
      options.cellOffset += model.primitives[primTypes3.TriStrips].getCABO().createVBO(poly.getStrips(), "strips", representation, options);
      model.VBOBuildTime.modified();
      model.VBOBuildString = toString;
    }
  };
  publicAPI.renderPieceDraw = (ren, actor) => {
    const representation = actor.getProperty().getRepresentation();
    const gl = model.context;
    gl.depthMask(true);
    for (let i = primTypes3.Start; i < primTypes3.End; i++) {
      const cabo = model.primitives[i].getCABO();
      if (cabo.getElementCount()) {
        model.lastBoundBO = model.primitives[i];
        model.primitiveIDOffset += model.primitives[i].drawArrays(ren, actor, representation, publicAPI);
      }
    }
  };
  publicAPI.renderPieceFinish = (ren, actor) => {
    if (model.lastBoundBO) {
      model.lastBoundBO.getVAO().release();
    }
    if (model.renderable.getColorTextureMap()) {
      model.internalColorTexture.deactivate();
    }
  };
  publicAPI.replaceShaderValues = (shaders, ren, actor) => {
    publicAPI.replaceShaderColor(shaders, ren, actor);
    publicAPI.replaceShaderTCoord(shaders, ren, actor);
    publicAPI.replaceShaderPicking(shaders, ren, actor);
    publicAPI.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.replaceShaderColor = (shaders, ren, actor) => {
    let VSSource = shaders.Vertex;
    let GSSource = shaders.Geometry;
    let FSSource = shaders.Fragment;
    let colorDec = ["uniform vec3 diffuseColorUniform;", "uniform float opacityUniform;"];
    let colorImpl = ["vec3 diffuseColor = diffuseColorUniform;", "float opacity = opacityUniform;"];
    if (model.lastBoundBO.getCABO().getColorComponents() !== 0) {
      colorDec = colorDec.concat(["varying vec4 vertexColorVSOutput;"]);
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Dec", ["attribute vec4 scalarColor;", "varying vec4 vertexColorVSOutput;"]).result;
      VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::Color::Impl", ["vertexColorVSOutput =  scalarColor;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Dec", ["in vec4 vertexColorVSOutput[];", "out vec4 vertexColorGSOutput;"]).result;
      GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::Color::Impl", ["vertexColorGSOutput = vertexColorVSOutput[i];"]).result;
      FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl.concat(["  diffuseColor = vertexColorVSOutput.rgb;", "  opacity = opacity*vertexColorVSOutput.a;"])).result;
    } else if (model.renderable.getAreScalarsMappedFromCells()) {
      colorImpl = colorImpl.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);", "  diffuseColor = texColor.rgb;", "  opacity = opacity*texColor.a;"]);
    }
    colorImpl = colorImpl.concat(["gl_FragData[0] = vec4(diffuseColor, opacity);"]);
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Dec", colorDec).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Color::Impl", colorImpl).result;
    shaders.Vertex = VSSource;
    shaders.Geometry = GSSource;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderTCoord = (shaders, ren, actor) => {
    if (model.lastBoundBO.getCABO().getTCoordOffset()) {
      let VSSource = shaders.Vertex;
      let GSSource = shaders.Geometry;
      let FSSource = shaders.Fragment;
      const tcdim = model.lastBoundBO.getCABO().getTCoordComponents();
      if (tcdim === 1) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", ["in float tcoordMC;", "out float tcoordVCVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", ["tcoordVCVSOutput = tcoordMC;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in float tcoordVCVSOutput[];\n", "out float tcoordVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, ["//VTK::TCoord::Impl", "tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["in float tcoordVCVSOutput;", "uniform sampler2D texture1;"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result;
      } else if (tcdim === 2) {
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordMC;", "out vec2 tcoordVCVSOutput;"]).result;
        VSSource = vtkShaderProgram$1.substitute(VSSource, "//VTK::TCoord::Impl", ["tcoordVCVSOutput = tcoordMC;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordVCVSOutput[];\n", "out vec2 tcoordVCGSOutput;"]).result;
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::TCoord::Impl", ["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Dec", ["in vec2 tcoordVCVSOutput;", "uniform sampler2D texture1;"]).result;
        FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::TCoord::Impl", ["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result;
      }
      if (model.renderable.getAreScalarsMappedFromCells()) {
        GSSource = vtkShaderProgram$1.substitute(GSSource, "//VTK::PrimID::Impl", ["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result;
      }
      shaders.Vertex = VSSource;
      shaders.Geometry = GSSource;
      shaders.Fragment = FSSource;
    }
  };
  publicAPI.replaceShaderPicking = (shaders, ren, actor) => {
    let FSSource = shaders.Fragment;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Dec", ["uniform vec3 mapperIndex;", "uniform int picking;"]).result;
    FSSource = vtkShaderProgram$1.substitute(FSSource, "//VTK::Picking::Impl", "  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result;
    shaders.Fragment = FSSource;
  };
  publicAPI.replaceShaderPositionVC = (shaders, ren, actor) => {
    model.lastBoundBO.replaceShaderPositionVC(shaders, ren, actor);
  };
  publicAPI.invokeShaderCallbacks = (cellBO, ren, actor) => {
    const listCallbacks = model.renderable.getViewSpecificProperties().ShadersCallbacks;
    if (listCallbacks) {
      listCallbacks.forEach((object) => {
        object.callback(object.userData, cellBO, ren, actor);
      });
    }
  };
  publicAPI.setMapperShaderParameters = (cellBO, ren, actor) => {
    if (cellBO.getProgram().isUniformUsed("PrimitiveIDOffset")) {
      cellBO.getProgram().setUniformi("PrimitiveIDOffset", model.primitiveIDOffset);
    }
    if (cellBO.getProgram().isAttributeUsed("vertexWC")) {
      if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "vertexWC", cellBO.getCABO().getVertexOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, 3, false)) {
        vtkErrorMacro14("Error setting vertexWC in shader VAO.");
      }
    }
    if (cellBO.getCABO().getElementCount() && (model.VBOBuildTime.getMTime() > cellBO.getAttributeUpdateTime().getMTime() || cellBO.getShaderSourceTime().getMTime() > cellBO.getAttributeUpdateTime().getMTime())) {
      model.renderable.getCustomShaderAttributes().forEach((attrName, idx) => {
        if (cellBO.getProgram().isAttributeUsed(`${attrName}MC`)) {
          if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), `${attrName}MC`, cellBO.getCABO().getCustomData()[idx].offset, cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getCustomData()[idx].components, false)) {
            vtkErrorMacro14(`Error setting ${attrName}MC in shader VAO.`);
          }
        }
      });
      if (cellBO.getProgram().isAttributeUsed("tcoordMC") && cellBO.getCABO().getTCoordOffset()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO(), "tcoordMC", cellBO.getCABO().getTCoordOffset(), cellBO.getCABO().getStride(), model.context.FLOAT, cellBO.getCABO().getTCoordComponents(), false)) {
          vtkErrorMacro14("Error setting tcoordMC in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("tcoordMC");
      }
      if (cellBO.getProgram().isAttributeUsed("scalarColor") && cellBO.getCABO().getColorComponents()) {
        if (!cellBO.getVAO().addAttributeArray(cellBO.getProgram(), cellBO.getCABO().getColorBO(), "scalarColor", cellBO.getCABO().getColorOffset(), cellBO.getCABO().getColorBOStride(), model.context.UNSIGNED_BYTE, 4, true)) {
          vtkErrorMacro14("Error setting scalarColor in shader VAO.");
        }
      } else {
        cellBO.getVAO().removeAttributeArray("scalarColor");
      }
      if (model.internalColorTexture && cellBO.getProgram().isUniformUsed("texture1")) {
        const texUnit = model.internalColorTexture.getTextureUnit();
        if (texUnit > -1) {
          cellBO.getProgram().setUniformi("texture1", model.internalColorTexture.getTextureUnit());
        }
      }
      const tus = model.openGLActor2D.getActiveTextures();
      if (tus) {
        for (let index2 = 0; index2 < tus.length; ++index2) {
          const tex = tus[index2];
          const texUnit = tex.getTextureUnit();
          const tname = `texture${texUnit + 1}`;
          if (cellBO.getProgram().isUniformUsed(tname)) {
            cellBO.getProgram().setUniformi(tname, texUnit);
          }
        }
      }
      cellBO.setMapperShaderParameters(ren, actor, model._openGLRenderer.getTiledSizeAndOrigin());
      const selector = model._openGLRenderer.getSelector();
      cellBO.getProgram().setUniform3fArray("mapperIndex", selector ? selector.getPropColorValue() : [0, 0, 0]);
      cellBO.getProgram().setUniformi("picking", selector ? selector.getCurrentPass() + 1 : 0);
    }
  };
  publicAPI.setPropertyShaderParameters = (cellBO, ren, actor) => {
    const c = model.renderable.getColorMapColors();
    if (!c || c.getNumberOfComponents() === 0) {
      const program = cellBO.getProgram();
      const ppty = actor.getProperty();
      const opacity = ppty.getOpacity();
      program.setUniformf("opacityUniform", opacity);
      const dColor = ppty.getColor();
      program.setUniform3fArray("diffuseColorUniform", dColor);
    }
  };
  publicAPI.setLightingShaderParameters = (cellBO, ren, actor) => {
  };
  function safeMatrixMultiply(matrixArray, matrixType, tmpMat) {
    matrixType.identity(tmpMat);
    return matrixArray.reduce((res, matrix, index2) => {
      if (index2 === 0) {
        return matrix ? matrixType.copy(res, matrix) : matrixType.identity(res);
      }
      return matrix ? matrixType.multiply(res, res, matrix) : res;
    }, tmpMat);
  }
  publicAPI.setCameraShaderParameters = (cellBO, ren, actor) => {
    const program = cellBO.getProgram();
    const shiftScaleEnabled = cellBO.getCABO().getCoordShiftAndScaleEnabled();
    const inverseShiftScaleMatrix = shiftScaleEnabled ? cellBO.getCABO().getInverseShiftAndScaleMatrix() : null;
    const view = ren.getRenderWindow().getViews()[0];
    const size = view.getViewportSize(ren);
    const vport = ren.getViewport();
    const actorPos = actor.getActualPositionCoordinate().getComputedDoubleViewportValue(ren);
    const tileViewport = [0, 0, 1, 1];
    const visVP = [0, 0, 1, 1];
    visVP[0] = vport[0] >= tileViewport[0] ? vport[0] : tileViewport[0];
    visVP[1] = vport[1] >= tileViewport[1] ? vport[1] : tileViewport[1];
    visVP[2] = vport[2] <= tileViewport[2] ? vport[2] : tileViewport[2];
    visVP[3] = vport[3] <= tileViewport[3] ? vport[3] : tileViewport[3];
    if (visVP[0] >= visVP[2]) {
      return;
    }
    if (visVP[1] >= visVP[3]) {
      return;
    }
    size[0] = round(size[0] * (visVP[2] - visVP[0]) / (vport[2] - vport[0]));
    size[1] = round(size[1] * (visVP[3] - visVP[1]) / (vport[3] - vport[1]));
    const winSize = model._openGLRenderer.getParent().getSize();
    const xoff = round(actorPos[0] - (visVP[0] - vport[0]) * winSize[0]);
    const yoff = round(actorPos[1] - (visVP[1] - vport[1]) * winSize[1]);
    const left = -xoff;
    let right = -xoff + size[0];
    const bottom = -yoff;
    let top = -yoff + size[1];
    if (left === right) {
      right = left + 1;
    }
    if (bottom === top) {
      top = bottom + 1;
    }
    const tmpMat4 = mat4_exports.identity(new Float64Array(16));
    tmpMat4[0] = 2 / (right - left);
    tmpMat4[1 * 4 + 1] = 2 / (top - bottom);
    tmpMat4[0 * 4 + 3] = -1 * (right + left) / (right - left);
    tmpMat4[1 * 4 + 3] = -1 * (top + bottom) / (top - bottom);
    tmpMat4[2 * 4 + 2] = 0;
    tmpMat4[2 * 4 + 3] = actor.getProperty().getDisplayLocation() === DisplayLocation.FOREGROUND ? -1 : 1;
    tmpMat4[3 * 4 + 3] = 1;
    mat4_exports.transpose(tmpMat4, tmpMat4);
    program.setUniformMatrix("WCVCMatrix", safeMatrixMultiply([tmpMat4, inverseShiftScaleMatrix], mat4_exports, model.tmpMat4));
  };
  publicAPI.getAllocatedGPUMemoryInBytes = () => {
    let memUsed = 0;
    model.primitives.forEach((prim) => {
      memUsed += prim.getAllocatedGPUMemoryInBytes();
    });
    return memUsed;
  };
}
var DEFAULT_VALUES48 = {
  context: null,
  VBOBuildTime: 0,
  VBOBuildString: null,
  primitives: null,
  primTypes: null,
  shaderRebuildString: null
};
function extend52(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES48, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementReplaceShaderCoincidentOffset(publicAPI, model, initialValues);
  vtkReplacementShaderMapper.implementBuildShadersWithReplacements(publicAPI, model, initialValues);
  model.primitives = [];
  model.primTypes = primTypes3;
  model.tmpMat4 = mat4_exports.identity(new Float64Array(16));
  for (let i = primTypes3.Start; i < primTypes3.End; i++) {
    model.primitives[i] = vtkHelper.newInstance();
    model.primitives[i].setPrimitiveType(i);
    model.primitives[i].set({
      lastLightComplexity: 0,
      lastLightCount: 0,
      lastSelectionPass: false
    }, true);
  }
  setGet(publicAPI, model, ["context"]);
  model.VBOBuildTime = {};
  obj(model.VBOBuildTime, {
    mtime: 0
  });
  vtkOpenGLPolyDataMapper2D(publicAPI, model);
}
var newInstance51 = newInstance(extend52, "vtkOpenGLPolyDataMapper2D");
var vtkPolyDataMapper2D = {
  newInstance: newInstance51,
  extend: extend52
};
registerOverride("vtkMapper2D", newInstance51);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Renderer.js
var {
  vtkDebugMacro: vtkDebugMacro3
} = macro$1;
function vtkOpenGLRenderer(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLRenderer");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getActiveCamera());
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps(), true);
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.updateLights = () => {
    let count2 = 0;
    const lights = model.renderable.getLightsByReference();
    for (let index2 = 0; index2 < lights.length; ++index2) {
      if (lights[index2].getSwitch() > 0) {
        count2++;
      }
    }
    if (!count2) {
      vtkDebugMacro3("No lights are on, creating one.");
      model.renderable.createLight();
    }
    return count2;
  };
  publicAPI.zBufferPass = (prepass) => {
    if (prepass) {
      let clearMask = 0;
      const gl = model.context;
      if (!model.renderable.getTransparent()) {
        model.context.clearColor(1, 0, 0, 1);
        clearMask |= gl.COLOR_BUFFER_BIT;
      }
      if (!model.renderable.getPreserveDepthBuffer()) {
        gl.clearDepth(1);
        clearMask |= gl.DEPTH_BUFFER_BIT;
        model.context.depthMask(true);
      }
      const ts = publicAPI.getTiledSizeAndOrigin();
      gl.enable(gl.SCISSOR_TEST);
      gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
      gl.colorMask(true, true, true, true);
      if (clearMask) {
        gl.clear(clearMask);
      }
      gl.enable(gl.DEPTH_TEST);
    }
  };
  publicAPI.opaqueZBufferPass = (prepass) => publicAPI.zBufferPass(prepass);
  publicAPI.cameraPass = (prepass) => {
    if (prepass) {
      publicAPI.clear();
    }
  };
  publicAPI.getAspectRatio = () => {
    const size = model._parent.getSizeByReference();
    const viewport = model.renderable.getViewportByReference();
    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
  };
  publicAPI.getTiledSizeAndOrigin = () => {
    const vport = model.renderable.getViewportByReference();
    const tileViewPort = [0, 0, 1, 1];
    const vpu = vport[0] - tileViewPort[0];
    const vpv = vport[1] - tileViewPort[1];
    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    const lowerLeftU = Math.round(ndvp[0]);
    const lowerLeftV = Math.round(ndvp[1]);
    const vpu2 = vport[2] - tileViewPort[0];
    const vpv2 = vport[3] - tileViewPort[1];
    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);
    let usize = Math.round(ndvp2[0]) - lowerLeftU;
    let vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.clear = () => {
    let clearMask = 0;
    const gl = model.context;
    if (!model.renderable.getTransparent()) {
      const background = model.renderable.getBackgroundByReference();
      gl.clearColor(background[0], background[1], background[2], background[3]);
      clearMask |= gl.COLOR_BUFFER_BIT;
    }
    if (!model.renderable.getPreserveDepthBuffer()) {
      gl.clearDepth(1);
      clearMask |= gl.DEPTH_BUFFER_BIT;
      gl.depthMask(true);
    }
    gl.colorMask(true, true, true, true);
    const ts = publicAPI.getTiledSizeAndOrigin();
    gl.enable(gl.SCISSOR_TEST);
    gl.scissor(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    gl.viewport(ts.lowerLeftU, ts.lowerLeftV, ts.usize, ts.vsize);
    if (clearMask) {
      gl.clear(clearMask);
    }
    gl.enable(gl.DEPTH_TEST);
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
    if (model.renderable) {
      model.renderable.getViewProps().forEach((prop) => {
        prop.modified();
      });
    }
  };
  publicAPI.setOpenGLRenderWindow = (rw) => {
    if (model._openGLRenderWindow === rw) {
      return;
    }
    publicAPI.releaseGraphicsResources();
    model._openGLRenderWindow = rw;
    model.context = null;
    if (rw) {
      model.context = model._openGLRenderWindow.getContext();
    }
  };
}
var DEFAULT_VALUES49 = {
  context: null,
  _openGLRenderWindow: null,
  selector: null
};
function extend53(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES49, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  get(publicAPI, model, ["shaderCache"]);
  setGet(publicAPI, model, ["selector"]);
  moveToProtected(publicAPI, model, ["openGLRenderWindow"]);
  vtkOpenGLRenderer(publicAPI, model);
}
var newInstance52 = newInstance(extend53, "vtkOpenGLRenderer");
var vtkRenderer = {
  newInstance: newInstance52,
  extend: extend53
};
registerOverride("vtkRenderer", newInstance52);

// node_modules/@kitware/vtk.js/Rendering/Core/ScalarBarActor/Constants.js
var Orientation = {
  HORIZONTAL: "horizontal",
  VERTICAL: "vertical",
  AUTO: "auto"
};
var Constants11 = {
  Orientation
};

// node_modules/@kitware/vtk.js/Rendering/Core/ScalarBarActor.js
var {
  VectorMode: VectorMode4
} = vtkScalarsToColors$1;
var {
  Orientation: Orientation2
} = Constants11;
function applyTextStyle2(ctx, style, defaultFontSize) {
  ctx.strokeStyle = style.strokeColor;
  ctx.lineWidth = style.strokeSize;
  ctx.fillStyle = style.fontColor;
  const fontSize = style.fontSize ?? defaultFontSize;
  ctx.font = `${style.fontStyle} ${fontSize}px ${style.fontFamily}`;
}
function defaultAutoLayout(publicAPI, model) {
  return (helper) => {
    const lastSize = helper.getLastSize();
    const xAxisAdjust = (lastSize[0] / 700) ** 0.8;
    const yAxisAdjust = (lastSize[1] / 700) ** 0.8;
    const minAdjust = Math.min(xAxisAdjust, yAxisAdjust);
    const axisTextStyle = helper.getAxisTextStyle();
    const tickTextStyle = helper.getTickTextStyle();
    Object.assign(axisTextStyle, model.axisTextStyle);
    Object.assign(tickTextStyle, model.tickTextStyle);
    if (axisTextStyle.fontSize === void 0) {
      axisTextStyle.fontSize = Math.max(24 * minAdjust, 12);
    }
    if (tickTextStyle.fontSize === void 0) {
      if (helper.getLastAspectRatio() > 1) {
        tickTextStyle.fontSize = Math.max(20 * minAdjust, 10);
      } else {
        tickTextStyle.fontSize = Math.max(16 * minAdjust, 10);
      }
    }
    const textSizes = helper.updateTextureAtlas();
    helper.setTopTitle(false);
    const boxSize = helper.getBoxSizeByReference();
    let isVertical = false;
    if (model.orientation === Orientation2.VERTICAL) {
      isVertical = true;
    } else if (model.orientation === Orientation2.HORIZONTAL) {
      isVertical = false;
    } else {
      isVertical = helper.getLastAspectRatio() > 1;
    }
    if (isVertical) {
      helper.setTickLabelPixelOffset(0.3 * tickTextStyle.fontSize);
      if (textSizes.titleWidth <= textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) {
        helper.setTopTitle(true);
        helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);
        boxSize[0] = 2 * (textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];
        helper.setBoxPosition([0.98 - boxSize[0], -0.92]);
      } else {
        helper.setAxisTitlePixelOffset(0.2 * tickTextStyle.fontSize);
        boxSize[0] = 2 * (textSizes.titleHeight + helper.getAxisTitlePixelOffset() + textSizes.tickWidth + helper.getTickLabelPixelOffset() + 0.8 * tickTextStyle.fontSize) / lastSize[0];
        helper.setBoxPosition([0.99 - boxSize[0], -0.92]);
      }
      boxSize[1] = Math.max(1.2, Math.min(1.84 / yAxisAdjust, 1.84));
    } else {
      helper.setAxisTitlePixelOffset(1.2 * tickTextStyle.fontSize);
      helper.setTickLabelPixelOffset(0.1 * tickTextStyle.fontSize);
      const titleHeight = (
        // total offset from top of bar (includes ticks)
        2 * (0.8 * tickTextStyle.fontSize + textSizes.titleHeight + helper.getAxisTitlePixelOffset()) / lastSize[1]
      );
      const tickWidth = 2 * textSizes.tickWidth / lastSize[0];
      boxSize[0] = Math.min(1.9, Math.max(1.4, 1.4 * tickWidth * (helper.getTicks().length + 3)));
      boxSize[1] = titleHeight;
      helper.setBoxPosition([-0.5 * boxSize[0], -0.97]);
    }
    helper.recomputeBarSegments(textSizes);
  };
}
function defaultGenerateTicks2(publicApi, model) {
  return (helper) => {
    const lastTickBounds = helper.getLastTickBounds();
    const scale7 = linear2().domain([lastTickBounds[0], lastTickBounds[1]]);
    const ticks2 = scale7.ticks(5);
    const format2 = scale7.tickFormat(5);
    helper.setTicks(ticks2);
    helper.setTickStrings(ticks2.map(format2));
  };
}
function vtkScalarBarActorHelper(publicAPI, model) {
  model.classHierarchy.push("vtkScalarBarActorHelper");
  publicAPI.setRenderable = (renderable) => {
    if (model.renderable === renderable) {
      return;
    }
    model.renderable = renderable;
    model.barActor.setProperty(renderable.getProperty());
    model.barActor.setParentProp(renderable);
    model.barActor.setCoordinateSystemToDisplay();
    model.tmActor.setProperty(renderable.getProperty());
    model.tmActor.setParentProp(renderable);
    model.tmActor.setCoordinateSystemToDisplay();
    model.generateTicks = renderable.generateTicks;
    model.axisTextStyle = {
      ...renderable.getAxisTextStyle()
    };
    model.tickTextStyle = {
      ...renderable.getTickTextStyle()
    };
    publicAPI.modified();
  };
  publicAPI.updateAPISpecificData = (size, camera, renderWindow) => {
    if (model.lastSize[0] !== size[0] || model.lastSize[1] !== size[1]) {
      model.lastSize[0] = size[0];
      model.lastSize[1] = size[1];
      model.lastAspectRatio = size[0] / size[1];
      model.forceUpdate = true;
    }
    const scalarsToColors = model.renderable.getScalarsToColors();
    if (!scalarsToColors || !model.renderable.getVisibility()) {
      return;
    }
    model.barMapper.setLookupTable(scalarsToColors);
    model.camera = camera;
    model.renderWindow = renderWindow;
    if (model.forceUpdate || Math.max(scalarsToColors.getMTime(), publicAPI.getMTime(), model.renderable.getMTime()) > model.lastRebuildTime.getMTime()) {
      const range2 = scalarsToColors.getMappingRange();
      model.lastTickBounds = [...range2];
      model.renderable.getGenerateTicks()(publicAPI);
      if (model.renderable.getAutomated()) {
        model.renderable.getAutoLayout()(publicAPI);
      } else {
        model.axisTextStyle = {
          ...model.renderable.getAxisTextStyle()
        };
        model.tickTextStyle = {
          ...model.renderable.getTickTextStyle()
        };
        model.barPosition = [...model.renderable.getBarPosition()];
        model.barSize = [...model.renderable.getBarSize()];
        model.boxPosition = [...model.renderable.getBoxPosition()];
        model.boxSize = [...model.renderable.getBoxSize()];
        model.axisTitlePixelOffset = model.renderable.getAxisTitlePixelOffset();
        model.tickLabelPixelOffset = model.renderable.getTickLabelPixelOffset();
        const textSizes = publicAPI.updateTextureAtlas();
        publicAPI.recomputeBarSegments(textSizes);
      }
      publicAPI.updatePolyDataForLabels();
      publicAPI.updatePolyDataForBarSegments();
      model.lastRebuildTime.modified();
      model.forceUpdate = false;
    }
  };
  publicAPI.updateTextureAtlas = () => {
    model.tmContext.textBaseline = "bottom";
    model.tmContext.textAlign = "left";
    const results = {};
    const newTmAtlas = /* @__PURE__ */ new Map();
    let maxWidth = 0;
    let totalHeight = 1;
    applyTextStyle2(model.tmContext, model.axisTextStyle, 18);
    let metrics = model.tmContext.measureText(model.renderable.getAxisLabel());
    let entry = {
      height: metrics.actualBoundingBoxAscent + 2,
      startingHeight: totalHeight,
      width: metrics.width + 2,
      textStyle: model.axisTextStyle
    };
    newTmAtlas.set(model.renderable.getAxisLabel(), entry);
    totalHeight += entry.height;
    maxWidth = entry.width;
    results.titleWidth = entry.width;
    results.titleHeight = entry.height;
    results.tickWidth = 0;
    results.tickHeight = 0;
    applyTextStyle2(model.tmContext, model.tickTextStyle, 14);
    const strings = [...publicAPI.getTickStrings(), "NaN", "Below", "Above"];
    for (let t = 0; t < strings.length; t++) {
      if (!newTmAtlas.has(strings[t])) {
        metrics = model.tmContext.measureText(strings[t]);
        entry = {
          height: metrics.actualBoundingBoxAscent + 2,
          startingHeight: totalHeight,
          width: metrics.width + 2,
          textStyle: model.tickTextStyle
        };
        newTmAtlas.set(strings[t], entry);
        totalHeight += entry.height;
        if (maxWidth < entry.width) {
          maxWidth = entry.width;
        }
        if (results.tickWidth < entry.width) {
          results.tickWidth = entry.width;
        }
        if (results.tickHeight < entry.height) {
          results.tickHeight = entry.height;
        }
      }
    }
    maxWidth = nearestPowerOfTwo(maxWidth);
    totalHeight = nearestPowerOfTwo(totalHeight);
    newTmAtlas.forEach((value) => {
      value.tcoords = [0, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight - value.height) / totalHeight, value.width / maxWidth, (totalHeight - value.startingHeight) / totalHeight, 0, (totalHeight - value.startingHeight) / totalHeight];
    });
    model.tmCanvas.width = maxWidth;
    model.tmCanvas.height = totalHeight;
    model.tmContext.textBaseline = "bottom";
    model.tmContext.textAlign = "left";
    model.tmContext.clearRect(0, 0, maxWidth, totalHeight);
    newTmAtlas.forEach((value, key) => {
      const defaultSize = value.textStyle === model.axisTextStyle ? 18 : 14;
      applyTextStyle2(model.tmContext, value.textStyle, defaultSize);
      model.tmContext.fillText(key, 1, value.startingHeight + value.height - 1);
    });
    model.tmTexture.setCanvas(model.tmCanvas);
    model.tmTexture.modified();
    model._tmAtlas = newTmAtlas;
    return results;
  };
  publicAPI.computeBarSize = (textSizes) => {
    model.vertical = model.boxSize[1] > model.boxSize[0];
    const tickHeight = 2 * textSizes.tickHeight / model.lastSize[1];
    const segSize = [1, 1];
    if (model.vertical) {
      const tickWidth = 2 * (textSizes.tickWidth + model.tickLabelPixelOffset) / model.lastSize[0];
      if (model.topTitle) {
        const titleHeight = 2 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];
        model.barSize[0] = model.boxSize[0] - tickWidth;
        model.barSize[1] = model.boxSize[1] - titleHeight;
      } else {
        const titleWidth = 2 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[0];
        model.barSize[0] = model.boxSize[0] - titleWidth - tickWidth;
        model.barSize[1] = model.boxSize[1];
      }
      model.barPosition[0] = model.boxPosition[0] + tickWidth;
      model.barPosition[1] = model.boxPosition[1];
      segSize[1] = tickHeight;
    } else {
      const tickWidth = (2 * textSizes.tickWidth - 8) / model.lastSize[0];
      const titleHeight = 2 * (textSizes.titleHeight + model.axisTitlePixelOffset) / model.lastSize[1];
      model.barSize[0] = model.boxSize[0];
      model.barPosition[0] = model.boxPosition[0];
      model.barSize[1] = model.boxSize[1] - titleHeight;
      model.barPosition[1] = model.boxPosition[1];
      segSize[0] = tickWidth;
    }
    return segSize;
  };
  publicAPI.recomputeBarSegments = (textSizes) => {
    var _a, _b, _c, _d;
    const segSize = publicAPI.computeBarSize(textSizes);
    model.barSegments = [];
    const startPos = [0, 0];
    const barAxis = model.vertical ? 1 : 0;
    const segSpace = model.vertical ? 0.01 : 0.02;
    function pushSeg(title, scalars) {
      model.barSegments.push({
        corners: [[...startPos], [startPos[0] + segSize[0], startPos[1]], [startPos[0] + segSize[0], startPos[1] + segSize[1]], [startPos[0], startPos[1] + segSize[1]]],
        scalars,
        title
      });
      startPos[barAxis] += segSize[barAxis] + segSpace;
    }
    if (model.renderable.getDrawNanAnnotation() && model.renderable.getScalarsToColors().getNanColor()) {
      pushSeg("NaN", [NaN, NaN, NaN, NaN]);
    }
    if (model.renderable.getDrawBelowRangeSwatch() && ((_b = (_a = model.renderable.getScalarsToColors()).getUseBelowRangeColor) == null ? void 0 : _b.call(_a))) {
      pushSeg("Below", [-0.1, -0.1, -0.1, -0.1]);
    }
    const haveAbove = (_d = (_c = model.renderable.getScalarsToColors()).getUseAboveRangeColor) == null ? void 0 : _d.call(_c);
    startPos[barAxis] += segSpace;
    const oldSegSize = segSize[barAxis];
    segSize[barAxis] = haveAbove ? 1 - 2 * segSpace - segSize[barAxis] - startPos[barAxis] : 1 - segSpace - startPos[barAxis];
    pushSeg("ticks", model.vertical ? [0, 0, 0.995, 0.995] : [0, 0.995, 0.995, 0]);
    if (model.renderable.getDrawAboveRangeSwatch() && haveAbove) {
      segSize[barAxis] = oldSegSize;
      startPos[barAxis] += segSpace;
      pushSeg("Above", [1.1, 1.1, 1.1, 1.1]);
    }
  };
  const tmp2v32 = new Float64Array(3);
  publicAPI.createPolyDataForOneLabel = (text, pos, alignment, orientation, offset, results) => {
    const value = model._tmAtlas.get(text);
    if (!value) {
      return;
    }
    let ptIdx = results.ptIdx;
    let cellIdx = results.cellIdx;
    tmp2v32[0] = (0.5 * pos[0] + 0.5) * model.lastSize[0];
    tmp2v32[1] = (0.5 * pos[1] + 0.5) * model.lastSize[1];
    tmp2v32[2] = pos[2];
    tmp2v32[0] += offset[0];
    tmp2v32[1] += offset[1];
    const textSize = [];
    const textAxes = orientation === "vertical" ? [1, 0] : [0, 1];
    if (orientation === "vertical") {
      textSize[0] = value.width;
      textSize[1] = -value.height;
      if (alignment[0] === "middle") {
        tmp2v32[1] -= value.width / 2;
      } else if (alignment[0] === "right") {
        tmp2v32[1] -= value.width;
      }
      if (alignment[1] === "middle") {
        tmp2v32[0] += value.height / 2;
      } else if (alignment[1] === "top") {
        tmp2v32[0] += value.height;
      }
    } else {
      textSize[0] = value.width;
      textSize[1] = value.height;
      if (alignment[0] === "middle") {
        tmp2v32[0] -= value.width / 2;
      } else if (alignment[0] === "right") {
        tmp2v32[0] -= value.width;
      }
      if (alignment[1] === "middle") {
        tmp2v32[1] -= value.height / 2;
      } else if (alignment[1] === "top") {
        tmp2v32[1] -= value.height;
      }
    }
    results.points[ptIdx * 3] = tmp2v32[0];
    results.points[ptIdx * 3 + 1] = tmp2v32[1];
    results.points[ptIdx * 3 + 2] = tmp2v32[2];
    results.tcoords[ptIdx * 2] = value.tcoords[0];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[1];
    ptIdx++;
    tmp2v32[textAxes[0]] += textSize[0];
    results.points[ptIdx * 3] = tmp2v32[0];
    results.points[ptIdx * 3 + 1] = tmp2v32[1];
    results.points[ptIdx * 3 + 2] = tmp2v32[2];
    results.tcoords[ptIdx * 2] = value.tcoords[2];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[3];
    ptIdx++;
    tmp2v32[textAxes[1]] += textSize[1];
    results.points[ptIdx * 3] = tmp2v32[0];
    results.points[ptIdx * 3 + 1] = tmp2v32[1];
    results.points[ptIdx * 3 + 2] = tmp2v32[2];
    results.tcoords[ptIdx * 2] = value.tcoords[4];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[5];
    ptIdx++;
    tmp2v32[textAxes[0]] -= textSize[0];
    results.points[ptIdx * 3] = tmp2v32[0];
    results.points[ptIdx * 3 + 1] = tmp2v32[1];
    results.points[ptIdx * 3 + 2] = tmp2v32[2];
    results.tcoords[ptIdx * 2] = value.tcoords[6];
    results.tcoords[ptIdx * 2 + 1] = value.tcoords[7];
    ptIdx++;
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 3;
    results.polys[cellIdx * 4 + 3] = ptIdx - 2;
    cellIdx++;
    results.polys[cellIdx * 4] = 3;
    results.polys[cellIdx * 4 + 1] = ptIdx - 4;
    results.polys[cellIdx * 4 + 2] = ptIdx - 2;
    results.polys[cellIdx * 4 + 3] = ptIdx - 1;
    results.ptIdx += 4;
    results.cellIdx += 2;
  };
  const tmpv32 = new Float64Array(3);
  publicAPI.updatePolyDataForLabels = () => {
    const numLabels = publicAPI.getTickStrings().length + model.barSegments.length;
    const numPts = numLabels * 4;
    const numTris = numLabels * 2;
    const points = new Float64Array(numPts * 3);
    const polys = new Uint16Array(numTris * 4);
    const tcoords = new Float32Array(numPts * 2);
    const results = {
      ptIdx: 0,
      cellIdx: 0,
      polys,
      points,
      tcoords
    };
    const offsetAxis = model.vertical ? 0 : 1;
    const spacedAxis = model.vertical ? 1 : 0;
    tmpv32[2] = -0.99;
    const alignment = model.vertical ? ["right", "middle"] : ["middle", "bottom"];
    let dir = [0, 1];
    const tickOffsets = [0, 0];
    if (model.vertical) {
      tickOffsets[0] = -model.tickLabelPixelOffset;
      if (model.topTitle) {
        tmpv32[0] = model.boxPosition[0] + 0.5 * model.boxSize[0];
        tmpv32[1] = model.barPosition[1] + model.barSize[1];
        publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv32, ["middle", "bottom"], "horizontal", [0, model.axisTitlePixelOffset], results);
      } else {
        tmpv32[0] = model.barPosition[0] + model.barSize[0];
        tmpv32[1] = model.barPosition[1] + 0.5 * model.barSize[1];
        publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv32, ["middle", "top"], "vertical", [model.axisTitlePixelOffset, 0], results);
      }
      dir = [-1, 0];
    } else {
      tickOffsets[1] = model.tickLabelPixelOffset;
      tmpv32[0] = model.barPosition[0] + 0.5 * model.barSize[0];
      tmpv32[1] = model.barPosition[1] + model.barSize[1];
      publicAPI.createPolyDataForOneLabel(model.renderable.getAxisLabel(), tmpv32, ["middle", "bottom"], "horizontal", [0, model.axisTitlePixelOffset], results);
    }
    tmpv32[offsetAxis] = model.barPosition[offsetAxis] + (0.5 * dir[offsetAxis] + 0.5) * model.barSize[offsetAxis];
    tmpv32[spacedAxis] = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * 0.5;
    let tickSeg = null;
    for (let i = 0; i < model.barSegments.length; i++) {
      const seg = model.barSegments[i];
      if (seg.title === "ticks") {
        tickSeg = seg;
      } else {
        tmpv32[spacedAxis] = model.barPosition[spacedAxis] + 0.5 * model.barSize[spacedAxis] * (seg.corners[2][spacedAxis] + seg.corners[0][spacedAxis]);
        publicAPI.createPolyDataForOneLabel(seg.title, tmpv32, alignment, "horizontal", tickOffsets, results);
      }
    }
    const tickSegmentStart = model.barPosition[spacedAxis] + model.barSize[spacedAxis] * tickSeg.corners[0][spacedAxis];
    const tickSegmentSize = model.barSize[spacedAxis] * (tickSeg.corners[2][spacedAxis] - tickSeg.corners[0][spacedAxis]);
    const ticks2 = publicAPI.getTicks();
    const tickStrings = publicAPI.getTickStrings();
    const tickPositions = publicAPI.getTickPositions();
    for (let t = 0; t < ticks2.length; t++) {
      const tickPos = tickPositions ? tickPositions[t] : (ticks2[t] - model.lastTickBounds[0]) / (model.lastTickBounds[1] - model.lastTickBounds[0]);
      tmpv32[spacedAxis] = tickSegmentStart + tickSegmentSize * tickPos;
      publicAPI.createPolyDataForOneLabel(tickStrings[t], tmpv32, alignment, "horizontal", tickOffsets, results);
    }
    const tcoordDA = vtkDataArray$1.newInstance({
      numberOfComponents: 2,
      values: tcoords,
      name: "TextureCoordinates"
    });
    model.tmPolyData.getPointData().setTCoords(tcoordDA);
    model.tmPolyData.getPoints().setData(points, 3);
    model.tmPolyData.getPoints().modified();
    model.tmPolyData.getPolys().setData(polys, 1);
    model.tmPolyData.getPolys().modified();
    model.tmPolyData.modified();
  };
  publicAPI.updatePolyDataForBarSegments = () => {
    var _a, _b;
    const scalarsToColors = model.renderable.getScalarsToColors();
    let numberOfExtraColors = 0;
    if (model.renderable.getDrawNanAnnotation() && scalarsToColors.getNanColor()) {
      numberOfExtraColors += 1;
    }
    if (model.renderable.getDrawBelowRangeSwatch() && ((_a = scalarsToColors.getUseBelowRangeColor) == null ? void 0 : _a.call(scalarsToColors))) {
      numberOfExtraColors += 1;
    }
    if (model.renderable.getDrawAboveRangeSwatch() && ((_b = scalarsToColors.getUseAboveRangeColor) == null ? void 0 : _b.call(scalarsToColors))) {
      numberOfExtraColors += 1;
    }
    const numPts = 4 * (1 + numberOfExtraColors);
    const numQuads = numPts;
    let numComps = 1;
    if (scalarsToColors.getVectorMode() === VectorMode4.COMPONENT) {
      numComps = scalarsToColors.getVectorComponent() + 1;
    }
    const points = new Float64Array(numPts * 3);
    const cells = new Uint16Array(numQuads * 5);
    const scalars = new Float32Array(numPts * numComps);
    let ptIdx = 0;
    let cellIdx = 0;
    for (let i = 0; i < model.barSegments.length; i++) {
      const seg = model.barSegments[i];
      for (let e = 0; e < 4; e++) {
        tmpv32[0] = model.barPosition[0] + seg.corners[e][0] * model.barSize[0];
        tmpv32[1] = model.barPosition[1] + seg.corners[e][1] * model.barSize[1];
        points[ptIdx * 3] = (0.5 * tmpv32[0] + 0.5) * model.lastSize[0];
        points[ptIdx * 3 + 1] = (0.5 * tmpv32[1] + 0.5) * model.lastSize[1];
        points[ptIdx * 3 + 2] = tmpv32[2];
        for (let nc = 0; nc < numComps; nc++) {
          scalars[ptIdx * numComps + nc] = model.lastTickBounds[0] + seg.scalars[e] * (model.lastTickBounds[1] - model.lastTickBounds[0]);
        }
        ptIdx++;
      }
      cells[cellIdx * 5] = 4;
      cells[cellIdx * 5 + 1] = ptIdx - 4;
      cells[cellIdx * 5 + 2] = ptIdx - 3;
      cells[cellIdx * 5 + 3] = ptIdx - 2;
      cells[cellIdx * 5 + 4] = ptIdx - 1;
      cellIdx++;
    }
    const scalarsDA = vtkDataArray$1.newInstance({
      numberOfComponents: numComps,
      values: scalars,
      name: "Scalars"
    });
    model.polyData.getPointData().setScalars(scalarsDA);
    model.polyData.getPoints().setData(points, 3);
    model.polyData.getPoints().modified();
    model.polyData.getPolys().setData(cells, 1);
    model.polyData.getPolys().modified();
    model.polyData.modified();
  };
}
var newScalarBarActorHelper = macro.newInstance(function(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    renderable: null
  };
  Object.assign(model, {}, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["axisTitlePixelOffset", "tickLabelPixelOffset", "renderable", "topTitle", "ticks", "tickStrings", "tickPositions"]);
  macro.get(publicAPI, model, ["lastSize", "lastAspectRatio", "lastTickBounds", "axisTextStyle", "tickTextStyle", "barActor", "tmActor"]);
  macro.getArray(publicAPI, model, ["boxPosition", "boxSize"]);
  macro.setArray(publicAPI, model, ["boxPosition", "boxSize"], 2);
  model.forceUpdate = false;
  model.lastRebuildTime = {};
  macro.obj(model.lastRebuildTime, {
    mtime: 0
  });
  model.lastSize = [-1, -1];
  model.tmCanvas = document.createElement("canvas");
  model.tmContext = model.tmCanvas.getContext("2d");
  model._tmAtlas = /* @__PURE__ */ new Map();
  model.barMapper = vtkMapper$1.newInstance();
  model.barMapper.setInterpolateScalarsBeforeMapping(true);
  model.barMapper.setUseLookupTableScalarRange(true);
  model.polyData = vtkPolyData$1.newInstance();
  model.barMapper.setInputData(model.polyData);
  model.barActor = vtkActor$1.newInstance();
  model.barActor.setMapper(model.barMapper);
  model.tmPolyData = vtkPolyData$1.newInstance();
  model.tmMapper = vtkMapper$1.newInstance();
  model.tmMapper.setInputData(model.tmPolyData);
  model.tmTexture = vtkTexture$1.newInstance({
    resizable: true
  });
  model.tmTexture.setInterpolate(false);
  model.tmActor = vtkActor$1.newInstance({
    parentProp: publicAPI
  });
  model.tmActor.setMapper(model.tmMapper);
  model.tmActor.addTexture(model.tmTexture);
  model.barPosition = [0, 0];
  model.barSize = [0, 0];
  model.boxPosition = [0.88, -0.92];
  model.boxSize = [0.1, 1.1];
  model.lastTickBounds = [];
  vtkScalarBarActorHelper(publicAPI, model);
}, "vtkScalarBarActorHelper");
function vtkScalarBarActor(publicAPI, model) {
  model.classHierarchy.push("vtkScalarBarActor");
  publicAPI.setTickTextStyle = (tickStyle) => {
    model.tickTextStyle = {
      ...model.tickTextStyle,
      ...tickStyle
    };
    publicAPI.modified();
  };
  publicAPI.setAxisTextStyle = (axisStyle) => {
    model.axisTextStyle = {
      ...model.axisTextStyle,
      ...axisStyle
    };
    publicAPI.modified();
  };
  publicAPI.setOrientationToHorizontal = () => publicAPI.setOrientation(Orientation2.HORIZONTAL);
  publicAPI.setOrientationToVertical = () => publicAPI.setOrientation(Orientation2.VERTICAL);
  publicAPI.resetAutoLayoutToDefault = () => {
    publicAPI.setAutoLayout(defaultAutoLayout(publicAPI, model));
  };
  publicAPI.resetGenerateTicksToDefault = () => {
    publicAPI.setGenerateTicks(defaultGenerateTicks2());
  };
}
function defaultValues4(initialValues) {
  return {
    automated: true,
    autoLayout: null,
    axisLabel: "Scalar Value",
    barPosition: [0, 0],
    barSize: [0, 0],
    boxPosition: [0.88, -0.92],
    boxSize: [0.1, 1.1],
    scalarToColors: null,
    axisTitlePixelOffset: 36,
    axisTextStyle: {
      fontColor: "white",
      fontStyle: "normal",
      fontSize: void 0,
      fontFamily: "serif"
    },
    tickLabelPixelOffset: 14,
    tickTextStyle: {
      fontColor: "white",
      fontStyle: "normal",
      fontSize: void 0,
      fontFamily: "serif"
    },
    generateTicks: null,
    drawNanAnnotation: true,
    drawBelowRangeSwatch: true,
    drawAboveRangeSwatch: true,
    orientation: null,
    ...initialValues
  };
}
function extend54(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues4(initialValues));
  if (!model.autoLayout)
    model.autoLayout = defaultAutoLayout(publicAPI, model);
  if (!model.generateTicks)
    model.generateTicks = defaultGenerateTicks2();
  vtkActor$1.extend(publicAPI, model, initialValues);
  publicAPI.getProperty().setDiffuse(0);
  publicAPI.getProperty().setAmbient(1);
  macro.setGet(publicAPI, model, ["automated", "autoLayout", "axisTitlePixelOffset", "axisLabel", "scalarsToColors", "tickLabelPixelOffset", "generateTicks", "drawNanAnnotation", "drawBelowRangeSwatch", "drawAboveRangeSwatch", "orientation"]);
  macro.get(publicAPI, model, ["axisTextStyle", "tickTextStyle"]);
  macro.getArray(publicAPI, model, ["barPosition", "barSize", "boxPosition", "boxSize"]);
  macro.setArray(publicAPI, model, ["barPosition", "barSize", "boxPosition", "boxSize"], 2);
  vtkScalarBarActor(publicAPI, model);
}
var newInstance53 = macro.newInstance(extend54, "vtkScalarBarActor");
var vtkScalarBarActor$1 = {
  newInstance: newInstance53,
  extend: extend54,
  newScalarBarActorHelper,
  ...Constants11
};

// node_modules/@kitware/vtk.js/Rendering/OpenGL/ScalarBarActor.js
function vtkOpenGLScalarBarActor(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLScalarBarActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      if (!model.scalarBarActorHelper.getRenderable()) {
        model.scalarBarActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());
      publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model._openGLRenderer ? model._openGLRenderer.getRenderable().getActiveCamera() : null;
      const tsize = model._openGLRenderer.getTiledSizeAndOrigin();
      model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model._openGLRenderWindow.getRenderable());
    }
  };
}
var DEFAULT_VALUES50 = {};
function extend55(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES50, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.scalarBarActorHelper = vtkScalarBarActor$1.newScalarBarActorHelper();
  vtkOpenGLScalarBarActor(publicAPI, model);
}
var newInstance54 = newInstance(extend55, "vtkOpenGLScalarBarActor");
registerOverride("vtkScalarBarActor", newInstance54);

// node_modules/@kitware/vtk.js/Rendering/OpenGL/Skybox.js
var {
  vtkErrorMacro: vtkErrorMacro15
} = macro$1;
function vtkOpenGLSkybox(publicAPI, model) {
  model.classHierarchy.push("vtkOpenGLSkybox");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model._openGLRenderer = publicAPI.getFirstAncestorOfType("vtkOpenGLRenderer");
      model._openGLRenderWindow = model._openGLRenderer.getParent();
      model.context = model._openGLRenderWindow.getContext();
      model.tris.setOpenGLRenderWindow(model._openGLRenderWindow);
      model.openGLTexture.setOpenGLRenderWindow(model._openGLRenderWindow);
      const ren = model._openGLRenderer.getRenderable();
      model.openGLCamera = model._openGLRenderer.getViewNodeFor(ren.getActiveCamera(), model.openGLCamera);
    }
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      renderPass.incrementOpaqueActorCount();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass && !model._openGLRenderer.getSelector()) {
      publicAPI.updateBufferObjects();
      model.context.depthMask(true);
      model._openGLRenderWindow.getShaderCache().readyShaderProgram(model.tris.getProgram());
      model.openGLTexture.render(model._openGLRenderWindow);
      const texUnit = model.openGLTexture.getTextureUnit();
      model.tris.getProgram().setUniformi("sbtexture", texUnit);
      const ren = model._openGLRenderer.getRenderable();
      const keyMats = model.openGLCamera.getKeyMatrices(ren);
      const imat = new Float64Array(16);
      mat4_exports.invert(imat, keyMats.wcpc);
      model.tris.getProgram().setUniformMatrix("IMCPCMatrix", imat);
      if (model.lastFormat === "box") {
        const camPos = ren.getActiveCamera().getPosition();
        model.tris.getProgram().setUniform3f("camPos", camPos[0], camPos[1], camPos[2]);
      }
      model.tris.getVAO().bind();
      model.context.drawArrays(model.context.TRIANGLES, 0, model.tris.getCABO().getElementCount());
      model.tris.getVAO().release();
      model.openGLTexture.deactivate();
    }
  };
  publicAPI.updateBufferObjects = () => {
    if (!model.tris.getCABO().getElementCount()) {
      const ptsArray = new Float32Array(12);
      for (let i = 0; i < 4; i++) {
        ptsArray[i * 3] = i % 2 * 2 - 1;
        ptsArray[i * 3 + 1] = i > 1 ? 1 : -1;
        ptsArray[i * 3 + 2] = 1;
      }
      const points = vtkDataArray$1.newInstance({
        numberOfComponents: 3,
        values: ptsArray
      });
      points.setName("points");
      const cellArray = new Uint16Array(8);
      cellArray[0] = 3;
      cellArray[1] = 0;
      cellArray[2] = 1;
      cellArray[3] = 3;
      cellArray[4] = 3;
      cellArray[5] = 0;
      cellArray[6] = 3;
      cellArray[7] = 2;
      const cells = vtkDataArray$1.newInstance({
        numberOfComponents: 1,
        values: cellArray
      });
      model.tris.getCABO().createVBO(cells, "polys", Representation.SURFACE, {
        points,
        cellOffset: 0
      });
    }
    if (model.renderable.getFormat() !== model.lastFormat) {
      model.lastFormat = model.renderable.getFormat();
      if (model.lastFormat === "box") {
        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec3 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = wpos.xyz/wpos.w;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec3 TexCoords;
             uniform samplerCube sbtexture;
             uniform vec3 camPos;
             void main () {
               // skybox looks from inside out
               // which means we have to adjust
               // our tcoords. Otherwise text would
               // be flipped
               vec3 tc = normalize(TexCoords - camPos);
               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))
               {
                 tc = vec3(1.0, 1.0, -1.0) * tc;
               }
               else
               {
                 tc = vec3(-1.0, 1.0, 1.0) * tc;
               }
               gl_FragData[0] = textureCube(sbtexture, tc);
             }`, ""));
      }
      if (model.lastFormat === "background") {
        model.tris.setProgram(model._openGLRenderWindow.getShaderCache().readyShaderProgramArray(`//VTK::System::Dec
             attribute vec3 vertexMC;
             uniform mat4 IMCPCMatrix;
             varying vec2 TexCoords;
             void main () {
              gl_Position = vec4(vertexMC.xyz, 1.0);
              vec4 wpos = IMCPCMatrix * gl_Position;
              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;
             }`, `//VTK::System::Dec
             //VTK::Output::Dec
             varying vec2 TexCoords;
             uniform sampler2D sbtexture;
             void main () {
               gl_FragData[0] = texture2D(sbtexture, TexCoords);
             }`, ""));
      }
      model.tris.getShaderSourceTime().modified();
      model.tris.getVAO().bind();
      if (!model.tris.getVAO().addAttributeArray(model.tris.getProgram(), model.tris.getCABO(), "vertexMC", model.tris.getCABO().getVertexOffset(), model.tris.getCABO().getStride(), model.context.FLOAT, 3, model.context.FALSE)) {
        vtkErrorMacro15("Error setting vertexMC in shader VAO.");
      }
    }
    const tmaps = model.renderable.getTextures();
    if (!tmaps.length) {
      vtkErrorMacro15("vtkSkybox requires a texture map");
    }
    if (model.openGLTexture.getRenderable() !== tmaps[0]) {
      model.openGLTexture.releaseGraphicsResources(model._openGLRenderWindow);
      model.openGLTexture.setRenderable(tmaps[0]);
    }
  };
}
var DEFAULT_VALUES51 = {
  context: null
};
function extend56(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES51, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.openGLTexture = vtkOpenGLTexture$1.newInstance();
  model.tris = vtkHelper.newInstance();
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: mat3_exports.identity(new Float64Array(9)),
    mcwc: mat4_exports.identity(new Float64Array(16))
  };
  setGet(publicAPI, model, ["context"]);
  get(publicAPI, model, ["activeTextures"]);
  vtkOpenGLSkybox(publicAPI, model);
}
var newInstance55 = newInstance(extend56);
var vtkSkybox = {
  newInstance: newInstance55,
  extend: extend56
};
registerOverride("vtkSkybox", newInstance55);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ViewNodeFactory.js
var CLASS_MAPPING2 = /* @__PURE__ */ Object.create(null);
function registerOverride2(className, fn) {
  CLASS_MAPPING2[className] = fn;
}
function vtkWebGPUViewNodeFactory(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUViewNodeFactory");
}
var DEFAULT_VALUES52 = {};
function extend57(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES52, initialValues);
  model.overrides = CLASS_MAPPING2;
  vtkViewNodeFactory$1.extend(publicAPI, model, initialValues);
  vtkWebGPUViewNodeFactory(publicAPI, model);
}
var newInstance56 = macro.newInstance(extend57, "vtkWebGPUViewNodeFactory");
var vtkWebGPUViewNodeFactory$1 = {
  newInstance: newInstance56,
  extend: extend57
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Actor.js
var {
  CoordinateSystem: CoordinateSystem4
} = vtkProp$1;
function vtkWebGPUActor(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === void 0) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = (wgpuRen) => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = (wgpuRen) => {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      const mcwc = model.renderable.getMatrix();
      model.bufferShift[0] = mcwc[3];
      model.bufferShift[1] = mcwc[7];
      model.bufferShift[2] = mcwc[11];
      const center = wgpuRen.getStabilizedCenterByReference();
      if (model.renderable.getCoordinateSystem() === CoordinateSystem4.WORLD) {
        model.bufferShift[0] -= center[0];
        model.bufferShift[1] -= center[1];
        model.bufferShift[2] -= center[2];
      }
      mat4_exports.transpose(model.keyMatrices.bcwc, mcwc);
      if (model.renderable.getIsIdentity()) {
        mat4_exports.identity(model.keyMatrices.normalMatrix);
      } else {
        mat4_exports.copy(model.keyMatrices.normalMatrix, model.keyMatrices.bcwc);
        model.keyMatrices.normalMatrix[3] = 0;
        model.keyMatrices.normalMatrix[7] = 0;
        model.keyMatrices.normalMatrix[11] = 0;
        mat4_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
        mat4_exports.transpose(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      }
      mat4_exports.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);
      if (model.renderable.getCoordinateSystem() === CoordinateSystem4.WORLD) {
        mat4_exports.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      } else {
        mat4_exports.copy(model.keyMatrices.bcsc, model.keyMatrices.bcwc);
      }
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES53 = {
  keyMatricesTime: null,
  keyMatrices: null,
  propID: void 0,
  bufferShift: void 0
};
function extend58(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES53, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macro.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macro.get(publicAPI, model, ["propID", "keyMatricesTime"]);
  model.bufferShift = [0, 0, 0, 0];
  vtkWebGPUActor(publicAPI, model);
}
var newInstance57 = macro.newInstance(extend58);
registerOverride2("vtkActor", newInstance57);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Actor2D.js
var {
  CoordinateSystem: CoordinateSystem5
} = vtkProp$1;
function vtkWebGPUActor2D(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUActor2D");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType("vtkWebGPURenderWindow");
      if (model.propID === void 0) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.traverseOpaquePass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || !model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.traverseTranslucentPass = (renderPass) => {
    if (!model.renderable || !model.renderable.getNestedVisibility() || model.renderable.getIsOpaque() || model.WebGPURenderer.getSelector() && !model.renderable.getNestedPickable()) {
      return;
    }
    publicAPI.apply(renderPass, true);
    if (model.children[0]) {
      model.children[0].traverse(renderPass);
    }
    publicAPI.apply(renderPass, false);
  };
  publicAPI.queryPass = (prepass, renderPass) => {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }
      if (model.renderable.getIsOpaque()) {
        renderPass.incrementOpaqueActorCount();
      } else {
        renderPass.incrementTranslucentActorCount();
      }
    }
  };
  publicAPI.getBufferShift = (wgpuRen) => {
    publicAPI.getKeyMatrices(wgpuRen);
    return model.bufferShift;
  };
  publicAPI.getKeyMatrices = (wgpuRen) => {
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.bufferShift[0] = 0;
      model.bufferShift[1] = 0;
      model.bufferShift[2] = 0;
      const center = wgpuRen.getStabilizedCenterByReference();
      if (model.renderable.getCoordinateSystem() === CoordinateSystem5.WORLD) {
        model.bufferShift[0] -= center[0];
        model.bufferShift[1] -= center[1];
        model.bufferShift[2] -= center[2];
      }
      mat4_exports.identity(model.keyMatrices.bcwc);
      mat4_exports.identity(model.keyMatrices.normalMatrix);
      mat4_exports.translate(model.keyMatrices.bcwc, model.keyMatrices.bcwc, [-model.bufferShift[0], -model.bufferShift[1], -model.bufferShift[2]]);
      if (model.renderable.getCoordinateSystem() === CoordinateSystem5.WORLD) {
        mat4_exports.translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      } else {
        mat4_exports.copy(model.keyMatrices.bcsc, model.keyMatrices.bcwc);
      }
      model.keyMatricesTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES54 = {
  keyMatricesTime: null,
  keyMatrices: null,
  propID: void 0,
  bufferShift: void 0
};
function extend59(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES54, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macro.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macro.get(publicAPI, model, ["propID", "keyMatricesTime"]);
  model.bufferShift = [0, 0, 0, 0];
  vtkWebGPUActor2D(publicAPI, model);
}
var newInstance58 = macro.newInstance(extend59);
registerOverride2("vtkActor2D", newInstance58);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Camera.js
function vtkWebGPUCamera(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUCamera");
  publicAPI.getProjectionMatrix = (outMat, aspect, cRange, windowCenter) => {
    mat4_exports.identity(outMat);
    if (model.renderable.getParallelProjection()) {
      const parallelScale = model.renderable.getParallelScale();
      const width = parallelScale * aspect;
      const height = parallelScale;
      const xmin = (windowCenter[0] - 1) * width;
      const xmax = (windowCenter[0] + 1) * width;
      const ymin = (windowCenter[1] - 1) * height;
      const ymax = (windowCenter[1] + 1) * height;
      const xr = 1 / (xmax - xmin);
      const yr = 1 / (ymax - ymin);
      outMat[0] = 2 * xr;
      outMat[5] = 2 * yr;
      outMat[10] = 1 / (cRange[1] - cRange[0]);
      outMat[12] = (xmax + xmin) * xr;
      outMat[13] = (ymax + ymin) * yr;
      outMat[14] = cRange[1] / (cRange[1] - cRange[0]);
    } else {
      const tmp = Math.tan(Math.PI * model.renderable.getViewAngle() / 360);
      let width;
      let height;
      if (model.renderable.getUseHorizontalViewAngle() === true) {
        width = cRange[0] * tmp;
        height = cRange[0] * tmp / aspect;
      } else {
        width = cRange[0] * tmp * aspect;
        height = cRange[0] * tmp;
      }
      const xmin = (windowCenter[0] - 1) * width;
      const xmax = (windowCenter[0] + 1) * width;
      const ymin = (windowCenter[1] - 1) * height;
      const ymax = (windowCenter[1] + 1) * height;
      outMat[0] = 2 * cRange[0] / (xmax - xmin);
      outMat[5] = 2 * cRange[0] / (ymax - ymin);
      outMat[12] = (xmin + xmax) / (xmax - xmin);
      outMat[13] = (ymin + ymax) / (ymax - ymin);
      outMat[10] = 0;
      outMat[14] = cRange[0];
      outMat[11] = -1;
      outMat[15] = 0;
    }
  };
  publicAPI.convertToOpenGLDepth = (val) => {
    if (model.renderable.getParallelProjection()) {
      return 1 - val;
    }
    const cRange = model.renderable.getClippingRangeByReference();
    let zval = -cRange[0] / val;
    zval = (cRange[0] + cRange[1]) / (cRange[1] - cRange[0]) + 2 * cRange[0] * cRange[1] / (zval * (cRange[1] - cRange[0]));
    return 0.5 * zval + 0.5;
  };
  publicAPI.getKeyMatrices = (webGPURenderer) => {
    const ren = webGPURenderer.getRenderable();
    const webGPURenderWindow = webGPURenderer.getParent();
    if (Math.max(webGPURenderWindow.getMTime(), publicAPI.getMTime(), ren.getMTime(), model.renderable.getMTime(), webGPURenderer.getStabilizedTime()) > model.keyMatrixTime.getMTime()) {
      const wcvc = model.renderable.getViewMatrix();
      mat4_exports.copy(model.keyMatrices.normalMatrix, wcvc);
      model.keyMatrices.normalMatrix[3] = 0;
      model.keyMatrices.normalMatrix[7] = 0;
      model.keyMatrices.normalMatrix[11] = 0;
      mat4_exports.invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      mat4_exports.transpose(model.keyMatrices.wcvc, wcvc);
      const center = webGPURenderer.getStabilizedCenterByReference();
      mat4_exports.translate(model.keyMatrices.scvc, model.keyMatrices.wcvc, center);
      const aspectRatio = webGPURenderer.getAspectRatio();
      const cRange = model.renderable.getClippingRangeByReference();
      publicAPI.getProjectionMatrix(model.keyMatrices.vcpc, aspectRatio, cRange, model.renderable.getWindowCenterByReference());
      mat4_exports.multiply(model.keyMatrices.scpc, model.keyMatrices.vcpc, model.keyMatrices.scvc);
      mat4_exports.invert(model.keyMatrices.pcsc, model.keyMatrices.scpc);
      model.keyMatrixTime.modified();
    }
    return model.keyMatrices;
  };
}
var DEFAULT_VALUES55 = {
  keyMatrixTime: null,
  keyMatrices: null
};
function extend60(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES55, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  macro.obj(model.keyMatrixTime);
  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    vcpc: new Float64Array(16),
    pcsc: new Float64Array(16),
    wcvc: new Float64Array(16),
    scpc: new Float64Array(16),
    scvc: new Float64Array(16)
  };
  macro.setGet(publicAPI, model, ["keyMatrixTime"]);
  vtkWebGPUCamera(publicAPI, model);
}
var newInstance59 = macro.newInstance(extend60);
registerOverride2("vtkCamera", newInstance59);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/CubeAxesActor.js
function vtkWebGPUCubeAxesActor(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUCubeAxesActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      if (!model.CubeAxesActorHelper.getRenderable()) {
        model.CubeAxesActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.CubeAxesActorHelper.getTmActor());
      publicAPI.addMissingNode(model.renderable.getGridActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
      const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
      model.CubeAxesActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());
    }
  };
}
var DEFAULT_VALUES56 = {};
function extend61(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES56, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.CubeAxesActorHelper = vtkCubeAxesActor$1.newCubeAxesActorHelper();
  vtkWebGPUCubeAxesActor(publicAPI, model);
}
var newInstance60 = newInstance(extend61, "vtkWebGPUCubeAxesActor");
registerOverride2("vtkCubeAxesActor", newInstance60);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager/Constants.js
var BufferUsage = {
  Verts: 0,
  Lines: 1,
  Triangles: 2,
  Strips: 3,
  LinesFromStrips: 4,
  LinesFromTriangles: 5,
  Points: 6,
  UniformArray: 7,
  PointArray: 8,
  NormalsFromPoints: 9,
  Texture: 10,
  RawVertex: 11,
  Storage: 12,
  Index: 13
};
var PrimitiveTypes = {
  Start: 0,
  Points: 0,
  Lines: 1,
  Triangles: 2,
  TriangleStrips: 3,
  TriangleEdges: 4,
  TriangleStripEdges: 5,
  End: 6
};
var Constants12 = {
  BufferUsage,
  PrimitiveTypes
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Buffer.js
var forwarded = ["getMappedRange", "mapAsync", "unmap"];
function bufferSubData(device, destBuffer, destOffset, srcArrayBuffer) {
  const byteCount = srcArrayBuffer.byteLength;
  const srcBuffer = device.createBuffer({
    size: byteCount,
    /* eslint-disable no-undef */
    usage: GPUBufferUsage.COPY_SRC,
    /* eslint-enable no-undef */
    mappedAtCreation: true
  });
  const arrayBuffer = srcBuffer.getMappedRange(0, byteCount);
  new Uint8Array(arrayBuffer).set(new Uint8Array(srcArrayBuffer));
  srcBuffer.unmap();
  const encoder = device.createCommandEncoder();
  encoder.copyBufferToBuffer(srcBuffer, 0, destBuffer, destOffset, byteCount);
  const commandBuffer = encoder.finish();
  const queue = device.queue;
  queue.submit([commandBuffer]);
  srcBuffer.destroy();
}
function vtkWebGPUBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBuffer");
  publicAPI.create = (sizeInBytes, usage) => {
    model.handle = model.device.getHandle().createBuffer({
      size: sizeInBytes,
      usage,
      label: model.label
    });
    model.sizeInBytes = sizeInBytes;
    model.usage = usage;
  };
  publicAPI.write = (data) => {
    bufferSubData(model.device.getHandle(), model.handle, 0, data.buffer);
  };
  publicAPI.createAndWrite = (data, usage) => {
    const paddedSize = Math.ceil(data.byteLength / 4) * 4;
    model.handle = model.device.getHandle().createBuffer({
      size: paddedSize,
      usage,
      mappedAtCreation: true,
      label: model.label
    });
    model.sizeInBytes = paddedSize;
    model.usage = usage;
    new Uint8Array(model.handle.getMappedRange()).set(new Uint8Array(data.buffer));
    model.handle.unmap();
  };
  for (let i = 0; i < forwarded.length; i++) {
    publicAPI[forwarded[i]] = function() {
      return model.handle[forwarded[i]](...arguments);
    };
  }
}
var DEFAULT_VALUES57 = {
  device: null,
  handle: null,
  sizeInBytes: 0,
  strideInBytes: 0,
  arrayInformation: null,
  usage: null,
  label: null,
  sourceTime: null
};
function extend62(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES57, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["handle", "sizeInBytes", "usage"]);
  macro.setGet(publicAPI, model, ["strideInBytes", "device", "arrayInformation", "label", "sourceTime"]);
  vtkWebGPUBuffer(publicAPI, model);
}
var newInstance61 = macro.newInstance(extend62);
var vtkWebGPUBuffer$1 = {
  newInstance: newInstance61,
  extend: extend62,
  ...Constants12
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/IndexBuffer.js
var {
  Representation: Representation4
} = vtkProperty$1;
var {
  PrimitiveTypes: PrimitiveTypes2
} = Constants12;
var _LimitedMap = class {
  constructor() {
    this.keys = new Uint32Array(10);
    this.values = new Uint32Array(10);
    this.count = 0;
  }
  clear() {
    this.count = 0;
  }
  has(key) {
    for (let i = 0; i < this.count; i++) {
      if (this.keys[i] === key) {
        return true;
      }
    }
    return void 0;
  }
  get(key) {
    for (let i = 0; i < this.count; i++) {
      if (this.keys[i] === key) {
        return this.values[i];
      }
    }
    return void 0;
  }
  set(key, value) {
    if (this.count < 9) {
      this.keys[this.count] = key;
      this.values[this.count++] = value;
    }
  }
};
function getPrimitiveName(primType) {
  switch (primType) {
    case PrimitiveTypes2.Points:
      return "points";
    case PrimitiveTypes2.Lines:
      return "lines";
    case PrimitiveTypes2.Triangles:
    case PrimitiveTypes2.TriangleEdges:
      return "polys";
    case PrimitiveTypes2.TriangleStripEdges:
    case PrimitiveTypes2.TriangleStrips:
      return "strips";
    default:
      return "";
  }
}
function _getOrAddFlatId(state, ptId, cellId) {
  let flatId = state.pointIdToFlatId[ptId];
  if (flatId < 0) {
    flatId = state.flatId;
    state.pointIdToFlatId[ptId] = flatId;
    state.flatIdToPointId[state.flatId] = ptId;
    state.flatIdToCellId[state.flatId] = cellId;
    state.flatId++;
  }
  return flatId;
}
function fillCell(ptIds, cellId, state) {
  const numPtIds = ptIds.length;
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    let ptId2 = ptIds[ptIdx];
    if (state.cellProvokedMap.has(ptId2)) {
      state.ibo[state.iboId++] = state.cellProvokedMap.get(ptId2);
      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
        ptId2 = ptIds[ptIdx2 % numPtIds];
        const flatId2 = _getOrAddFlatId(state, ptId2, cellId);
        state.ibo[state.iboId++] = flatId2;
      }
      return;
    }
  }
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    let ptId2 = ptIds[ptIdx];
    if (!state.provokedPointIds[ptId2]) {
      let flatId2 = _getOrAddFlatId(state, ptId2, cellId);
      state.provokedPointIds[ptId2] = 1;
      state.cellProvokedMap.set(ptId2, flatId2);
      state.flatIdToCellId[flatId2] = cellId;
      state.ibo[state.iboId++] = flatId2;
      for (let ptIdx2 = ptIdx + 1; ptIdx2 < ptIdx + numPtIds; ptIdx2++) {
        ptId2 = ptIds[ptIdx2 % numPtIds];
        flatId2 = _getOrAddFlatId(state, ptId2, cellId);
        state.ibo[state.iboId++] = flatId2;
      }
      return;
    }
  }
  let ptId = ptIds[0];
  let flatId = state.flatId;
  state.cellProvokedMap.set(ptId, flatId);
  state.flatIdToPointId[state.flatId] = ptId;
  state.flatIdToCellId[state.flatId] = cellId;
  state.flatId++;
  state.ibo[state.iboId++] = flatId;
  for (let ptIdx2 = 1; ptIdx2 < numPtIds; ptIdx2++) {
    ptId = ptIds[ptIdx2];
    flatId = _getOrAddFlatId(state, ptId, cellId);
    state.ibo[state.iboId++] = flatId;
  }
}
function countCell(ptIds, cellId, state) {
  const numPtIds = ptIds.length;
  state.iboSize += numPtIds;
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    const ptId = ptIds[ptIdx];
    if (state.cellProvokedMap.has(ptId)) {
      return;
    }
  }
  for (let ptIdx = 0; ptIdx < numPtIds; ptIdx++) {
    const ptId = ptIds[ptIdx];
    if (!state.provokedPointIds[ptId]) {
      state.provokedPointIds[ptId] = 1;
      state.cellProvokedMap.set(ptId, 1);
      return;
    }
  }
  state.cellProvokedMap.set(ptIds[0], 1);
  state.extraPoints++;
}
var processCell;
var _single = new Uint32Array(1);
var _double = new Uint32Array(2);
var _triple = new Uint32Array(3);
var _indexCellBuilders = {
  // easy, every input point becomes an output point
  anythingToPoints(numPoints, cellPts, offset, cellId, state) {
    for (let i = 0; i < numPoints; ++i) {
      _single[0] = cellPts[offset + i];
      processCell(_single, cellId, state);
    }
  },
  linesToWireframe(numPoints, cellPts, offset, cellId, state) {
    for (let i = 0; i < numPoints - 1; ++i) {
      _double[0] = cellPts[offset + i];
      _double[1] = cellPts[offset + i + 1];
      processCell(_double, cellId, state);
    }
  },
  polysToWireframe(numPoints, cellPts, offset, cellId, state) {
    if (numPoints > 2) {
      for (let i = 0; i < numPoints; ++i) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + (i + 1) % numPoints];
        processCell(_double, cellId, state);
      }
    }
  },
  stripsToWireframe(numPoints, cellPts, offset, cellId, state) {
    if (numPoints > 2) {
      for (let i = 0; i < numPoints - 1; ++i) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + i + 1];
        processCell(_double, cellId, state);
      }
      for (let i = 0; i < numPoints - 2; i++) {
        _double[0] = cellPts[offset + i];
        _double[1] = cellPts[offset + i + 2];
        processCell(_double, cellId, state);
      }
    }
  },
  polysToSurface(npts, cellPts, offset, cellId, state) {
    for (let i = 0; i < npts - 2; i++) {
      _triple[0] = cellPts[offset];
      _triple[1] = cellPts[offset + i + 1];
      _triple[2] = cellPts[offset + i + 2];
      processCell(_triple, cellId, state);
    }
  },
  stripsToSurface(npts, cellPts, offset, cellId, state) {
    for (let i = 0; i < npts - 2; i++) {
      _triple[0] = cellPts[offset + i];
      _triple[1] = cellPts[offset + i + 1 + i % 2];
      _triple[2] = cellPts[offset + i + 1 + (i + 1) % 2];
      processCell(_triple, cellId, state);
    }
  }
};
function vtkWebGPUIndexBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUIndexBuffer");
  publicAPI.buildIndexBuffer = (req) => {
    const cellArray = req.cells;
    const primitiveType = req.primitiveType;
    const representation = req.representation;
    const cellOffset = req.cellOffset;
    const array2 = cellArray.getData();
    const cellArraySize = array2.length;
    const inRepName = getPrimitiveName(primitiveType);
    const numPts = req.numberOfPoints;
    const state = {
      provokedPointIds: new Uint8Array(numPts),
      // size is good
      extraPoints: 0,
      iboSize: 0,
      flatId: 0,
      iboId: 0,
      cellProvokedMap: new _LimitedMap()
    };
    let func = null;
    if (representation === Representation4.POINTS || primitiveType === PrimitiveTypes2.Points) {
      func = _indexCellBuilders.anythingToPoints;
    } else if (representation === Representation4.WIREFRAME || primitiveType === PrimitiveTypes2.Lines) {
      func = _indexCellBuilders[`${inRepName}ToWireframe`];
    } else {
      func = _indexCellBuilders[`${inRepName}ToSurface`];
    }
    processCell = countCell;
    let cellId = cellOffset || 0;
    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize; ) {
      state.cellProvokedMap.clear();
      func(array2[cellArrayIndex], array2, cellArrayIndex + 1, cellId, state);
      cellArrayIndex += array2[cellArrayIndex] + 1;
      cellId++;
    }
    if (numPts <= 65535) {
      state.flatIdToPointId = new Uint16Array(numPts + state.extraPoints);
    } else {
      state.flatIdToPointId = new Uint32Array(numPts + state.extraPoints);
    }
    if (numPts + state.extraPoints < 36863) {
      state.pointIdToFlatId = new Int16Array(numPts);
    } else {
      state.pointIdToFlatId = new Int32Array(numPts);
    }
    if (numPts + state.extraPoints <= 65535) {
      state.ibo = new Uint16Array(state.iboSize);
      req.format = "uint16";
    } else {
      state.ibo = new Uint32Array(state.iboSize);
      req.format = "uint32";
    }
    if (cellId <= 65535) {
      state.flatIdToCellId = new Uint16Array(numPts + state.extraPoints);
    } else {
      state.flatIdToCellId = new Uint32Array(numPts + state.extraPoints);
    }
    state.pointIdToFlatId.fill(-1);
    state.provokedPointIds.fill(0);
    processCell = fillCell;
    cellId = cellOffset || 0;
    for (let cellArrayIndex = 0; cellArrayIndex < cellArraySize; ) {
      state.cellProvokedMap.clear();
      func(array2[cellArrayIndex], array2, cellArrayIndex + 1, cellId, state);
      cellArrayIndex += array2[cellArrayIndex] + 1;
      cellId++;
    }
    delete state.provokedPointIds;
    delete state.pointIdToFlatId;
    req.nativeArray = state.ibo;
    model.flatIdToPointId = state.flatIdToPointId;
    model.flatIdToCellId = state.flatIdToCellId;
    model.flatSize = state.flatId;
    model.indexCount = state.iboId;
  };
}
var DEFAULT_VALUES58 = {
  flatIdToPointId: null,
  flatIdToCellId: null,
  flatSize: 0,
  indexCount: 0
};
function extend63(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES58, initialValues);
  vtkWebGPUBuffer$1.extend(publicAPI, model, initialValues);
  macro.setGet(publicAPI, model, ["flatIdToPointId", "flatIdToCellId", "flatSize", "indexCount"]);
  vtkWebGPUIndexBuffer(publicAPI, model);
}
var newInstance62 = macro.newInstance(extend63);
var vtkWebGPUIndexBuffer$1 = {
  newInstance: newInstance62,
  extend: extend63,
  ...Constants12
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/BufferManager.js
var {
  BufferUsage: BufferUsage2
} = Constants12;
var {
  vtkErrorMacro: vtkErrorMacro16
} = macro$1;
var {
  VtkDataTypes: VtkDataTypes5
} = vtkDataArray$1;
var STATIC11 = {};
function _getFormatForDataArray(dataArray) {
  let format2;
  switch (dataArray.getDataType()) {
    case VtkDataTypes5.UNSIGNED_CHAR:
      format2 = "uint8";
      break;
    case VtkDataTypes5.FLOAT:
      format2 = "float32";
      break;
    case VtkDataTypes5.UNSIGNED_INT:
      format2 = "uint32";
      break;
    case VtkDataTypes5.INT:
      format2 = "sint32";
      break;
    case VtkDataTypes5.DOUBLE:
      format2 = "float32";
      break;
    case VtkDataTypes5.UNSIGNED_SHORT:
      format2 = "uint16";
      break;
    case VtkDataTypes5.SHORT:
      format2 = "sin16";
      break;
    default:
      format2 = "float32";
      break;
  }
  switch (dataArray.getNumberOfComponents()) {
    case 2:
      format2 += "x2";
      break;
    case 3:
      if (!format2.includes("32")) {
        vtkErrorMacro16(`unsupported x3 type for ${format2}`);
      }
      format2 += "x3";
      break;
    case 4:
      format2 += "x4";
      break;
  }
  return format2;
}
function packArray(indexBuffer, inArrayData, numComp, outputType, options) {
  const result = {};
  const flatSize = indexBuffer.getFlatSize();
  if (!flatSize) {
    return result;
  }
  let shift = [0, 0, 0, 0];
  if (options.shift) {
    if (options.shift.length) {
      shift = options.shift;
    } else {
      shift.fill(options.shift);
    }
  }
  let scale7 = [1, 1, 1, 1];
  if (options.scale) {
    if (options.scale.length) {
      scale7 = options.scale;
    } else {
      scale7.fill(options.scale);
    }
  }
  const packExtra = Object.prototype.hasOwnProperty.call(options, "packExtra") ? options.packExtra : false;
  let addAPoint;
  let vboidx = 0;
  const stride = numComp + (packExtra ? 1 : 0);
  const packedVBO = newTypedArray(outputType, flatSize * stride);
  let flatIdMap = indexBuffer.getFlatIdToPointId();
  if (options.cellData) {
    flatIdMap = indexBuffer.getFlatIdToCellId();
  }
  if (numComp === 1) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale7[0] * inArrayData[i] + shift[0];
    };
  } else if (numComp === 2) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale7[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale7[1] * inArrayData[i + 1] + shift[1];
    };
  } else if (numComp === 3 && !packExtra) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale7[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale7[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale7[2] * inArrayData[i + 2] + shift[2];
    };
  } else if (numComp === 3 && packExtra) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale7[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale7[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale7[2] * inArrayData[i + 2] + shift[2];
      packedVBO[vboidx++] = scale7[3] * 1 + shift[3];
    };
  } else if (numComp === 4) {
    addAPoint = function addAPointFunc(i) {
      packedVBO[vboidx++] = scale7[0] * inArrayData[i] + shift[0];
      packedVBO[vboidx++] = scale7[1] * inArrayData[i + 1] + shift[1];
      packedVBO[vboidx++] = scale7[2] * inArrayData[i + 2] + shift[2];
      packedVBO[vboidx++] = scale7[3] * inArrayData[i + 3] + shift[3];
    };
  }
  for (let index2 = 0; index2 < flatSize; index2++) {
    const inArrayId = numComp * flatIdMap[index2];
    addAPoint(inArrayId);
  }
  result.nativeArray = packedVBO;
  return result;
}
function getNormal2(pointData, i0, i1, i2) {
  const v1 = [pointData[i2 * 3] - pointData[i1 * 3], pointData[i2 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i2 * 3 + 2] - pointData[i1 * 3 + 2]];
  const v2 = [pointData[i0 * 3] - pointData[i1 * 3], pointData[i0 * 3 + 1] - pointData[i1 * 3 + 1], pointData[i0 * 3 + 2] - pointData[i1 * 3 + 2]];
  const result = [];
  cross(v1, v2, result);
  normalize(result);
  return result;
}
function generateNormals(cellArray, pointArray) {
  const pointData = pointArray.getData();
  const cellArrayData = cellArray.getData();
  if (!cellArrayData || !pointData) {
    return null;
  }
  const packedVBO = new Int8Array(cellArray.getNumberOfCells() * 4);
  const size = cellArrayData.length;
  let vboidx = 0;
  for (let index2 = 0; index2 < size; ) {
    const normal = getNormal2(pointData, cellArrayData[index2 + 1], cellArrayData[index2 + 2], cellArrayData[index2 + 3]);
    packedVBO[vboidx++] = 127 * normal[0];
    packedVBO[vboidx++] = 127 * normal[1];
    packedVBO[vboidx++] = 127 * normal[2];
    packedVBO[vboidx++] = 127;
    index2 += cellArrayData[index2] + 1;
  }
  return packedVBO;
}
function vtkWebGPUBufferManager(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBufferManager");
  function _createBuffer(req) {
    if (req.dataArray && !req.nativeArray) {
      req.nativeArray = req.dataArray.getData();
    }
    let buffer;
    let gpuUsage;
    if (req.usage === BufferUsage2.Index) {
      buffer = vtkWebGPUIndexBuffer$1.newInstance({
        label: req.label
      });
      buffer.setDevice(model.device);
      gpuUsage = GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST;
      buffer.buildIndexBuffer(req);
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setArrayInformation([{
        format: req.format
      }]);
    }
    if (!buffer) {
      buffer = vtkWebGPUBuffer$1.newInstance({
        label: req.label
      });
      buffer.setDevice(model.device);
    }
    if (req.usage === BufferUsage2.UniformArray) {
      gpuUsage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.Storage) {
      gpuUsage = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.Texture) {
      gpuUsage = GPUBufferUsage.COPY_SRC;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
    }
    if (req.usage === BufferUsage2.PointArray) {
      gpuUsage = GPUBufferUsage.VERTEX;
      const arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
      const result = packArray(req.indexBuffer, req.dataArray.getData(), req.dataArray.getNumberOfComponents(), arrayType, {
        packExtra: req.packExtra,
        shift: req.shift,
        scale: req.scale,
        cellData: req.cellData,
        cellOffset: req.cellOffset
      });
      buffer.createAndWrite(result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format,
        interpolation: req.cellData ? "flat" : "perspective"
      }]);
    }
    if (req.usage === BufferUsage2.NormalsFromPoints) {
      gpuUsage = GPUBufferUsage.VERTEX;
      const arrayType = vtkWebGPUTypes.getNativeTypeFromBufferFormat(req.format);
      const normals = generateNormals(req.cells, req.dataArray);
      const result = packArray(req.indexBuffer, normals, 4, arrayType, {
        cellData: true
      });
      buffer.createAndWrite(result.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format,
        interpolation: "flat"
      }]);
    }
    if (req.usage === BufferUsage2.RawVertex) {
      gpuUsage = GPUBufferUsage.VERTEX;
      buffer.createAndWrite(req.nativeArray, gpuUsage);
      buffer.setStrideInBytes(vtkWebGPUTypes.getByteStrideFromBufferFormat(req.format));
      buffer.setArrayInformation([{
        offset: 0,
        format: req.format
      }]);
    }
    buffer.setSourceTime(req.time);
    return buffer;
  }
  publicAPI.hasBuffer = (hash) => model.device.hasCachedObject(hash);
  publicAPI.getBuffer = (req) => {
    if (req.hash) {
      return model.device.getCachedObject(req.hash, _createBuffer, req);
    }
    return _createBuffer(req);
  };
  publicAPI.getBufferForPointArray = (dataArray, indexBuffer) => {
    const format2 = _getFormatForDataArray(dataArray);
    const buffRequest = {
      hash: `${dataArray.getMTime()}I${indexBuffer.getMTime()}${format2}`,
      usage: BufferUsage2.PointArray,
      format: format2,
      dataArray,
      indexBuffer
    };
    return publicAPI.getBuffer(buffRequest);
  };
  publicAPI.getFullScreenQuadBuffer = () => {
    if (model.fullScreenQuadBuffer) {
      return model.fullScreenQuadBuffer;
    }
    model.fullScreenQuadBuffer = vtkWebGPUBuffer$1.newInstance();
    model.fullScreenQuadBuffer.setDevice(model.device);
    const array2 = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0]);
    model.fullScreenQuadBuffer.createAndWrite(array2, GPUBufferUsage.VERTEX);
    model.fullScreenQuadBuffer.setStrideInBytes(12);
    model.fullScreenQuadBuffer.setArrayInformation([{
      offset: 0,
      format: "float32x3"
    }]);
    return model.fullScreenQuadBuffer;
  };
}
var DEFAULT_VALUES59 = {
  device: null,
  fullScreenQuadBuffer: null
};
function extend64(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES59, initialValues);
  obj(publicAPI, model);
  setGet(publicAPI, model, ["device"]);
  vtkWebGPUBufferManager(publicAPI, model);
}
var newInstance63 = newInstance(extend64);
var vtkWebGPUBufferManager$1 = {
  newInstance: newInstance63,
  extend: extend64,
  ...STATIC11,
  ...Constants12
};

// node_modules/@kitware/vtk.js/Rendering/Core/Property2D.js
var {
  DisplayLocation: DisplayLocation2
} = Constants10;
function vtkProperty2D(publicAPI, model) {
  model.classHierarchy.push("vtkProperty2D");
  publicAPI.setDisplayLocationToBackground = () => publicAPI.setDisplayLocation(DisplayLocation2.BACKGROUND);
  publicAPI.setDisplayLocationToForeground = () => publicAPI.setDisplayLocation(DisplayLocation2.FOREGROUND);
  publicAPI.setRepresentationToWireframe = () => publicAPI.setRepresentation(Representation.WIREFRAME);
  publicAPI.setRepresentationToSurface = () => publicAPI.setRepresentation(Representation.SURFACE);
  publicAPI.setRepresentationToPoints = () => publicAPI.setRepresentation(Representation.POINTS);
  publicAPI.getRepresentationAsString = () => macro.enumToString(Representation, model.representation);
}
var DEFAULT_VALUES60 = {
  color: [1, 1, 1],
  opacity: 1,
  pointSize: 1,
  lineWidth: 1,
  representation: Representation.SURFACE,
  displayLocation: DisplayLocation2.FOREGROUND
};
function extend65(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES60, initialValues);
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["opacity", "lineWidth", "pointSize", "displayLocation", "representation"]);
  macro.setGetArray(publicAPI, model, ["color"], 3);
  vtkProperty2D(publicAPI, model);
}
var newInstance64 = macro.newInstance(extend65, "vtkProperty2D");
var vtkProperty2D$1 = {
  newInstance: newInstance64,
  extend: extend65,
  ...Constants10
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderModule.js
function vtkWebGPUShaderModule(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderModule");
  publicAPI.initialize = (device, shaderDesc) => {
    model.device = device;
    model.handle = model.device.getHandle().createShaderModule({
      code: shaderDesc.getCode()
    });
  };
}
var DEFAULT_VALUES61 = {
  device: null,
  handle: null
};
function extend66(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES61, initialValues);
  macro.obj(publicAPI, model);
  macro.get(publicAPI, model, ["lastCameraMTime"]);
  macro.setGet(publicAPI, model, ["device", "handle"]);
  vtkWebGPUShaderModule(publicAPI, model);
}
var newInstance65 = macro.newInstance(extend66, "vtkWebGPUShaderModule");
var vtkWebGPUShaderModule$1 = {
  newInstance: newInstance65,
  extend: extend66
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderCache.js
function substitute2(source, search, replace) {
  let all = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  const replaceStr = Array.isArray(replace) ? replace.join("\n") : replace;
  let replaced = false;
  if (source.search(search) !== -1) {
    replaced = true;
  }
  let gflag = "";
  if (all) {
    gflag = "g";
  }
  const regex = new RegExp(search, gflag);
  const resultstr = source.replace(regex, replaceStr);
  return {
    replace: replaced,
    result: resultstr
  };
}
function vtkWebGPUShaderCache(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderCache");
  publicAPI.getShaderModule = (shaderDesc) => {
    const sType = shaderDesc.getType();
    const sHash = shaderDesc.getHash();
    const keys = model._shaderModules.keys();
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key.getHash() === sHash && key.getType() === sType) {
        return model._shaderModules.get(key);
      }
    }
    const sm = vtkWebGPUShaderModule$1.newInstance();
    sm.initialize(model.device, shaderDesc);
    model._shaderModules.set(shaderDesc, sm);
    return sm;
  };
}
var DEFAULT_VALUES62 = {
  shaderModules: null,
  device: null,
  window: null
};
function extend67(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES62, initialValues);
  model._shaderModules = /* @__PURE__ */ new Map();
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["device", "window"]);
  vtkWebGPUShaderCache(publicAPI, model);
}
var newInstance66 = macro.newInstance(extend67, "vtkWebGPUShaderCache");
var vtkWebGPUShaderCache$1 = {
  newInstance: newInstance66,
  extend: extend67,
  substitute: substitute2
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/UniformBuffer.js
var {
  BufferUsage: BufferUsage3
} = vtkWebGPUBufferManager$1;
var {
  vtkErrorMacro: vtkErrorMacro17
} = macro;
function vtkWebGPUUniformBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUUniformBuffer");
  publicAPI.addEntry = (name, type) => {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro17(`entry named ${name} already exists`);
      return;
    }
    model.sortDirty = true;
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes: vtkWebGPUTypes.getByteStrideFromShaderFormat(type),
      offset: -1,
      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type),
      packed: false
    });
  };
  publicAPI.sortBufferEntries = () => {
    if (!model.sortDirty) {
      return;
    }
    let currOffset = 0;
    const newEntries = [];
    let maxAlignment = 4;
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (entry.sizeInBytes % 16 === 0) {
        maxAlignment = Math.max(16, maxAlignment);
      }
      if (entry.sizeInBytes % 8 === 0) {
        maxAlignment = Math.max(8, maxAlignment);
      }
    }
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (entry.packed === false && entry.sizeInBytes % 16 === 0) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (entry.packed === false && entry.sizeInBytes === 12) {
        for (let i2 = 0; i2 < model.bufferEntries.length; i2++) {
          const entry2 = model.bufferEntries[i2];
          if (entry2.packed === false && entry2.sizeInBytes === 4) {
            entry.packed = true;
            entry.offset = currOffset;
            newEntries.push(entry);
            currOffset += entry.sizeInBytes;
            entry2.packed = true;
            entry2.offset = currOffset;
            newEntries.push(entry2);
            currOffset += entry2.sizeInBytes;
            break;
          }
        }
      }
    }
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed && entry.sizeInBytes % 8 === 0) {
        for (let i2 = i + 1; i2 < model.bufferEntries.length; i2++) {
          const entry2 = model.bufferEntries[i2];
          if (!entry2.packed && entry2.sizeInBytes % 8 === 0) {
            entry.packed = true;
            entry.offset = currOffset;
            newEntries.push(entry);
            currOffset += entry.sizeInBytes;
            entry2.packed = true;
            entry2.offset = currOffset;
            newEntries.push(entry2);
            currOffset += entry2.sizeInBytes;
            break;
          }
        }
      }
    }
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed && entry.sizeInBytes % 8 === 0) {
        let found = false;
        for (let i2 = 0; !found && i2 < model.bufferEntries.length; i2++) {
          const entry2 = model.bufferEntries[i2];
          if (!entry2.packed && entry2.sizeInBytes === 4) {
            for (let i3 = i2 + 1; i3 < model.bufferEntries.length; i3++) {
              const entry3 = model.bufferEntries[i3];
              if (!entry3.packed && entry3.sizeInBytes === 4) {
                entry.packed = true;
                entry.offset = currOffset;
                newEntries.push(entry);
                currOffset += entry.sizeInBytes;
                entry2.packed = true;
                entry2.offset = currOffset;
                newEntries.push(entry2);
                currOffset += entry2.sizeInBytes;
                entry3.packed = true;
                entry3.offset = currOffset;
                newEntries.push(entry3);
                currOffset += entry3.sizeInBytes;
                found = true;
                break;
              }
            }
          }
        }
      }
    }
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed && entry.sizeInBytes > 4) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      if (!entry.packed) {
        entry.packed = true;
        entry.offset = currOffset;
        newEntries.push(entry);
        currOffset += entry.sizeInBytes;
      }
    }
    model.bufferEntries = newEntries;
    model._bufferEntryNames.clear();
    for (let i = 0; i < model.bufferEntries.length; i++) {
      model._bufferEntryNames.set(model.bufferEntries[i].name, i);
    }
    model.sizeInBytes = currOffset;
    model.sizeInBytes = maxAlignment * Math.ceil(model.sizeInBytes / maxAlignment);
    model.sortDirty = false;
  };
  publicAPI.sendIfNeeded = (device) => {
    if (!model.UBO) {
      const req = {
        nativeArray: model.Float32Array,
        usage: BufferUsage3.UniformArray,
        label: model.label
      };
      model.UBO = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model.sendDirty = false;
    }
    if (model.sendDirty) {
      device.getHandle().queue.writeBuffer(model.UBO.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes);
      model.sendDirty = false;
    }
    model.sendTime.modified();
  };
  publicAPI.createView = (type) => {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes);
      }
      model[type] = macro.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = (name, val) => {
    publicAPI.sortBufferEntries();
    const idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro17(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    if (entry.lastValue !== val) {
      view[entry.offset / view.BYTES_PER_ELEMENT] = val;
      model.sendDirty = true;
    }
    entry.lastValue = val;
  };
  publicAPI.setArray = (name, arr) => {
    publicAPI.sortBufferEntries();
    const idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro17(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    let changed = false;
    for (let i = 0; i < arr.length; i++) {
      if (!entry.lastValue || entry.lastValue[i] !== arr[i]) {
        view[entry.offset / view.BYTES_PER_ELEMENT + i] = arr[i];
        changed = true;
      }
    }
    if (changed) {
      model.sendDirty = true;
      entry.lastValue = [...arr];
    }
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: {
        buffer: model.UBO.getHandle()
      }
    };
    return foo;
  };
  publicAPI.getSendTime = () => model.sendTime.getMTime();
  publicAPI.getShaderCode = (binding, group2) => {
    publicAPI.sortBufferEntries();
    const lines = [`struct ${model.label}Struct
{`];
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      lines.push(`  ${entry.name}: ${entry.type},`);
    }
    lines.push(`};
@binding(${binding}) @group(${group2}) var<uniform> ${model.label}: ${model.label}Struct;`);
    return lines.join("\n");
  };
}
var DEFAULT_VALUES63 = {
  bufferEntries: null,
  bufferEntryNames: null,
  sizeInBytes: 0,
  label: null,
  bindGroupLayoutEntry: null,
  bindGroupEntry: null
};
function extend68(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES63, initialValues);
  macro.obj(publicAPI, model);
  model._bufferEntryNames = /* @__PURE__ */ new Map();
  model.bufferEntries = [];
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: "uniform"
    }
  };
  model.sendTime = {};
  macro.obj(model.sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  model.sendDirty = true;
  model.sortDirty = true;
  macro.get(publicAPI, model, ["binding", "bindGroupTime"]);
  macro.setGet(publicAPI, model, ["bindGroupLayoutEntry", "device", "label", "sizeInBytes"]);
  vtkWebGPUUniformBuffer(publicAPI, model);
}
var newInstance67 = macro.newInstance(extend68, "vtkWebGPUUniformBuffer");
var vtkWebGPUUniformBuffer$1 = {
  newInstance: newInstance67,
  extend: extend68
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/BindGroup.js
function vtkWebGPUBindGroup(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUBindGroup");
  publicAPI.setBindables = (bindables) => {
    if (model.bindables.length === bindables.length) {
      let allMatch = true;
      for (let i = 0; i < model.bindables.length; i++) {
        if (model.bindables[i] !== bindables[i]) {
          allMatch = false;
        }
      }
      if (allMatch) {
        return;
      }
    }
    model.bindables = bindables;
    publicAPI.modified();
  };
  publicAPI.getBindGroupLayout = (device) => {
    const entries = [];
    for (let i = 0; i < model.bindables.length; i++) {
      const entry = model.bindables[i].getBindGroupLayoutEntry();
      entry.binding = i;
      entries.push(entry);
    }
    return device.getBindGroupLayout({
      entries
    });
  };
  publicAPI.getBindGroup = (device) => {
    let mtime = publicAPI.getMTime();
    for (let i = 0; i < model.bindables.length; i++) {
      const tm = model.bindables[i].getBindGroupTime().getMTime();
      mtime = tm > mtime ? tm : mtime;
    }
    if (mtime < model.bindGroupTime.getMTime()) {
      return model.bindGroup;
    }
    const entries = [];
    for (let i = 0; i < model.bindables.length; i++) {
      const entry = model.bindables[i].getBindGroupEntry();
      entry.binding = i;
      entries.push(entry);
    }
    model.bindGroup = device.getHandle().createBindGroup({
      layout: publicAPI.getBindGroupLayout(device),
      entries,
      label: model.label
    });
    model.bindGroupTime.modified();
    return model.bindGroup;
  };
  publicAPI.getShaderCode = (pipeline) => {
    const lines = [];
    const bgroup = pipeline.getBindGroupLayoutCount(model.label);
    for (let i = 0; i < model.bindables.length; i++) {
      lines.push(model.bindables[i].getShaderCode(i, bgroup));
    }
    return lines.join("\n");
  };
}
var DEFAULT_VALUES64 = {
  device: null,
  handle: null,
  label: null
};
function extend69(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES64, initialValues);
  macro.obj(publicAPI, model);
  model.bindables = [];
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  macro.get(publicAPI, model, ["bindGroupTime", "handle", "sizeInBytes", "usage"]);
  macro.setGet(publicAPI, model, ["label", "device", "arrayInformation"]);
  vtkWebGPUBindGroup(publicAPI, model);
}
var newInstance68 = macro.newInstance(extend69);
var vtkWebGPUBindGroup$1 = {
  newInstance: newInstance68,
  extend: extend69
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Pipeline.js
function vtkWebGPUPipeline(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPipeline");
  publicAPI.getShaderDescriptions = () => model.shaderDescriptions;
  publicAPI.initialize = (device, hash) => {
    model.pipelineDescription = model.renderEncoder.getPipelineSettings();
    model.pipelineDescription.primitive.topology = model.topology;
    model.pipelineDescription.vertex = model.vertexState;
    model.pipelineDescription.label = hash;
    const bindGroupLayouts = [];
    for (let i = 0; i < model.layouts.length; i++) {
      bindGroupLayouts.push(model.layouts[i].layout);
    }
    model.pipelineLayout = device.getHandle().createPipelineLayout({
      bindGroupLayouts
    });
    model.pipelineDescription.layout = model.pipelineLayout;
    for (let i = 0; i < model.shaderDescriptions.length; i++) {
      const sd = model.shaderDescriptions[i];
      const sm = device.getShaderModule(sd);
      if (sd.getType() === "vertex") {
        model.pipelineDescription.vertex.module = sm.getHandle();
        model.pipelineDescription.vertex.entryPoint = "main";
      }
      if (sd.getType() === "fragment") {
        model.pipelineDescription.fragment.module = sm.getHandle();
        model.pipelineDescription.fragment.entryPoint = "main";
      }
    }
    model.handle = device.getHandle().createRenderPipeline(model.pipelineDescription);
  };
  publicAPI.getShaderDescription = (stype) => {
    for (let i = 0; i < model.shaderDescriptions.length; i++) {
      if (model.shaderDescriptions[i].getType() === stype)
        return model.shaderDescriptions[i];
    }
    return null;
  };
  publicAPI.addBindGroupLayout = (bindGroup) => {
    if (!bindGroup) {
      return;
    }
    model.layouts.push({
      layout: bindGroup.getBindGroupLayout(model.device),
      label: bindGroup.getLabel()
    });
  };
  publicAPI.getBindGroupLayout = (idx) => model.layouts[idx].layout;
  publicAPI.getBindGroupLayoutCount = (llabel) => {
    for (let i = 0; i < model.layouts.length; i++) {
      if (model.layouts[i].label === llabel) {
        return i;
      }
    }
    return 0;
  };
  publicAPI.bindVertexInput = (renderEncoder, vInput) => {
    vInput.bindBuffers(renderEncoder);
  };
}
var DEFAULT_VALUES65 = {
  handle: null,
  layouts: null,
  renderEncoder: null,
  shaderDescriptions: null,
  vertexState: null,
  topology: null,
  pipelineDescription: null
};
function extend70(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES65, initialValues);
  obj(publicAPI, model);
  model.layouts = [];
  model.shaderDescriptions = [];
  get(publicAPI, model, ["handle", "pipelineDescription"]);
  setGet(publicAPI, model, ["device", "renderEncoder", "topology", "vertexState"]);
  vtkWebGPUPipeline(publicAPI, model);
}
var newInstance69 = newInstance(extend70, "vtkWebGPUPipeline");
var vtkWebGPUPipeline$1 = {
  newInstance: newInstance69,
  extend: extend70
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ShaderDescription.js
function vtkWebGPUShaderDescription(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUShaderDescription");
  publicAPI.hasOutput = (name) => model.outputNames.includes(name);
  publicAPI.addOutput = function(type, name) {
    let interpolation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
    model.outputTypes.push(type);
    model.outputNames.push(name);
    model.outputInterpolations.push(interpolation);
  };
  publicAPI.addBuiltinOutput = (type, name) => {
    model.builtinOutputTypes.push(type);
    model.builtinOutputNames.push(name);
  };
  publicAPI.addBuiltinInput = (type, name) => {
    model.builtinInputTypes.push(type);
    model.builtinInputNames.push(name);
  };
  publicAPI.replaceShaderCode = (priorStage, vertexInput) => {
    const inputImpl = [];
    let iodec = [];
    if (vertexInput) {
      inputImpl.push(vertexInput.getShaderCode());
    }
    if (priorStage || model.builtinInputNames.length) {
      const inputStruct = [];
      inputStruct.push(`struct ${model.type}Input
{`);
      if (priorStage) {
        const inputNames = priorStage.getOutputNamesByReference();
        const inputTypes = priorStage.getOutputTypesByReference();
        const inputInterpolations = priorStage.getOutputInterpolationsByReference();
        for (let i = 0; i < inputNames.length; i++) {
          if (inputInterpolations[i] !== void 0) {
            inputStruct.push(`  @location(${i}) @interpolate(${inputInterpolations[i]}) ${inputNames[i]} : ${inputTypes[i]},`);
          } else {
            inputStruct.push(`  @location(${i}) ${inputNames[i]} : ${inputTypes[i]},`);
          }
        }
      }
      for (let i = 0; i < model.builtinInputNames.length; i++) {
        inputStruct.push(`  ${model.builtinInputNames[i]} : ${model.builtinInputTypes[i]},`);
      }
      if (inputStruct.length > 1) {
        inputStruct.push("};");
        iodec = inputStruct;
        inputImpl[inputImpl.length - 1] += ",";
        inputImpl.push(`input: ${model.type}Input`);
      }
    }
    if (inputImpl.length) {
      model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Input", inputImpl).result;
    }
    if (model.outputNames.length + model.builtinOutputNames.length) {
      const outputStruct = [`struct ${model.type}Output
{`];
      for (let i = 0; i < model.outputNames.length; i++) {
        if (model.outputInterpolations[i] !== void 0) {
          outputStruct.push(`  @location(${i}) @interpolate(${model.outputInterpolations[i]}) ${model.outputNames[i]} : ${model.outputTypes[i]},`);
        } else {
          outputStruct.push(`  @location(${i}) ${model.outputNames[i]} : ${model.outputTypes[i]},`);
        }
      }
      for (let i = 0; i < model.builtinOutputNames.length; i++) {
        outputStruct.push(`  ${model.builtinOutputNames[i]} : ${model.builtinOutputTypes[i]},`);
      }
      outputStruct.push("};");
      iodec = iodec.concat(outputStruct);
      model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Output", [`-> ${model.type}Output`]).result;
    }
    model.code = vtkWebGPUShaderCache$1.substitute(model.code, "//VTK::IOStructs::Dec", iodec).result;
  };
}
var DEFAULT_VALUES66 = {
  type: null,
  // 'vertex' or 'fragment'
  hash: null,
  code: null,
  outputNames: null,
  outputTypes: null
};
function extend71(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES66, initialValues);
  model.outputNames = [];
  model.outputTypes = [];
  model.outputInterpolations = [];
  model.builtinOutputNames = [];
  model.builtinOutputTypes = [];
  model.builtinInputNames = [];
  model.builtinInputTypes = [];
  macro.obj(publicAPI, model);
  macro.setGet(publicAPI, model, ["type", "hash", "code"]);
  macro.getArray(publicAPI, model, ["outputTypes", "outputNames", "outputInterpolations"]);
  vtkWebGPUShaderDescription(publicAPI, model);
}
var newInstance70 = macro.newInstance(extend71, "vtkWebGPUShaderDescription");
var vtkWebGPUShaderDescription$1 = {
  newInstance: newInstance70,
  extend: extend71
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/VertexInput.js
function arraysEqual(a, b) {
  if (a === b)
    return true;
  if (a == null || b == null)
    return false;
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; ++i) {
    if (!b.includes(a[i]))
      return false;
  }
  return true;
}
function vtkWebGPUVertexInput(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUVertexInput");
  publicAPI.addBuffer = function(buffer, inames) {
    let stepMode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "vertex";
    let names = inames;
    if (!Array.isArray(names)) {
      names = [names];
    }
    for (let i = 0; i < model.inputs.length; i++) {
      if (arraysEqual(model.inputs[i].names, names)) {
        if (model.inputs[i].buffer === buffer) {
          return;
        }
        model.inputs[i].buffer = buffer;
        return;
      }
    }
    model.inputs.push({
      buffer,
      stepMode,
      names
    });
    model.inputs = model.inputs.sort((v1, v2) => {
      if (v1.names[0] < v2.names[0]) {
        return -1;
      }
      if (v1.names[0] > v2.names[0]) {
        return 1;
      }
      return 0;
    });
  };
  publicAPI.removeBufferIfPresent = (name) => {
    for (let i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        model.inputs.splice(i, 1);
      }
    }
  };
  publicAPI.getBuffer = (name) => {
    for (let i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return model.inputs[i].buffer;
      }
    }
    return null;
  };
  publicAPI.hasAttribute = (name) => {
    for (let i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return true;
      }
    }
    return false;
  };
  publicAPI.getAttributeTime = (name) => {
    for (let i = 0; i < model.inputs.length; i++) {
      if (model.inputs[i].names.includes(name)) {
        return model.inputs[i].buffer.getSourceTime();
      }
    }
    return 0;
  };
  publicAPI.getShaderCode = () => {
    let result = "";
    let nameCount = 0;
    for (let i = 0; i < model.inputs.length; i++) {
      for (let nm = 0; nm < model.inputs[i].names.length; nm++) {
        const arrayInfo = model.inputs[i].buffer.getArrayInformation()[nm];
        const type = vtkWebGPUTypes.getShaderTypeFromBufferFormat(arrayInfo.format);
        if (nameCount > 0) {
          result += ",\n";
        }
        result = `${result}  @location(${nameCount}) ${model.inputs[i].names[nm]} : ${type}`;
        nameCount++;
      }
    }
    return result;
  };
  publicAPI.getVertexInputInformation = () => {
    const info = {};
    if (model.inputs.length) {
      const vertexBuffers = [];
      let nameCount = 0;
      for (let i = 0; i < model.inputs.length; i++) {
        const buf = model.inputs[i].buffer;
        const buffer = {
          arrayStride: buf.getStrideInBytes(),
          stepMode: model.inputs[i].stepMode,
          attributes: []
        };
        const arrayInfo = buf.getArrayInformation();
        for (let nm = 0; nm < model.inputs[i].names.length; nm++) {
          buffer.attributes.push({
            shaderLocation: nameCount,
            offset: arrayInfo[nm].offset,
            format: arrayInfo[nm].format
          });
          nameCount++;
        }
        vertexBuffers.push(buffer);
      }
      info.buffers = vertexBuffers;
    }
    return info;
  };
  publicAPI.bindBuffers = (renderEncoder) => {
    for (let i = 0; i < model.inputs.length; i++) {
      renderEncoder.setVertexBuffer(i, model.inputs[i].buffer.getHandle());
    }
    if (model.indexBuffer) {
      renderEncoder.setIndexBuffer(model.indexBuffer.getHandle(), model.indexBuffer.getArrayInformation()[0].format);
    }
  };
  publicAPI.getReady = () => {
  };
  publicAPI.releaseGraphicsResources = () => {
    if (model.created) {
      model.inputs = [];
      model.bindingDescriptions = [];
      model.attributeDescriptions = [];
    }
  };
}
var DEFAULT_VALUES67 = {
  inputs: null,
  bindingDescriptions: false,
  attributeDescriptions: null,
  indexBuffer: null
};
function extend72(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES67, initialValues);
  obj(publicAPI, model);
  model.bindingDescriptions = [];
  model.attributeDescriptions = [];
  model.inputs = [];
  setGet(publicAPI, model, ["created", "device", "handle", "indexBuffer"]);
  vtkWebGPUVertexInput(publicAPI, model);
}
var newInstance71 = newInstance(extend72, "vtkWebGPUVertexInput");
var vtkWebGPUVertexInput$1 = {
  newInstance: newInstance71,
  extend: extend72
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/SimpleMapper.js
var vtkWebGPUSimpleMapperVS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  // var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`;
var vtkWebGPUSimpleMapperFS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::Light::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
function vtkWebGPUSimpleMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUSimpleMapper");
  publicAPI.generateShaderDescriptions = (hash, pipeline, vertexInput) => {
    const vDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: "vertex",
      hash,
      code: model.vertexShaderTemplate
    });
    const fDesc = vtkWebGPUShaderDescription$1.newInstance({
      type: "fragment",
      hash,
      code: model.fragmentShaderTemplate
    });
    const sdrs = pipeline.getShaderDescriptions();
    sdrs.push(vDesc);
    sdrs.push(fDesc);
    const scode = model.vertexShaderTemplate + model.fragmentShaderTemplate;
    const re2 = new RegExp("//VTK::[^:]*::", "g");
    const unique = scode.match(re2).filter((v, i, a) => a.indexOf(v) === i);
    const fnames = unique.map((v) => `replaceShader${v.substring(7, v.length - 2)}`);
    for (let i = 0; i < fnames.length; i++) {
      const fname = fnames[i];
      if (fname !== "replaceShaderIOStructs" && model.shaderReplacements.has(fname)) {
        model.shaderReplacements.get(fname)(hash, pipeline, vertexInput);
      }
    }
    publicAPI.replaceShaderIOStructs(hash, pipeline, vertexInput);
  };
  publicAPI.replaceShaderIOStructs = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.replaceShaderCode(null, vertexInput);
    const fDesc = pipeline.getShaderDescription("fragment");
    fDesc.replaceShaderCode(vDesc);
  };
  publicAPI.replaceShaderRenderEncoder = (hash, pipeline, vertexInput) => {
    model.renderEncoder.replaceShaderCode(pipeline);
  };
  model.shaderReplacements.set("replaceShaderRenderEncoder", publicAPI.replaceShaderRenderEncoder);
  publicAPI.replaceShaderRenderer = (hash, pipeline, vertexInput) => {
    if (!model.WebGPURenderer) {
      return;
    }
    const ubocode = model.WebGPURenderer.getBindGroup().getShaderCode(pipeline);
    const vDesc = pipeline.getShaderDescription("vertex");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Renderer::Dec", [ubocode]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Renderer::Dec", [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderRenderer", publicAPI.replaceShaderRenderer);
  publicAPI.replaceShaderMapper = (hash, pipeline, vertexInput) => {
    const ubocode = model.bindGroup.getShaderCode(pipeline);
    const vDesc = pipeline.getShaderDescription("vertex");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Mapper::Dec", [ubocode]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    fDesc.addBuiltinInput("bool", "@builtin(front_facing) frontFacing");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Mapper::Dec", [ubocode]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderMapper", publicAPI.replaceShaderMapper);
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addOutput("vec2<f32>", "tcoordVS");
  };
  model.shaderReplacements.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.addTextureView = (view) => {
    if (model.textureViews.includes(view)) {
      return;
    }
    model.textureViews.push(view);
  };
  publicAPI.prepareToDraw = (renderEncoder) => {
    model.renderEncoder = renderEncoder;
    publicAPI.updateInput();
    publicAPI.updateBuffers();
    publicAPI.updateBindings();
    publicAPI.updatePipeline();
  };
  publicAPI.updateInput = () => {
  };
  publicAPI.updateBuffers = () => {
  };
  publicAPI.updateBindings = () => {
    model.bindGroup.setBindables(publicAPI.getBindables());
  };
  publicAPI.computePipelineHash = () => {
  };
  publicAPI.registerDrawCallback = (encoder) => {
    encoder.registerDrawCallback(model.pipeline, publicAPI.draw);
  };
  publicAPI.prepareAndDraw = (encoder) => {
    publicAPI.prepareToDraw(encoder);
    encoder.setPipeline(model.pipeline);
    publicAPI.draw(encoder);
  };
  publicAPI.draw = (renderEncoder) => {
    const pipeline = renderEncoder.getBoundPipeline();
    renderEncoder.activateBindGroup(model.bindGroup);
    if (model.WebGPURenderer) {
      model.WebGPURenderer.bindUBO(renderEncoder);
    }
    pipeline.bindVertexInput(renderEncoder, model.vertexInput);
    const indexBuffer = model.vertexInput.getIndexBuffer();
    if (indexBuffer) {
      renderEncoder.drawIndexed(indexBuffer.getIndexCount(), model.numberOfInstances, 0, 0, 0);
    } else {
      renderEncoder.draw(model.numberOfVertices, model.numberOfInstances, 0, 0);
    }
  };
  publicAPI.getBindables = () => {
    const bindables = [...model.additionalBindables];
    if (model.UBO) {
      bindables.push(model.UBO);
    }
    if (model.SSBO) {
      bindables.push(model.SSBO);
    }
    for (let t = 0; t < model.textureViews.length; t++) {
      bindables.push(model.textureViews[t]);
      const samp = model.textureViews[t].getSampler();
      if (samp) {
        bindables.push(samp);
      }
    }
    return bindables;
  };
  publicAPI.updatePipeline = () => {
    publicAPI.computePipelineHash();
    model.pipeline = model.device.getPipeline(model.pipelineHash);
    if (!model.pipeline) {
      model.pipeline = vtkWebGPUPipeline$1.newInstance();
      model.pipeline.setDevice(model.device);
      if (model.WebGPURenderer) {
        model.pipeline.addBindGroupLayout(model.WebGPURenderer.getBindGroup());
      }
      model.pipeline.addBindGroupLayout(model.bindGroup);
      publicAPI.generateShaderDescriptions(model.pipelineHash, model.pipeline, model.vertexInput);
      model.pipeline.setTopology(model.topology);
      model.pipeline.setRenderEncoder(model.renderEncoder);
      model.pipeline.setVertexState(model.vertexInput.getVertexInputInformation());
      model.device.createPipeline(model.pipelineHash, model.pipeline);
    }
  };
}
var DEFAULT_VALUES68 = {
  additionalBindables: void 0,
  bindGroup: null,
  device: null,
  fragmentShaderTemplate: null,
  numberOfInstances: 1,
  numberOfVertices: 0,
  pipelineHash: null,
  shaderReplacements: null,
  SSBO: null,
  textureViews: null,
  topology: "triangle-list",
  UBO: null,
  vertexShaderTemplate: null,
  WebGPURenderer: null
};
function extend73(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES68, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.textureViews = [];
  model.vertexInput = vtkWebGPUVertexInput$1.newInstance();
  model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
    label: "mapperBG"
  });
  model.additionalBindables = [];
  model.fragmentShaderTemplate = model.fragmentShaderTemplate || vtkWebGPUSimpleMapperFS;
  model.vertexShaderTemplate = model.vertexShaderTemplate || vtkWebGPUSimpleMapperVS;
  model.shaderReplacements = /* @__PURE__ */ new Map();
  macro.get(publicAPI, model, ["pipeline", "vertexInput"]);
  macro.setGet(publicAPI, model, ["additionalBindables", "device", "fragmentShaderTemplate", "interpolate", "numberOfInstances", "numberOfVertices", "pipelineHash", "shaderReplacements", "SSBO", "textureViews", "topology", "UBO", "vertexShaderTemplate", "WebGPURenderer"]);
  vtkWebGPUSimpleMapper(publicAPI, model);
}
var newInstance72 = macro.newInstance(extend73, "vtkWebGPUSimpleMapper");
var vtkWebGPUSimpleMapper$1 = {
  newInstance: newInstance72,
  extend: extend73
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/CellArrayMapper.js
var {
  BufferUsage: BufferUsage4,
  PrimitiveTypes: PrimitiveTypes3
} = vtkWebGPUBufferManager$1;
var {
  Representation: Representation5
} = vtkProperty$1;
var {
  ScalarMode: ScalarMode4
} = vtkMapper$1;
var {
  CoordinateSystem: CoordinateSystem6
} = vtkProp$1;
var {
  DisplayLocation: DisplayLocation3
} = vtkProperty2D$1;
var vtkWebGPUPolyDataVS = `
//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::Normal::Dec

//VTK::TCoord::Dec

//VTK::Select::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@vertex
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : vertexOutput;

  var vertex: vec4<f32> = vertexBC;

  //VTK::Color::Impl

  //VTK::Normal::Impl

  //VTK::TCoord::Impl

  //VTK::Select::Impl

  //VTK::Position::Impl

  return output;
}
`;
var vtkWebGPUPolyDataFS = `
struct PBRData {
  diffuse: vec3<f32>,
  specular: vec3<f32>,
}

struct Material {
  ior: f32,
  roughness: f32,
  metallic: f32,
  base: vec3<f32>,
};

struct DirectionalLight {
  direction: vec3<f32>,
  color: vec3<f32>,
};

struct PointLight {
  position: vec3<f32>,
  color: vec3<f32>,
};

struct SpotLight {
  position: vec3<f32>,
  direction: vec3<f32>,
  cones: vec2<f32>,
  color: vec3<f32>,
};

const pi: f32 = 3.14159265359;

// Dot product with the max already in it
fn mdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  return max(0.0, dot(a, b));
}
// Dot product with a max in it that does not allow for negative values
// Physically based rendering is accurate as long as normals are accurate,
// however this is pretty often not the case. In order to prevent negative
// values from ruining light calculations and creating zones of zero light,
// this remapping is used, which smoothly clamps the dot product between
// zero and one while still maintaining a good amount of accuracy.
fn cdot(a: vec3<f32>, b: vec3<f32>) -> f32 {
  var d: f32 = max(0.0, dot(a, b));
  d = pow((d + 1.0) / 2.0, 2.6);
  return d;
}

// Lambertian diffuse model
fn lambertDiffuse(base: vec3<f32>, N: vec3<f32>, L: vec3<f32>) -> vec3<f32> {
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5);
  return (base/pi)*NdotL;
}

// Yasuhiro Fujii improvement on the Oren-Nayar model
// https://mimosa-pudica.net/improved-oren-nayar.html
// p is surface color, o is roughness
fn fujiiOrenNayar(p: vec3<f32>, o: f32, N: vec3<f32>, L: vec3<f32>, V: vec3<f32>) -> vec3<f32> {
  var invpi: f32 = 0.31830988618; // 1/pi

  var o2 = o*o;
  var NdotL: f32 = mdot(N, L);
  NdotL = pow(NdotL, 1.5); // Less physically accurate, but hides the "seams" between lights better

  var NdotV: f32 = mdot(N, V);
  var LdotV: f32 = mdot(L, V);

  var s: f32 = LdotV - NdotL*NdotV;
  var t: f32 = mix(1.0, max(NdotL, NdotV), step(0.0, s)); // Mix with step is the equivalent of an if statement
  var A: vec3<f32> = 0.5*(o2 / (o2 + 0.33)) + 0.17*p*(o2 / (o2 + 0.13));
  A = invpi*(1 - A);
  var B: f32 = 0.45*(o2 / (o2 + 0.09));
  B = invpi*B;

  return p*NdotL*(A + B*(s/t));
}

// Fresnel portion of BRDF (IOR only, simplified)
fn schlickFresnelIOR(V: vec3<f32>, N: vec3<f32>, ior: f32, k: f32) -> f32 {
  var NdotV: f32 = mdot(V, N);
  var F0: f32 = (pow((ior - 1.0), 2.0) + k*k) / (pow((ior + 1.0), 2.0) + k*k); // This takes into account the roughness, which the other one does not
  return F0 + (1.0 - F0) * pow((1.0-NdotV), 5.0);
}

// Fresnel portion of BRDF (Color ior, better)
fn schlickFresnelRGB(V: vec3<f32>, N: vec3<f32>, F0: vec3<f32>) -> vec3<f32> {
  var NdotV: f32 = mdot(V, N);
  return F0 + (1.0 - F0) * pow((1-NdotV), 5.0);
}

// Normal portion of BRDF
// https://learnopengl.com/PBR/Theory
// Trowbridge-Reitz GGX functions: normal, halfway, roughness^2
fn trGGX(N: vec3<f32>, H: vec3<f32>, a: f32) -> f32 {
  var a2: f32 = a*a;
  var NdotH = mdot(N, H);
  var NdotH2 = NdotH*NdotH;

  var denom: f32 = NdotH2 * (a2 - 1.0) + 1.0;

  return a2 / max((pi*denom*denom), 0.000001);
}

// A VERY bad approximation of anisotropy. Real anisotropic calculations require tangent and bitangent
fn anisotrophicTrGGX(N: vec3<f32>, H: vec3<f32>, O: vec3<f32>, s: f32, a: f32) -> f32 {
  var Op: vec3<f32> = (rendererUBO.WCVCNormals * vec4<f32>(normalize(O) * s, 0.)).xyz;

  var ggx1: f32 = trGGX(N + Op*s, H, a);
  var ggx2: f32 = trGGX(N - Op*s, H, a);
  return (0.5 * ggx1 + 0.5 * ggx2);
}

// Geometry portion of BRDF
fn schlickGGX(N: vec3<f32>, X: vec3<f32>, k: f32) -> f32 {
  var NdotX = cdot(N, X);
  return NdotX / max(0.000001, (NdotX*(1.0-k) + k));
}

fn smithSurfaceRoughness(N: vec3<f32>, V: vec3<f32>, L: vec3<f32>, k: f32) -> f32 {
  var ggx1: f32 = min(1.0, schlickGGX(N, V, k));
  var ggx2: f32 = min(1.0, schlickGGX(N, L, k));
  return ggx1*ggx2;
}

// BRDF Combination
fn cookTorrance(D: f32, F: f32, G: f32, N: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> f32 {
  var num: f32 = D*F*G;
  var denom: f32 = 4*cdot(V, N)*cdot(L, N);

  return num / max(denom, 0.000001);
}

// Different lighting calculations for different light sources
fn calcDirectionalLight(N: vec3<f32>, V: vec3<f32>, mat: Material, light: DirectionalLight) -> PBRData {
  var L: vec3<f32> = normalize(light.direction); // Light Vector
  var H: vec3<f32> = normalize(L + V); // Halfway Vector

  var alpha = mat.roughness * mat.roughness;
  var k: f32 = alpha * alpha / 2.0;

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L); // Fresnel term is replaced with 1 because it is added later
  var incoming: vec3<f32> = light.color;
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5);

  var specular: vec3<f32> = brdf * incoming * angle;
  // Oren-Nayar gives a clay-like effect when fully rough which some people may not want, so it might be better to give a separate
  // control property for the diffuse vs specular roughness
  var diffuse: vec3<f32> = incoming * fujiiOrenNayar(mat.base, mat.roughness, N, L, V);
  // Stores the specular and diffuse separately to allow for finer post processing
  var out = PBRData(diffuse, specular);

  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

fn calcPointLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, mat: Material, light: PointLight) -> PBRData {
  var L: vec3<f32> = normalize(light.position - fragPos);
  var H: vec3<f32> = normalize(L + V);
  var dist = distance(light.position, fragPos);

  var alpha = mat.roughness * mat.roughness;
  var k: f32 = alpha * alpha / 2.0;

  var D: f32 = trGGX(N, H, alpha); // Distribution
  var F: f32 = schlickFresnelIOR(V, N, mat.ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);
  var incoming: vec3<f32> = light.color * (1.0 / (dist * dist));
  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" between light sources

  var specular: vec3<f32> = brdf * incoming * angle;
  var diffuse: vec3<f32> = incoming * fujiiOrenNayar(mat.base, mat.roughness, N, L, V);
  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);

  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// For a reason unknown to me, spheres dont seem to behave propperly with head-on spot lights
fn calcSpotLight(N: vec3<f32>, V: vec3<f32>, fragPos: vec3<f32>, mat: Material, light: SpotLight) -> PBRData {
  var L: vec3<f32> = normalize(light.position - fragPos);
  var H: vec3<f32> = normalize(L + V); // Halfway Vector
  var dist = distance(light.position, fragPos);

  var alpha = mat.roughness * mat.roughness;
  var k: f32 = alpha * alpha / 2.0; // could also be pow(alpha + 1.0, 2) / 8

  var D: f32 = trGGX(N, H, alpha); // Distribution
  // var F: f32 = schlickFresnelIOR(V, N, ior, k); // Fresnel
  var G: f32 = smithSurfaceRoughness(N, V, L, k); // Geometry

  var brdf: f32 = cookTorrance(D, 1.0, G, N, V, L);

  var theta: f32 = mdot(normalize(light.direction), L);
  var epsilon: f32 = light.cones.x - light.cones.y;
  var intensity: f32 = (theta - light.cones.y) / epsilon;
  intensity = clamp(intensity, 0.0, 1.0);
  intensity /= dist * dist;

  var incoming: vec3<f32> = light.color * intensity;

  var angle: f32 = mdot(L, N);
  angle = pow(angle, 1.5); // Smoothing factor makes it less accurate, but reduces ugly "seams" between light sources

  var specular: vec3<f32> = brdf * incoming * angle;
  var diffuse: vec3<f32> = incoming * fujiiOrenNayar(mat.base, mat.roughness, N, L, V);

  // Stores the specular and diffuse separately to allow for finer post processing
  // Could also be done (propably more properly) with a struct
  var out = PBRData(diffuse, specular);

  return out; // Returns angle along with color of light so the final color can be multiplied by angle as well (creates black areas)
}

// Environment mapping stuff
// Takes in a vector and converts it to an equivalent coordinate in a rectilinear texture. Should be replaced with cubemaps at some point
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Color::Dec

//VTK::TCoord::Dec

// optional surface normal declaration
//VTK::Normal::Dec

//VTK::Select::Dec

//VTK::RenderEncoder::Dec

//VTK::Mapper::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output : fragmentOutput;

  // Temporary ambient, diffuse, and opacity
  var ambientColor: vec4<f32> = mapperUBO.AmbientColor;
  var diffuseColor: vec4<f32> = mapperUBO.DiffuseColor;
  var opacity: f32 = mapperUBO.Opacity;
  var ior: f32 = mapperUBO.BaseIOR;

  // This should be declared somewhere else
  var _diffuseMap: vec4<f32> = vec4<f32>(1.0);
  var _roughnessMap: vec4<f32> = vec4<f32>(1.0);
  var _metallicMap: vec4<f32> = vec4<f32>(1.0);
  var _normalMap: vec4<f32> = vec4<f32>(0.0, 0.0, 1.0, 0.0); // normal map was setting off the normal vector detection in fragment
  var _ambientOcclusionMap: vec4<f32> = vec4<f32>(1.);
  var _emissionMap: vec4<f32> = vec4<f32>(0.);

  //VTK::Color::Impl

  //VTK::TCoord::Impl

  //VTK::Normal::Impl

  var computedColor: vec4<f32> = vec4<f32>(diffuseColor.rgb, 1.0);

  //VTK::Light::Impl

  //VTK::Select::Impl

  // Use texture alpha for transparency
  computedColor.a = mapperUBO.Opacity * _diffuseMap.a;
  if (computedColor.a == 0.0) { discard; };

  //VTK::Position::Impl

  //VTK::RenderEncoder::Impl

  return output;
}
`;
function isEdges(hash) {
  return hash.indexOf("edge") >= 0;
}
function vtkWebGPUCellArrayMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUCellArrayMapper");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (model.is2D) {
        model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor2D");
        model.forceZValue = true;
      } else {
        model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor");
        model.forceZValue = false;
      }
      model.coordinateSystem = model.WebGPUActor.getRenderable().getCoordinateSystem();
      model.useRendererMatrix = model.coordinateSystem !== CoordinateSystem6.DISPLAY;
      model.WebGPURenderer = model.WebGPUActor.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      model.device = model.WebGPURenderWindow.getDevice();
    }
  };
  publicAPI.translucentPass = (prepass) => {
    if (prepass) {
      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
    }
  };
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      publicAPI.prepareToDraw(model.WebGPURenderer.getRenderEncoder());
      model.renderEncoder.registerDrawCallback(model.pipeline, publicAPI.draw);
    }
  };
  publicAPI.updateUBO = () => {
    var _a, _b;
    const actor = model.WebGPUActor.getRenderable();
    const ppty = actor.getProperty();
    const utime = model.UBO.getSendTime();
    if (publicAPI.getMTime() <= utime && ppty.getMTime() <= utime && model.renderable.getMTime() <= utime) {
      return;
    }
    const keyMats = model.WebGPUActor.getKeyMatrices(model.WebGPURenderer);
    model.UBO.setArray("BCWCMatrix", keyMats.bcwc);
    model.UBO.setArray("BCSCMatrix", keyMats.bcsc);
    model.UBO.setArray("MCWCNormals", keyMats.normalMatrix);
    if (model.is2D) {
      const displayLoc = ((_a = ppty.getDisplayLocation) == null ? void 0 : _a.call(ppty)) ?? DisplayLocation3.BACKGROUND;
      model.UBO.setValue("ZValue", displayLoc === DisplayLocation3.FOREGROUND ? 1 : 0);
      const aColor = ppty.getColorByReference();
      model.UBO.setValue("AmbientIntensity", 1);
      model.UBO.setArray("DiffuseColor", [...aColor, 1]);
      model.UBO.setValue("DiffuseIntensity", 0);
      model.UBO.setValue("SpecularIntensity", 0);
    } else {
      model.UBO.setValue("AmbientIntensity", ppty.getAmbient());
      model.UBO.setArray("AmbientColor", [...ppty.getAmbientColorByReference(), 1]);
      model.UBO.setValue("DiffuseIntensity", ppty.getDiffuse());
      model.UBO.setArray("DiffuseColor", [...ppty.getDiffuseColorByReference(), 1]);
      model.UBO.setValue("Roughness", ppty.getRoughness());
      model.UBO.setValue("BaseIOR", ppty.getBaseIOR());
      model.UBO.setValue("Metallic", ppty.getMetallic());
      model.UBO.setValue("NormalStrength", ppty.getNormalStrength());
      model.UBO.setValue("Emission", ppty.getEmission());
      model.UBO.setValue("SpecularIntensity", ppty.getSpecular());
      if (ppty.getSpecularColorByReference()) {
        model.UBO.setArray("SpecularColor", [...ppty.getSpecularColorByReference(), 1]);
      }
    }
    const edgeColor = (_b = ppty.getEdgeColorByReference) == null ? void 0 : _b.call(ppty);
    if (edgeColor)
      model.UBO.setArray("EdgeColor", [...edgeColor, 1]);
    model.UBO.setValue("LineWidth", ppty.getLineWidth());
    model.UBO.setValue("Opacity", ppty.getOpacity());
    model.UBO.setValue("PropID", model.WebGPUActor.getPropID());
    model.UBO.sendIfNeeded(model.WebGPURenderWindow.getDevice());
  };
  publicAPI.haveWideLines = () => {
    const actor = model.WebGPUActor.getRenderable();
    const representation = actor.getProperty().getRepresentation();
    if (actor.getProperty().getLineWidth() <= 1) {
      return false;
    }
    if (model.primitiveType === PrimitiveTypes3.Verts) {
      return false;
    }
    if (model.primitiveType === PrimitiveTypes3.Triangles || model.primitiveType === PrimitiveTypes3.TriangleStrips) {
      return representation === Representation5.WIREFRAME;
    }
    return true;
  };
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    if (!vDesc.hasOutput("vertexVC"))
      vDesc.addOutput("vec4<f32>", "vertexVC");
    let code = vDesc.getCode();
    if (model.useRendererMatrix) {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    var pCoord: vec4<f32> = rendererUBO.SCPCMatrix*mapperUBO.BCSCMatrix*vertexBC;", "    output.vertexVC = rendererUBO.SCVCMatrix * mapperUBO.BCSCMatrix * vec4<f32>(vertexBC.xyz, 1.0);", "//VTK::Position::Impl"]).result;
      if (model.forceZValue) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["pCoord = vec4<f32>(pCoord.xyz/pCoord.w, 1.0);", "pCoord.z = mapperUBO.ZValue;", "//VTK::Position::Impl"]).result;
      }
    } else {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    var pCoord: vec4<f32> = mapperUBO.BCSCMatrix*vertexBC;", "    pCoord.x = 2.0* pCoord.x / rendererUBO.viewportSize.x - 1.0;", "    pCoord.y = 2.0* pCoord.y / rendererUBO.viewportSize.y - 1.0;", "    pCoord.z = 0.5 - 0.5 * pCoord.z;", "//VTK::Position::Impl"]).result;
      if (model.forceZValue) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    pCoord.z = mapperUBO.ZValue;", "//VTK::Position::Impl"]).result;
      }
    }
    if (publicAPI.haveWideLines()) {
      vDesc.addBuiltinInput("u32", "@builtin(instance_index) instanceIndex");
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", [
        "    var tmpPos: vec4<f32> = pCoord;",
        "    var numSteps: f32 = ceil(mapperUBO.LineWidth - 1.0);",
        "    var offset: f32 = (mapperUBO.LineWidth - 1.0) * (f32(input.instanceIndex / 2u) - numSteps/2.0) / numSteps;",
        "    var tmpPos2: vec3<f32> = tmpPos.xyz / tmpPos.w;",
        "    tmpPos2.x = tmpPos2.x + 2.0 * (f32(input.instanceIndex) % 2.0) * offset / rendererUBO.viewportSize.x;",
        "    tmpPos2.y = tmpPos2.y + 2.0 * (f32(input.instanceIndex + 1u) % 2.0) * offset / rendererUBO.viewportSize.y;",
        "    tmpPos2.z = min(1.0, tmpPos2.z + 0.00001);",
        // could become a setting
        "    pCoord = vec4<f32>(tmpPos2.xyz * tmpPos.w, tmpPos.w);",
        "//VTK::Position::Impl"
      ]).result;
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["    output.Position = pCoord;"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.replaceShaderNormal = (hash, pipeline, vertexInput) => {
    const normalBuffer = vertexInput.getBuffer("normalMC");
    const actor = model.WebGPUActor.getRenderable();
    if (normalBuffer) {
      const vDesc = pipeline.getShaderDescription("vertex");
      if (!vDesc.hasOutput("normalVC")) {
        vDesc.addOutput("vec3<f32>", "normalVC", normalBuffer.getArrayInformation()[0].interpolation);
      }
      if (!vDesc.hasOutput("tangentVC")) {
        vDesc.addOutput("vec3<f32>", "tangentVC", normalBuffer.getArrayInformation()[0].interpolation);
      }
      if (!vDesc.hasOutput("bitangentVC")) {
        vDesc.addOutput("vec3<f32>", "bitangentVC", normalBuffer.getArrayInformation()[0].interpolation);
      }
      let code = vDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", [
        "  output.normalVC = normalize((rendererUBO.WCVCNormals * mapperUBO.MCWCNormals * normalMC).xyz);",
        // This is just an approximation, but it happens to work extremely well
        // It only works well for normals that are head on and not super angled though
        // Definitely needs to be replaced
        "  var c1: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 0, 1));",
        "  var c2: vec3<f32> = cross(output.normalVC, vec3<f32>(0, 1, 0));",
        "  var tangent: vec3<f32> = mix(c1, c2, distance(c1, c2));",
        "  output.tangentVC = normalize(tangent);",
        "  output.bitangentVC = normalize(cross(output.normalVC, tangent));"
      ]).result;
      vDesc.setCode(code);
      const fDesc = pipeline.getShaderDescription("fragment");
      code = fDesc.getCode();
      if (actor.getProperty().getNormalTexture()) {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", ["  var normal: vec3<f32> = input.normalVC;", "  if (!input.frontFacing) { normal = -normal; }", "  var tangent: vec3<f32> = input.tangentVC;", "  var bitangent: vec3<f32> = input.bitangentVC;", "  var TCVCMatrix: mat3x3<f32> = mat3x3<f32>(", "    tangent.x, bitangent.x, normal.x,", "    tangent.y, bitangent.y, normal.y,", "    tangent.z, bitangent.z, normal.z,", "  );", "  var mappedNormal: vec3<f32> = TCVCMatrix * (_normalMap.xyz * 2 - 1);", "  normal = mix(normal, mappedNormal, mapperUBO.NormalStrength);", "  normal = normalize(normal);"]).result;
      } else {
        code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Normal::Impl", ["  var normal: vec3<f32> = input.normalVC;", "  if (!input.frontFacing) { normal = -normal; }", "  normal = normalize(normal);"]).result;
      }
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set("replaceShaderNormal", publicAPI.replaceShaderNormal);
  publicAPI.replaceShaderLight = (hash, pipeline, vertexInput) => {
    var _a;
    if (hash.includes("sel"))
      return;
    const vDesc = pipeline.getShaderDescription("vertex");
    if (!vDesc.hasOutput("vertexVC"))
      vDesc.addOutput("vec4<f32>", "vertexVC");
    const renderer = model.WebGPURenderer.getRenderable();
    const fDesc = pipeline.getShaderDescription("fragment");
    let code = fDesc.getCode();
    if (code.includes("var normal:") && model.useRendererMatrix && !isEdges(hash) && !model.is2D && !hash.includes("sel")) {
      const lightingCode = [
        // Vectors needed for light calculations
        "  let fragPos = vec3<f32>(input.vertexVC.xyz);",
        "  let V = mix(normalize(-fragPos), vec3<f32>(0, 0, 1), f32(rendererUBO.cameraParallel)); // View Vector",
        // Values needed for light calculations
        "  let baseColor = _diffuseMap.rgb * diffuseColor.rgb;",
        "  let roughness = max(0.000001, mapperUBO.Roughness * _roughnessMap.r);",
        // Need to have a different way of sampling greyscale values aside from .r
        "  let metallic = mapperUBO.Metallic * _metallicMap.r;",
        "  let alpha = roughness * roughness;",
        "  let k = alpha * alpha / 2.0;",
        // Split diffuse and specular components
        "  var diffuse = vec3<f32>(0.);",
        "  var specular = vec3<f32>(0.);",
        "  let emission = _emissionMap.rgb * mapperUBO.Emission;",
        "",
        "  // Material struct",
        "  let mat = Material(ior, roughness, metallic, baseColor);",
        "",
        // Summing diffuse and specular components of directional lights
        "  {",
        "    var i = 0;",
        "    loop {",
        "      if (!(i < rendererUBO.LightCount)) { break; }",
        "      switch (i32(rendererLightSSBO.values[i].LightData.x)) {",
        "         // Point Light",
        "         case 0 {",
        "           let color = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
        "           let pos = (rendererLightSSBO.values[i].LightPos).xyz;",
        "           let pointLight = PointLight(pos, color);",
        "           let result = calcPointLight(normal, V, fragPos, mat, pointLight);",
        "           diffuse += max(vec3<f32>(0), result.diffuse);",
        "           specular += max(vec3<f32>(0), result.specular);",
        "          }",
        "         // Directional light",
        "         case 1 {",
        "           let dir = normalize((rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz);",
        "           let color = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
        "           let dirLight = DirectionalLight(dir, color);",
        "           let result = calcDirectionalLight(normal, V, mat, dirLight); // diffuseColor.rgb needs to be fixed with a more dynamic diffuse color",
        "           diffuse += max(vec3<f32>(0), result.diffuse);",
        "           specular += max(vec3<f32>(0), result.specular);",
        "         }",
        "         // Spot Light",
        "         case 2 {",
        "           let color = rendererLightSSBO.values[i].LightColor.rgb * rendererLightSSBO.values[i].LightColor.w;",
        "           let pos = (rendererLightSSBO.values[i].LightPos).xyz;",
        "           let dir = normalize((rendererUBO.WCVCNormals * vec4<f32>(normalize(rendererLightSSBO.values[i].LightDir.xyz), 0.)).xyz);",
        "           let cones = vec2<f32>(rendererLightSSBO.values[i].LightData.y, rendererLightSSBO.values[i].LightData.z);",
        "           let spotLight = SpotLight(pos, dir, cones, color);",
        "           let result = calcSpotLight(normal, V, fragPos, mat, spotLight);",
        "           diffuse += max(vec3<f32>(0), result.diffuse);",
        "           specular += max(vec3<f32>(0), result.specular);",
        "         }",
        "         default { continue; }",
        "       }",
        "      continuing { i++; }",
        "    }",
        "  }",
        // Final variables for combining specular and diffuse
        "  let fresnel = min(1.0, schlickFresnelIOR(V, normal, ior, k)); // Fresnel",
        "  // This could be controlled with its own variable (that isnt base color) for better artistic control",
        "  let fresnelMetallic = schlickFresnelRGB(V, normal, baseColor); // Fresnel for metal, takes color into account",
        "  let kS = min(vec3<f32>(1.0), mix(vec3<f32>(fresnel), fresnelMetallic, metallic));",
        "  let kD = (1.0 - kS) * (1.0 - metallic);",
        "  let PBR = mapperUBO.DiffuseIntensity * kD * diffuse + kS * specular;",
        "  computedColor = vec4<f32>(PBR + emission, mapperUBO.Opacity);"
      ];
      if ((_a = renderer.getEnvironmentTexture()) == null ? void 0 : _a.getImageLoaded()) {
        lightingCode.push(
          "  // To get diffuse IBL, the texture is sampled with normals in worldspace",
          "  let diffuseIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(normal, 1.)).xyz;",
          "  let diffuseCoords = vecToRectCoord(diffuseIBLCoords);",
          "  // To get specular IBL, the texture is sampled as the worldspace reflection between the normal and view vectors",
          "  // Reflections are first calculated in viewspace, then converted to worldspace to sample the environment",
          "  let VreflN = normalize(reflect(-V, normal));",
          "  let reflectionIBLCoords = (transpose(rendererUBO.WCVCNormals) * vec4<f32>(VreflN, 1.)).xyz;",
          "  let specularCoords = vecToRectCoord(reflectionIBLCoords);",
          "  let diffuseIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, diffuseCoords, rendererUBO.MaxEnvironmentMipLevel);",
          // Level multiplier should be set by UBO
          "  let level = roughness * rendererUBO.MaxEnvironmentMipLevel;",
          "  let specularIBL = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, specularCoords, level);",
          // Manual mip smoothing since not all formats support smooth level sampling
          "  let specularIBLContribution = specularIBL.rgb * rendererUBO.BackgroundSpecularStrength;",
          "  computedColor += vec4<f32>(specularIBLContribution * kS, 0);",
          "  let diffuseIBLContribution = diffuseIBL.rgb * rendererUBO.BackgroundDiffuseStrength;",
          "  computedColor += vec4<f32>(diffuseIBLContribution * baseColor * _ambientOcclusionMap.rgb * kD, 0);"
        );
      }
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Light::Impl", lightingCode).result;
      fDesc.setCode(code);
    } else {
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Light::Impl", ["  let diffuse = diffuseColor.rgb;", "  let specular = mapperUBO.SpecularColor.rgb * mapperUBO.SpecularColor.a;", "  computedColor = vec4<f32>(diffuse * _diffuseMap.rgb, mapperUBO.Opacity);"]).result;
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set("replaceShaderLight", publicAPI.replaceShaderLight);
  publicAPI.replaceShaderColor = (hash, pipeline, vertexInput) => {
    if (isEdges(hash)) {
      const fDesc2 = pipeline.getShaderDescription("fragment");
      let code2 = fDesc2.getCode();
      code2 = vtkWebGPUShaderCache$1.substitute(code2, "//VTK::Color::Impl", ["ambientColor = mapperUBO.EdgeColor;", "diffuseColor = mapperUBO.EdgeColor;"]).result;
      fDesc2.setCode(code2);
      return;
    }
    const colorBuffer = vertexInput.getBuffer("colorVI");
    if (!colorBuffer)
      return;
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addOutput("vec4<f32>", "color", colorBuffer.getArrayInformation()[0].interpolation);
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Color::Impl", ["  output.color = colorVI;"]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    code = fDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Color::Impl", ["ambientColor = input.color;", "diffuseColor = input.color;", "opacity = mapperUBO.Opacity * input.color.a;"]).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderColor", publicAPI.replaceShaderColor);
  publicAPI.replaceShaderTCoord = (hash, pipeline, vertexInput) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if (!vertexInput.hasAttribute("tcoord"))
      return;
    const vDesc = pipeline.getShaderDescription("vertex");
    const tcoords = vertexInput.getBuffer("tcoord");
    const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);
    let code = vDesc.getCode();
    vDesc.addOutput(`vec${numComp}<f32>`, "tcoordVS");
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::TCoord::Impl", ["  output.tcoordVS = tcoord;"]).result;
    vDesc.setCode(code);
    const fDesc = pipeline.getShaderDescription("fragment");
    code = fDesc.getCode();
    const actor = model.WebGPUActor.getRenderable();
    const property = actor.getProperty();
    const checkDims = (texture) => {
      if (!texture)
        return false;
      const dims = texture.getDimensionality();
      return dims === numComp;
    };
    const usedTextures = [];
    const diffuseTexture = (_a = property.getDiffuseTexture) == null ? void 0 : _a.call(property);
    if ((diffuseTexture == null ? void 0 : diffuseTexture.getImageLoaded()) || actor.getTextures()[0] || model.colorTexture) {
      if (
        // Chained or statements here are questionable
        checkDims(diffuseTexture) || checkDims(actor.getTextures()[0]) || checkDims(model.colorTexture)
      ) {
        usedTextures.push("_diffuseMap = textureSample(DiffuseTexture, DiffuseTextureSampler, input.tcoordVS);");
      }
    }
    const ormTexture = (_b = property.getORMTexture) == null ? void 0 : _b.call(property);
    const rmTexture = (_c = property.getRMTexture) == null ? void 0 : _c.call(property);
    const roughnessTexture = (_d = property.getRoughnessTexture) == null ? void 0 : _d.call(property);
    const metallicTexture = (_e = property.getMetallicTexture) == null ? void 0 : _e.call(property);
    const ambientOcclusionTexture = (_f = property.getAmbientOcclusionTexture) == null ? void 0 : _f.call(property);
    const emissionTexture = (_g = property.getEmissionTexture) == null ? void 0 : _g.call(property);
    const normalTexture = (_h = property.getNormalTexture) == null ? void 0 : _h.call(property);
    if (ormTexture == null ? void 0 : ormTexture.getImageLoaded()) {
      if (checkDims(ormTexture)) {
        usedTextures.push("_ambientOcclusionMap = textureSample(ORMTexture, ORMTextureSampler, input.tcoordVS).rrra;", "_roughnessMap = textureSample(ORMTexture, ORMTextureSampler, input.tcoordVS).ggga;", "_metallicMap = textureSample(ORMTexture, ORMTextureSampler, input.tcoordVS).bbba;");
      }
    } else if (rmTexture == null ? void 0 : rmTexture.getImageLoaded()) {
      if (checkDims(rmTexture)) {
        usedTextures.push("_roughnessMap = textureSample(RMTexture, RMTextureSampler, input.tcoordVS).ggga;", "_metallicMap = textureSample(RMTexture, RMTextureSampler, input.tcoordVS).bbba;");
      }
    } else {
      if (roughnessTexture == null ? void 0 : roughnessTexture.getImageLoaded()) {
        if (checkDims(roughnessTexture)) {
          usedTextures.push("_roughnessMap = textureSample(RoughnessTexture, RoughnessTextureSampler, input.tcoordVS).ggga;");
        }
      }
      if (metallicTexture == null ? void 0 : metallicTexture.getImageLoaded()) {
        if (checkDims(metallicTexture)) {
          usedTextures.push("_metallicMap = textureSample(MetallicTexture, MetallicTextureSampler, input.tcoordVS).bbba;");
        }
      }
      if (ambientOcclusionTexture == null ? void 0 : ambientOcclusionTexture.getImageLoaded()) {
        if (checkDims(ambientOcclusionTexture)) {
          usedTextures.push("_ambientOcclusionMap = textureSample(AmbientOcclusionTexture, AmbientOcclusionTextureSampler, input.tcoordVS).rrra;");
        }
      }
    }
    if (emissionTexture == null ? void 0 : emissionTexture.getImageLoaded()) {
      if (checkDims(emissionTexture)) {
        usedTextures.push("_emissionMap = textureSample(EmissionTexture, EmissionTextureSampler, input.tcoordVS);");
      }
    }
    if (normalTexture == null ? void 0 : normalTexture.getImageLoaded()) {
      if (checkDims(normalTexture)) {
        usedTextures.push("_normalMap = textureSample(NormalTexture, NormalTextureSampler, input.tcoordVS);");
      }
    }
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::TCoord::Impl", usedTextures).result;
    fDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderTCoord", publicAPI.replaceShaderTCoord);
  publicAPI.replaceShaderSelect = (hash, pipeline, vertexInput) => {
    if (hash.includes("sel")) {
      const fDesc = pipeline.getShaderDescription("fragment");
      let code = fDesc.getCode();
      code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Select::Impl", ["  var compositeID: u32 = 0u;"]).result;
      fDesc.setCode(code);
    }
  };
  model.shaderReplacements.set("replaceShaderSelect", publicAPI.replaceShaderSelect);
  publicAPI.getUsage = (rep, i) => {
    if (rep === Representation5.POINTS || i === PrimitiveTypes3.Points) {
      return BufferUsage4.Verts;
    }
    if (i === PrimitiveTypes3.Lines) {
      return BufferUsage4.Lines;
    }
    if (rep === Representation5.WIREFRAME) {
      if (i === PrimitiveTypes3.Triangles) {
        return BufferUsage4.LinesFromTriangles;
      }
      return BufferUsage4.LinesFromStrips;
    }
    if (i === PrimitiveTypes3.Triangles) {
      return BufferUsage4.Triangles;
    }
    if (i === PrimitiveTypes3.TriangleStrips) {
      return BufferUsage4.Strips;
    }
    if (i === PrimitiveTypes3.TriangleEdges) {
      return BufferUsage4.LinesFromTriangles;
    }
    return BufferUsage4.LinesFromStrips;
  };
  publicAPI.getHashFromUsage = (usage) => `pt${usage}`;
  publicAPI.getTopologyFromUsage = (usage) => {
    switch (usage) {
      case BufferUsage4.Triangles:
        return "triangle-list";
      case BufferUsage4.Verts:
        return "point-list";
      case BufferUsage4.Lines:
      default:
        return "line-list";
    }
  };
  publicAPI.buildVertexInput = () => {
    var _a, _b, _c;
    const pd = model.currentInput;
    const cells = model.cellArray;
    const primType = model.primitiveType;
    const actor = model.WebGPUActor.getRenderable();
    let representation = actor.getProperty().getRepresentation();
    const device = model.WebGPURenderWindow.getDevice();
    let edges = false;
    if (primType === PrimitiveTypes3.TriangleEdges) {
      edges = true;
      representation = Representation5.WIREFRAME;
    }
    const vertexInput = model.vertexInput;
    const points = pd.getPoints();
    let indexBuffer = null;
    if (cells) {
      indexBuffer = device.getBufferManager().getBuffer({
        hash: `R${representation}P${primType}${cells.getMTime()}`,
        usage: BufferUsage4.Index,
        cells,
        numberOfPoints: points.getNumberOfPoints(),
        primitiveType: primType,
        representation
      });
      vertexInput.setIndexBuffer(indexBuffer);
    } else {
      vertexInput.setIndexBuffer(null);
    }
    if (points) {
      const shift = model.WebGPUActor.getBufferShift(model.WebGPURenderer);
      vertexInput.addBuffer(device.getBufferManager().getBuffer({
        hash: `${points.getMTime()}I${((_a = indexBuffer == null ? void 0 : indexBuffer.getMTime) == null ? void 0 : _a.call(indexBuffer)) ?? 0}${shift.join()}float32x4`,
        usage: BufferUsage4.PointArray,
        format: "float32x4",
        dataArray: points,
        indexBuffer,
        shift,
        packExtra: true
      }), ["vertexBC"]);
    } else {
      vertexInput.removeBufferIfPresent("vertexBC");
    }
    const usage = publicAPI.getUsage(representation, primType);
    model._usesCellNormals = false;
    if (!model.is2D && // no lighting on Property2D
    (usage === BufferUsage4.Triangles || usage === BufferUsage4.Strips)) {
      const normals = pd.getPointData().getNormals();
      const buffRequest = {
        format: "snorm8x4",
        indexBuffer,
        packExtra: true,
        shift: 0,
        scale: 127
      };
      if (normals) {
        buffRequest.hash = `${normals.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;
        buffRequest.dataArray = normals;
        buffRequest.usage = BufferUsage4.PointArray;
        vertexInput.addBuffer(device.getBufferManager().getBuffer(buffRequest), ["normalMC"]);
      } else if (primType === PrimitiveTypes3.Triangles) {
        model._usesCellNormals = true;
        buffRequest.hash = `PFN${points.getMTime()}I${indexBuffer.getMTime()}snorm8x4`;
        buffRequest.dataArray = points;
        buffRequest.cells = cells;
        buffRequest.usage = BufferUsage4.NormalsFromPoints;
        vertexInput.addBuffer(device.getBufferManager().getBuffer(buffRequest), ["normalMC"]);
      } else {
        vertexInput.removeBufferIfPresent("normalMC");
      }
    } else {
      vertexInput.removeBufferIfPresent("normalMC");
    }
    let haveColors = false;
    if (model.renderable.getScalarVisibility()) {
      const c = model.renderable.getColorMapColors();
      if (c && !edges) {
        const scalarMode = model.renderable.getScalarMode();
        const haveCellScalars = (scalarMode === ScalarMode4.USE_CELL_DATA || scalarMode === ScalarMode4.USE_CELL_FIELD_DATA || scalarMode === ScalarMode4.USE_FIELD_DATA || !pd.getPointData().getScalars()) && scalarMode !== ScalarMode4.USE_POINT_FIELD_DATA && c;
        vertexInput.addBuffer(device.getBufferManager().getBuffer({
          usage: BufferUsage4.PointArray,
          format: "unorm8x4",
          hash: `${haveCellScalars}${c.getMTime()}I${indexBuffer.getMTime()}unorm8x4`,
          dataArray: c,
          indexBuffer,
          cellData: haveCellScalars,
          cellOffset: 0
        }), ["colorVI"]);
        haveColors = true;
      }
    }
    if (!haveColors)
      vertexInput.removeBufferIfPresent("colorVI");
    let tcoords = null;
    if (((_c = (_b = model.renderable).getInterpolateScalarsBeforeMapping) == null ? void 0 : _c.call(_b)) && model.renderable.getColorCoordinates()) {
      tcoords = model.renderable.getColorCoordinates();
    } else {
      tcoords = pd.getPointData().getTCoords();
    }
    if (tcoords && !edges) {
      vertexInput.addBuffer(device.getBufferManager().getBufferForPointArray(tcoords, vertexInput.getIndexBuffer()), ["tcoord"]);
    } else {
      vertexInput.removeBufferIfPresent("tcoord");
    }
  };
  publicAPI.updateTextures = () => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    const usedTextures = [];
    const newTextures = [];
    const idata = (_b = (_a = model.renderable).getColorTextureMap) == null ? void 0 : _b.call(_a);
    if (idata && !model.colorTexture) {
      model.colorTexture = vtkTexture$1.newInstance({
        label: "polyDataColor"
      });
    }
    if (idata) {
      model.colorTexture.setInputData(idata);
      newTextures.push(["DiffuseTexture", model.colorTexture]);
    }
    const actor = model.WebGPUActor.getRenderable();
    const renderer = model.WebGPURenderer.getRenderable();
    const textures = [["DiffuseTexture", (_d = (_c = actor.getProperty()).getDiffuseTexture) == null ? void 0 : _d.call(_c)], ["DiffuseTexture", actor.getTextures()[0]], ["DiffuseTexture", model.colorTexture], ["ORMTexture", (_f = (_e = actor.getProperty()).getORMTexture) == null ? void 0 : _f.call(_e)], ["RMTexture", (_h = (_g = actor.getProperty()).getRMTexture) == null ? void 0 : _h.call(_g)], ["RoughnessTexture", (_j = (_i = actor.getProperty()).getRoughnessTexture) == null ? void 0 : _j.call(_i)], ["MetallicTexture", (_l = (_k = actor.getProperty()).getMetallicTexture) == null ? void 0 : _l.call(_k)], ["NormalTexture", (_n = (_m = actor.getProperty()).getNormalTexture) == null ? void 0 : _n.call(_m)], ["AmbientOcclusionTexture", (_p = (_o = actor.getProperty()).getAmbientOcclusionTexture) == null ? void 0 : _p.call(_o)], ["EmissionTexture", (_r = (_q = actor.getProperty()).getEmissionTexture) == null ? void 0 : _r.call(_q)], ["EnvironmentTexture", (_s = renderer.getEnvironmentTexture) == null ? void 0 : _s.call(renderer)]];
    textures.forEach((_ref) => {
      let [name, tex] = _ref;
      if (!tex)
        return;
      if (tex.getInputData() || tex.getJsImageData() || tex.getCanvas() || tex.getImageBitmap()) {
        newTextures.push([name, tex]);
      }
      if (tex.getImage() && tex.getImageLoaded()) {
        newTextures.push([name, tex]);
      }
    });
    newTextures.forEach((_ref2) => {
      let [textureName, srcTexture] = _ref2;
      const newTex = model.device.getTextureManager().getTextureForVTKTexture(srcTexture, textureName);
      if (!newTex.getReady())
        return;
      let found = false;
      for (let t = 0; t < model.textures.length; ++t) {
        if (model.textures[t] === newTex) {
          found = true;
          usedTextures[t] = true;
          break;
        }
      }
      if (!found) {
        usedTextures[model.textures.length] = true;
        const tview = newTex.createView(textureName);
        model.textures.push(newTex);
        model.textureViews.push(tview);
        const interpolate = srcTexture.getInterpolate() ? "linear" : "nearest";
        let addressMode = null;
        if (srcTexture.getEdgeClamp() && srcTexture.getRepeat())
          addressMode = "mirror-repeat";
        else if (srcTexture.getEdgeClamp())
          addressMode = "clamp-to-edge";
        else if (srcTexture.getRepeat())
          addressMode = "repeat";
        let options = {
          addressModeU: addressMode,
          addressModeV: addressMode,
          addressModeW: addressMode,
          minFilter: interpolate,
          magFilter: interpolate
        };
        if (textureName === "EnvironmentTexture") {
          options = {
            addressModeU: "repeat",
            addressModeV: "clamp-to-edge",
            addressModeW: "repeat",
            minFilter: interpolate,
            magFilter: interpolate,
            mipmapFilter: "linear"
          };
        }
        tview.addSampler(model.device, options);
      }
    });
    for (let i = model.textures.length - 1; i >= 0; i--) {
      if (!usedTextures[i]) {
        model.textures.splice(i, 1);
        model.textureViews.splice(i, 1);
      }
    }
  };
  publicAPI.computePipelineHash = () => {
    let pipelineHash = `pd${model.useRendererMatrix ? "r" : ""}${model.forceZValue ? "z" : ""}`;
    if (model.primitiveType === PrimitiveTypes3.TriangleEdges || model.primitiveType === PrimitiveTypes3.TriangleStripEdges) {
      pipelineHash += "edge";
    } else {
      if (model.vertexInput.hasAttribute(`normalMC`)) {
        pipelineHash += `n`;
      }
      if (model.vertexInput.hasAttribute(`colorVI`)) {
        pipelineHash += `c`;
      }
      if (model.vertexInput.hasAttribute(`tcoord`)) {
        const tcoords = model.vertexInput.getBuffer("tcoord");
        const numComp = vtkWebGPUTypes.getNumberOfComponentsFromBufferFormat(tcoords.getArrayInformation()[0].format);
        pipelineHash += `t${numComp}`;
      }
      if (model.textures.length) {
        pipelineHash += `tx${model.textures.length}`;
      }
    }
    if (model._usesCellNormals) {
      pipelineHash += `cn`;
    }
    if (model.SSBO) {
      pipelineHash += `ssbo`;
    }
    const uhash = publicAPI.getHashFromUsage(model.usage);
    pipelineHash += uhash;
    pipelineHash += model.renderEncoder.getPipelineHash();
    model.pipelineHash = pipelineHash;
  };
  publicAPI.updateBuffers = () => {
    if (model.primitiveType !== PrimitiveTypes3.TriangleEdges && model.primitiveType !== PrimitiveTypes3.TriangleStripEdges) {
      publicAPI.updateTextures();
    }
    const actor = model.WebGPUActor.getRenderable();
    const rep = actor.getProperty().getRepresentation();
    model.usage = publicAPI.getUsage(rep, model.primitiveType);
    publicAPI.buildVertexInput();
    const vbo = model.vertexInput.getBuffer("vertexBC");
    publicAPI.setNumberOfVertices(vbo.getSizeInBytes() / vbo.getStrideInBytes());
    publicAPI.setTopology(publicAPI.getTopologyFromUsage(model.usage));
    publicAPI.updateUBO();
    if (publicAPI.haveWideLines()) {
      const ppty = actor.getProperty();
      publicAPI.setNumberOfInstances(Math.ceil(ppty.getLineWidth() * 2));
    } else {
      publicAPI.setNumberOfInstances(1);
    }
  };
}
var DEFAULT_VALUES69 = {
  is2D: false,
  cellArray: null,
  currentInput: null,
  cellOffset: 0,
  primitiveType: 0,
  colorTexture: null,
  renderEncoder: null,
  textures: null
};
function extend74(publicAPI, model) {
  let initiaLalues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES69, initiaLalues);
  vtkWebGPUSimpleMapper$1.extend(publicAPI, model, initiaLalues);
  model.fragmentShaderTemplate = vtkWebGPUPolyDataFS;
  model.vertexShaderTemplate = vtkWebGPUPolyDataVS;
  model._tmpMat3 = mat3_exports.identity(new Float64Array(9));
  model._tmpMat4 = mat4_exports.identity(new Float64Array(16));
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "mapperUBO"
  });
  model.UBO.addEntry("BCWCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("BCSCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("MCWCNormals", "mat4x4<f32>");
  model.UBO.addEntry("AmbientColor", "vec4<f32>");
  model.UBO.addEntry("DiffuseColor", "vec4<f32>");
  model.UBO.addEntry("EdgeColor", "vec4<f32>");
  model.UBO.addEntry("SpecularColor", "vec4<f32>");
  model.UBO.addEntry("AmbientIntensity", "f32");
  model.UBO.addEntry("DiffuseIntensity", "f32");
  model.UBO.addEntry("Roughness", "f32");
  model.UBO.addEntry("Metallic", "f32");
  model.UBO.addEntry("Ambient", "f32");
  model.UBO.addEntry("Normal", "f32");
  model.UBO.addEntry("Emission", "f32");
  model.UBO.addEntry("NormalStrength", "f32");
  model.UBO.addEntry("BaseIOR", "f32");
  model.UBO.addEntry("SpecularIntensity", "f32");
  model.UBO.addEntry("LineWidth", "f32");
  model.UBO.addEntry("Opacity", "f32");
  model.UBO.addEntry("ZValue", "f32");
  model.UBO.addEntry("PropID", "u32");
  model.UBO.addEntry("ClipNear", "f32");
  model.UBO.addEntry("ClipFar", "f32");
  model.UBO.addEntry("Time", "u32");
  setGet(publicAPI, model, ["cellArray", "currentInput", "cellOffset", "is2D", "primitiveType", "renderEncoder"]);
  model.textures = [];
  vtkWebGPUCellArrayMapper(publicAPI, model);
}
var newInstance73 = newInstance(extend74, "vtkWebGPUCellArrayMapper");
var vtkWebGPUCellArrayMapper$1 = {
  newInstance: newInstance73,
  extend: extend74
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/PolyDataMapper.js
var {
  PrimitiveTypes: PrimitiveTypes4
} = vtkWebGPUBufferManager$1;
function vtkWebGPUPolyDataMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPolyDataMapper");
  publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper$1.newInstance();
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor");
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      const poly = model.renderable.getInputData();
      model.renderable.mapScalars(poly, 1);
      publicAPI.updateCellArrayMappers(poly);
    }
  };
  publicAPI.updateCellArrayMappers = (poly) => {
    if (!poly) {
      vtkErrorMacro("No input!");
      return;
    }
    const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];
    const cellMappers = [];
    let cellOffset = 0;
    for (let i = PrimitiveTypes4.Points; i <= PrimitiveTypes4.TriangleStrips; i++) {
      if (prims[i].getNumberOfValues() > 0) {
        if (!model.primitives[i]) {
          model.primitives[i] = publicAPI.createCellArrayMapper();
        }
        const cellMapper = model.primitives[i];
        cellMapper.setCellArray(prims[i]);
        cellMapper.setCurrentInput(poly);
        cellMapper.setCellOffset(cellOffset);
        cellMapper.setPrimitiveType(i);
        cellMapper.setRenderable(model.renderable);
        cellOffset += prims[i].getNumberOfCells();
        cellMappers.push(cellMapper);
      } else {
        model.primitives[i] = null;
      }
    }
    if (model.WebGPUActor.getRenderable().getProperty().getEdgeVisibility()) {
      if (prims[PrimitiveTypes4.Triangles].getNumberOfValues() > 0) {
        const i = PrimitiveTypes4.TriangleEdges;
        if (!model.primitives[i]) {
          model.primitives[i] = publicAPI.createCellArrayMapper();
        }
        const cellMapper = model.primitives[i];
        cellMapper.setCellArray(prims[PrimitiveTypes4.Triangles]);
        cellMapper.setCurrentInput(poly);
        cellMapper.setCellOffset(model.primitives[PrimitiveTypes4.Triangles].getCellOffset());
        cellMapper.setPrimitiveType(i);
        cellMapper.setRenderable(model.renderable);
        cellMappers.push(cellMapper);
      } else {
        model.primitives[PrimitiveTypes4.TriangleEdges] = null;
      }
      if (prims[PrimitiveTypes4.TriangleStrips].getNumberOfValues() > 0) {
        const i = PrimitiveTypes4.TriangleStripEdges;
        if (!model.primitives[i]) {
          model.primitives[i] = publicAPI.createCellArrayMapper();
        }
        const cellMapper = model.primitives[i];
        cellMapper.setCellArray(prims[PrimitiveTypes4.TriangleStrips]);
        cellMapper.setCurrentInput(poly);
        cellMapper.setCellOffset(model.primitives[PrimitiveTypes4.TriangleStrips].getCellOffset());
        cellMapper.setPrimitiveType(i);
        cellMapper.setRenderable(model.renderable);
        cellMappers.push(cellMapper);
      } else {
        model.primitives[PrimitiveTypes4.TriangleStripEdges] = null;
      }
    }
    publicAPI.prepareNodes();
    publicAPI.addMissingChildren(cellMappers);
    publicAPI.removeUnusedNodes();
  };
}
var DEFAULT_VALUES70 = {
  primitives: null
};
function extend75(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES70, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.primitives = [];
  vtkWebGPUPolyDataMapper(publicAPI, model);
}
var newInstance74 = newInstance(extend75, "vtkWebGPUPolyDataMapper");
var vtkWebGPUPolyDataMapper$1 = {
  newInstance: newInstance74,
  extend: extend75
};
registerOverride2("vtkMapper", newInstance74);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/PixelSpaceCallbackMapper.js
function vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPixelSpaceCallbackMapper");
  publicAPI.opaquePass = (prepass, renderPass) => {
    model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
    model.WebGPURenderWindow = model.WebGPURenderer.getParent();
    const aspectRatio = model.WebGPURenderer.getAspectRatio();
    const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
    const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
    const texels = null;
    if (model.renderable.getUseZValues())
      ;
    model.renderable.invokeCallback(model.renderable.getInputData(), camera, aspectRatio, tsize, texels);
  };
}
var DEFAULT_VALUES71 = {};
function extend76(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES71, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  vtkWebGPUPixelSpaceCallbackMapper(publicAPI, model);
}
var newInstance75 = macro.newInstance(extend76, "vtkWebGPUPixelSpaceCallbackMapper");
registerOverride2("vtkPixelSpaceCallbackMapper", newInstance75);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/PolyDataMapper2D.js
var {
  PrimitiveTypes: PrimitiveTypes5
} = vtkWebGPUBufferManager$1;
function vtkWebGPUPolyDataMapper2D(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUPolyDataMapper2D");
  publicAPI.createCellArrayMapper = () => vtkWebGPUCellArrayMapper$1.newInstance();
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPUActor = publicAPI.getFirstAncestorOfType("vtkWebGPUActor2D");
      if (!model.renderable.getStatic()) {
        model.renderable.update();
      }
      const poly = model.renderable.getInputData();
      model.renderable.mapScalars(poly, 1);
      publicAPI.updateCellArrayMappers(poly);
    }
  };
  publicAPI.updateCellArrayMappers = (poly) => {
    const prims = [poly.getVerts(), poly.getLines(), poly.getPolys(), poly.getStrips()];
    const cellMappers = [];
    let cellOffset = 0;
    for (let i = PrimitiveTypes5.Points; i <= PrimitiveTypes5.Triangles; i++) {
      if (prims[i].getNumberOfValues() > 0) {
        if (!model.primitives[i]) {
          model.primitives[i] = publicAPI.createCellArrayMapper();
        }
        const cellMapper = model.primitives[i];
        cellMapper.setCellArray(prims[i]);
        cellMapper.setCurrentInput(poly);
        cellMapper.setCellOffset(cellOffset);
        cellMapper.setPrimitiveType(i);
        cellMapper.setRenderable(model.renderable);
        cellMapper.setIs2D(true);
        cellOffset += prims[i].getNumberOfCells();
        cellMappers.push(cellMapper);
      } else {
        model.primitives[i] = null;
      }
    }
    publicAPI.prepareNodes();
    publicAPI.addMissingChildren(cellMappers);
    publicAPI.removeUnusedNodes();
  };
}
function defaultValues5(initialValues) {
  return {
    primitives: [],
    ...initialValues
  };
}
function extend77(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, defaultValues5(initialValues));
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.primitives = [];
  vtkWebGPUPolyDataMapper2D(publicAPI, model);
}
var newInstance76 = newInstance(extend77, "vtkWebGPUPolyDataMapper2D");
registerOverride2("vtkMapper2D", newInstance76);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/FullScreenQuad.js
function vtkWebGPUFullScreenQuad(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUFullScreenQuad");
  publicAPI.replaceShaderPosition = (hash, pipeline, vertexInput) => {
    const vDesc = pipeline.getShaderDescription("vertex");
    vDesc.addBuiltinOutput("vec4<f32>", "@builtin(position) Position");
    vDesc.addOutput("vec4<f32>", "vertexVC");
    let code = vDesc.getCode();
    code = vtkWebGPUShaderCache$1.substitute(code, "//VTK::Position::Impl", ["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);", "output.Position = vec4<f32>(vertexBC, 1.0);", "output.vertexVC = vec4<f32>(vertexBC, 1);"]).result;
    vDesc.setCode(code);
  };
  model.shaderReplacements.set("replaceShaderPosition", publicAPI.replaceShaderPosition);
  publicAPI.updateBuffers = () => {
    const buff = model.device.getBufferManager().getFullScreenQuadBuffer();
    model.vertexInput.addBuffer(buff, ["vertexBC"]);
    model.numberOfVertices = 6;
  };
}
var DEFAULT_VALUES72 = {};
function extend78(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES72, initialValues);
  vtkWebGPUSimpleMapper$1.extend(publicAPI, model, initialValues);
  vtkWebGPUFullScreenQuad(publicAPI, model);
}
var newInstance77 = macro.newInstance(extend78, "vtkWebGPUFullScreenQuad");
var vtkWebGPUFullScreenQuad$1 = {
  newInstance: newInstance77,
  extend: extend78
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/StorageBuffer.js
var {
  BufferUsage: BufferUsage5
} = vtkWebGPUBufferManager$1;
var {
  vtkErrorMacro: vtkErrorMacro18
} = macro;
function vtkWebGPUStorageBuffer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUStorageBuffer");
  publicAPI.addEntry = (name, type) => {
    if (model._bufferEntryNames.has(name)) {
      vtkErrorMacro18(`entry named ${name} already exists`);
      return;
    }
    model._bufferEntryNames.set(name, model.bufferEntries.length);
    const sizeInBytes = vtkWebGPUTypes.getByteStrideFromShaderFormat(type);
    model.bufferEntries.push({
      name,
      type,
      sizeInBytes,
      offset: model.sizeInBytes,
      nativeType: vtkWebGPUTypes.getNativeTypeFromShaderFormat(type)
    });
    model.sizeInBytes += sizeInBytes;
  };
  publicAPI.send = (device) => {
    if (!model._buffer) {
      const req = {
        nativeArray: model.Float32Array,
        usage: BufferUsage5.Storage,
        label: model.label
      };
      model._buffer = device.getBufferManager().getBuffer(req);
      model.bindGroupTime.modified();
      model._sendTime.modified();
      return;
    }
    device.getHandle().queue.writeBuffer(model._buffer.getHandle(), 0, model.arrayBuffer, 0, model.sizeInBytes * model.numberOfInstances);
    model._sendTime.modified();
  };
  publicAPI.createView = (type) => {
    if (type in model === false) {
      if (!model.arrayBuffer) {
        model.arrayBuffer = new ArrayBuffer(model.sizeInBytes * model.numberOfInstances);
      }
      model[type] = macro.newTypedArray(type, model.arrayBuffer);
    }
  };
  publicAPI.setValue = (name, instance, val) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro18(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    view[(entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT] = val;
  };
  publicAPI.setArray = (name, instance, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro18(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const ioffset = (entry.offset + instance * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
    for (let i = 0; i < arr.length; i++) {
      view[ioffset + i] = arr[i];
    }
  };
  publicAPI.setAllInstancesFromArray = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro18(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = arr.length / model.numberOfInstances;
    for (let inst = 0; inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let i = 0; i < numComponents; i++) {
        view[ioffset + i] = arr[inst * numComponents + i];
      }
    }
  };
  publicAPI.setAllInstancesFromArrayColorToFloat = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro18(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = arr.length / model.numberOfInstances;
    for (let inst = 0; inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let i = 0; i < numComponents; i++) {
        view[ioffset + i] = arr[inst * numComponents + i] / 255;
      }
    }
  };
  publicAPI.setAllInstancesFromArray3x3To4x4 = (name, arr) => {
    const idx = model._bufferEntryNames.get(name);
    if (idx === void 0) {
      vtkErrorMacro18(`entry named ${name} not found in UBO`);
      return;
    }
    const entry = model.bufferEntries[idx];
    publicAPI.createView(entry.nativeType);
    const view = model[entry.nativeType];
    const numComponents = 9;
    for (let inst = 0; inst < model.numberOfInstances; inst++) {
      const ioffset = (entry.offset + inst * model.sizeInBytes) / view.BYTES_PER_ELEMENT;
      for (let j = 0; j < 3; j++) {
        for (let i = 0; i < 3; i++) {
          view[ioffset + j * 4 + i] = arr[inst * numComponents + j * 3 + i];
        }
      }
    }
  };
  publicAPI.getSendTime = () => model._sendTime.getMTime();
  publicAPI.getShaderCode = (binding, group2) => {
    const lines = [`struct ${model.label}StructEntry
{`];
    for (let i = 0; i < model.bufferEntries.length; i++) {
      const entry = model.bufferEntries[i];
      lines.push(`  ${entry.name}: ${entry.type},`);
    }
    lines.push(`
};
struct ${model.label}Struct
{
  values: array<${model.label}StructEntry>,
};
@binding(${binding}) @group(${group2}) var<storage, read> ${model.label}: ${model.label}Struct;
`);
    return lines.join("\n");
  };
  publicAPI.getBindGroupEntry = () => {
    const foo = {
      resource: {
        buffer: model._buffer.getHandle()
      }
    };
    return foo;
  };
  publicAPI.clearData = () => {
    model.numberOfInstances = 0;
    model.sizeInBytes = 0;
    model.bufferEntries = [];
    model._bufferEntryNames = /* @__PURE__ */ new Map();
    model._buffer = null;
    delete model.arrayBuffer;
    delete model.Float32Array;
  };
}
var DEFAULT_VALUES73 = {
  bufferEntries: null,
  bufferEntryNames: null,
  sizeInBytes: 0,
  label: null,
  numberOfInstances: 1
};
function extend79(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES73, initialValues);
  macro.obj(publicAPI, model);
  model._bufferEntryNames = /* @__PURE__ */ new Map();
  model.bufferEntries = [];
  model._sendTime = {};
  macro.obj(model._sendTime, {
    mtime: 0
  });
  model.bindGroupTime = {};
  macro.obj(model.bindGroupTime, {
    mtime: 0
  });
  model.bindGroupLayoutEntry = model.bindGroupLayoutEntry || {
    buffer: {
      type: "read-only-storage"
    }
  };
  macro.get(publicAPI, model, ["bindGroupTime"]);
  macro.setGet(publicAPI, model, ["device", "bindGroupLayoutEntry", "label", "numberOfInstances", "sizeInBytes"]);
  vtkWebGPUStorageBuffer(publicAPI, model);
}
var newInstance78 = macro.newInstance(extend79, "vtkWebGPUStorageBuffer");
var vtkWebGPUStorageBuffer$1 = {
  newInstance: newInstance78,
  extend: extend79
};

// node_modules/@kitware/vtk.js/Rendering/WebGPU/Renderer.js
var {
  vtkDebugMacro: vtkDebugMacro4
} = macro$1;
var clearFragColorTemplate = `
//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var computedColor: vec4<f32> = mapperUBO.BackgroundColor;

  //VTK::RenderEncoder::Impl
  return output;
}
`;
var clearFragTextureTemplate = `
fn vecToRectCoord(dir: vec3<f32>) -> vec2<f32> {
  var tau: f32 = 6.28318530718;
  var pi: f32 = 3.14159265359;
  var out: vec2<f32> = vec2<f32>(0.0);

  out.x = atan2(dir.z, dir.x) / tau;
  out.x += 0.5;

  var phix: f32 = length(vec2(dir.x, dir.z));
  out.y = atan2(dir.y, phix) / pi + 0.5;

  return out;
}

//VTK::Renderer::Dec

//VTK::Mapper::Dec

//VTK::TCoord::Dec

//VTK::RenderEncoder::Dec

//VTK::IOStructs::Dec

@fragment
fn main(
//VTK::IOStructs::Input
)
//VTK::IOStructs::Output
{
  var output: fragmentOutput;

  var tcoord: vec4<f32> = vec4<f32>(input.vertexVC.xy, -1, 1);
  var V: vec4<f32> = normalize(mapperUBO.FSQMatrix * tcoord); // vec2<f32>((input.tcoordVS.x - 0.5) * 2, -(input.tcoordVS.y - 0.5) * 2);
  // textureSampleLevel gets rid of some ugly artifacts
  var background = textureSampleLevel(EnvironmentTexture, EnvironmentTextureSampler, vecToRectCoord(V.xyz), 0.0);
  var computedColor: vec4<f32> = vec4<f32>(background.rgb, 1);

  //VTK::RenderEncoder::Impl
  return output;
}
`;
var _fsqClearMat4 = new Float64Array(16);
var _tNormalMat4 = new Float64Array(16);
function getLightTypeIndex(light) {
  if (light.getPositional()) {
    if (light.getConeAngle() >= 90) {
      return 0;
    }
    return 2;
  }
  return 1;
}
function vtkWebGPURenderer(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPURenderer");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      if (!model.renderable) {
        return;
      }
      model.camera = model.renderable.getActiveCamera();
      publicAPI.updateLights();
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.camera);
      publicAPI.addMissingNodes(model.renderable.getViewPropsWithNestedProps());
      publicAPI.removeUnusedNodes();
      model.webgpuCamera = publicAPI.getViewNodeFor(model.camera, model.webgpuCamera);
      publicAPI.updateStabilizedMatrix();
    }
  };
  publicAPI.updateStabilizedMatrix = () => {
    const clipRange = model.camera.getClippingRange();
    const pos = model.camera.getPositionByReference();
    const dop = model.camera.getDirectionOfProjectionByReference();
    const center = [];
    const offset = [];
    vec3_exports.scale(offset, dop, 0.5 * (clipRange[0] + clipRange[1]));
    vec3_exports.add(center, pos, offset);
    vec3_exports.sub(offset, center, model.stabilizedCenter);
    const length4 = vec3_exports.len(offset);
    if (length4 / (clipRange[1] - clipRange[0]) > model.recenterThreshold) {
      model.stabilizedCenter = center;
      model.stabilizedTime.modified();
    }
  };
  publicAPI.updateLights = () => {
    let count2 = 0;
    const lights = model.renderable.getLightsByReference();
    for (let index2 = 0; index2 < lights.length; ++index2) {
      if (lights[index2].getSwitch() > 0) {
        count2++;
      }
    }
    if (!count2) {
      vtkDebugMacro4("No lights are on, creating one.");
      model.renderable.createLight();
    }
    return count2;
  };
  publicAPI.updateUBO = () => {
    var _a;
    const utime = model.UBO.getSendTime();
    if (model._parent.getMTime() > utime || publicAPI.getMTime() > utime || model.camera.getMTime() > utime || model.renderable.getMTime() > utime) {
      const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
      model.UBO.setArray("WCVCMatrix", keyMats.wcvc);
      model.UBO.setArray("SCPCMatrix", keyMats.scpc);
      model.UBO.setArray("PCSCMatrix", keyMats.pcsc);
      model.UBO.setArray("SCVCMatrix", keyMats.scvc);
      model.UBO.setArray("VCPCMatrix", keyMats.vcpc);
      model.UBO.setArray("WCVCNormals", keyMats.normalMatrix);
      model.UBO.setValue("LightCount", model.renderable.getLights().length);
      model.UBO.setValue("MaxEnvironmentMipLevel", (_a = model.renderable.getEnvironmentTexture()) == null ? void 0 : _a.getMipLevel());
      model.UBO.setValue("BackgroundDiffuseStrength", model.renderable.getEnvironmentTextureDiffuseStrength());
      model.UBO.setValue("BackgroundSpecularStrength", model.renderable.getEnvironmentTextureSpecularStrength());
      const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
      model.UBO.setArray("viewportSize", [tsize.usize, tsize.vsize]);
      model.UBO.setValue("cameraParallel", model.camera.getParallelProjection());
      const device = model._parent.getDevice();
      model.UBO.sendIfNeeded(device);
    }
  };
  publicAPI.updateSSBO = () => {
    const lights = model.renderable.getLights();
    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
    let lightTimeString = `${model.renderable.getMTime()}`;
    for (let i = 0; i < lights.length; i++) {
      lightTimeString += lights[i].getMTime();
    }
    if (lightTimeString !== model.lightTimeString) {
      const lightPosArray = new Float32Array(lights.length * 4);
      const lightDirArray = new Float32Array(lights.length * 4);
      const lightColorArray = new Float32Array(lights.length * 4);
      const lightTypeArray = new Float32Array(lights.length * 4);
      for (let i = 0; i < lights.length; i++) {
        const offset = i * 4;
        const viewCoordinatePosition = lights[i].getPosition();
        vec3_exports.transformMat4(viewCoordinatePosition, viewCoordinatePosition, keyMats.wcvc);
        lightPosArray[offset] = viewCoordinatePosition[0];
        lightPosArray[offset + 1] = viewCoordinatePosition[1];
        lightPosArray[offset + 2] = viewCoordinatePosition[2];
        lightPosArray[offset + 3] = 0;
        lightDirArray[offset] = -lights[i].getDirection()[0];
        lightDirArray[offset + 1] = -lights[i].getDirection()[1];
        lightDirArray[offset + 2] = -lights[i].getDirection()[2];
        lightDirArray[offset + 3] = 0;
        lightColorArray[offset] = lights[i].getColor()[0];
        lightColorArray[offset + 1] = lights[i].getColor()[1];
        lightColorArray[offset + 2] = lights[i].getColor()[2];
        lightColorArray[offset + 3] = lights[i].getIntensity() * 5;
        lightTypeArray[offset] = getLightTypeIndex(lights[i]);
        lightTypeArray[offset + 1] = Math.cos(radiansFromDegrees(lights[i].getConeAngle()));
        lightTypeArray[offset + 2] = Math.cos(radiansFromDegrees(lights[i].getConeAngle() + lights[i].getConeFalloff()));
        lightTypeArray[offset + 3] = 0;
      }
      model.SSBO.clearData();
      model.SSBO.setNumberOfInstances(lights.length);
      model.SSBO.addEntry("LightPos", "vec4<f32>");
      model.SSBO.addEntry("LightDir", "vec4<f32>");
      model.SSBO.addEntry("LightColor", "vec4<f32>");
      model.SSBO.addEntry("LightData", "vec4<f32>");
      model.SSBO.setAllInstancesFromArray("LightPos", lightPosArray);
      model.SSBO.setAllInstancesFromArray("LightDir", lightDirArray);
      model.SSBO.setAllInstancesFromArray("LightColor", lightColorArray);
      model.SSBO.setAllInstancesFromArray("LightData", lightTypeArray);
      const device = model._parent.getDevice();
      model.SSBO.send(device);
    }
    model.lightTimeString = lightTimeString;
  };
  publicAPI.scissorAndViewport = (encoder) => {
    const tsize = publicAPI.getYInvertedTiledSizeAndOrigin();
    encoder.getHandle().setViewport(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize, 0, 1);
    encoder.getHandle().setScissorRect(tsize.lowerLeftU, tsize.lowerLeftV, tsize.usize, tsize.vsize);
  };
  publicAPI.bindUBO = (renderEncoder) => {
    renderEncoder.activateBindGroup(model.bindGroup);
  };
  publicAPI.opaquePass = (prepass) => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
      publicAPI.updateUBO();
      publicAPI.updateSSBO();
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      publicAPI.clear();
      model.renderEncoder.end();
    }
  };
  publicAPI.clear = () => {
    var _a;
    if (model.renderable.getTransparent() || model.suppressClear) {
      return;
    }
    const device = model._parent.getDevice();
    if (!model.clearFSQ) {
      model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash("clearfsq");
      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
      const ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      ubo.addEntry("FSQMatrix", "mat4x4<f32>");
      ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(ubo);
      model.backgroundTex = model.renderable.getEnvironmentTexture();
    }
    if (model.clearFSQ.getPipelineHash() !== "clearfsqwithtexture" && model.renderable.getUseEnvironmentTextureAsBackground() && ((_a = model.backgroundTex) == null ? void 0 : _a.getImageLoaded())) {
      model.clearFSQ.setFragmentShaderTemplate(clearFragTextureTemplate);
      const ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      ubo.addEntry("FSQMatrix", "mat4x4<f32>");
      ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(ubo);
      const environmentTextureHash = device.getTextureManager().getTextureForVTKTexture(model.backgroundTex, "EnvironmentTexture");
      if (environmentTextureHash.getReady()) {
        const tview = environmentTextureHash.createView(`EnvironmentTexture`);
        model.clearFSQ.setTextureViews([tview]);
        model.backgroundTexLoaded = true;
        const interpolate = model.backgroundTex.getInterpolate() ? "linear" : "nearest";
        tview.addSampler(device, {
          addressModeU: "repeat",
          addressModeV: "clamp-to-edge",
          addressModeW: "repeat",
          minFilter: interpolate,
          magFilter: interpolate,
          mipmapFilter: "linear"
        });
      }
      model.clearFSQ.setPipelineHash("clearfsqwithtexture");
    } else if (model.clearFSQ.getPipelineHash() === "clearfsqwithtexture" && !model.renderable.getUseEnvironmentTextureAsBackground()) {
      model.clearFSQ = vtkWebGPUFullScreenQuad$1.newInstance();
      model.clearFSQ.setDevice(device);
      model.clearFSQ.setPipelineHash("clearfsq");
      model.clearFSQ.setFragmentShaderTemplate(clearFragColorTemplate);
      const ubo = vtkWebGPUUniformBuffer$1.newInstance({
        label: "mapperUBO"
      });
      ubo.addEntry("FSQMatrix", "mat4x4<f32>");
      ubo.addEntry("BackgroundColor", "vec4<f32>");
      model.clearFSQ.setUBO(ubo);
    }
    const keyMats = model.webgpuCamera.getKeyMatrices(publicAPI);
    const background = model.renderable.getBackgroundByReference();
    model.clearFSQ.getUBO().setArray("BackgroundColor", background);
    mat4_exports.transpose(_tNormalMat4, keyMats.normalMatrix);
    mat4_exports.mul(_fsqClearMat4, keyMats.scvc, keyMats.pcsc);
    mat4_exports.mul(_fsqClearMat4, _tNormalMat4, _fsqClearMat4);
    model.clearFSQ.getUBO().setArray("FSQMatrix", _fsqClearMat4);
    model.clearFSQ.getUBO().sendIfNeeded(device);
    model.clearFSQ.prepareAndDraw(model.renderEncoder);
  };
  publicAPI.translucentPass = (prepass) => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      model.renderEncoder.end();
    }
  };
  publicAPI.volumeDepthRangePass = (prepass) => {
    if (prepass) {
      model.renderEncoder.begin(model._parent.getCommandEncoder());
    } else {
      publicAPI.scissorAndViewport(model.renderEncoder);
      model.renderEncoder.end();
    }
  };
  publicAPI.getAspectRatio = () => {
    const size = model._parent.getSizeByReference();
    const viewport = model.renderable.getViewportByReference();
    return size[0] * (viewport[2] - viewport[0]) / ((viewport[3] - viewport[1]) * size[1]);
  };
  publicAPI.convertToOpenGLDepth = (val) => model.webgpuCamera.convertToOpenGLDepth(val);
  publicAPI.getYInvertedTiledSizeAndOrigin = () => {
    const res = publicAPI.getTiledSizeAndOrigin();
    const size = model._parent.getSizeByReference();
    res.lowerLeftV = size[1] - res.vsize - res.lowerLeftV;
    return res;
  };
  publicAPI.getTiledSizeAndOrigin = () => {
    const vport = model.renderable.getViewportByReference();
    const tileViewPort = [0, 0, 1, 1];
    const vpu = vport[0] - tileViewPort[0];
    const vpv = vport[1] - tileViewPort[1];
    const ndvp = model._parent.normalizedDisplayToDisplay(vpu, vpv);
    const lowerLeftU = Math.round(ndvp[0]);
    const lowerLeftV = Math.round(ndvp[1]);
    const vpu2 = vport[2] - tileViewPort[0];
    const vpv2 = vport[3] - tileViewPort[1];
    const ndvp2 = model._parent.normalizedDisplayToDisplay(vpu2, vpv2);
    let usize = Math.round(ndvp2[0]) - lowerLeftU;
    let vsize = Math.round(ndvp2[1]) - lowerLeftV;
    if (usize < 0) {
      usize = 0;
    }
    if (vsize < 0) {
      vsize = 0;
    }
    return {
      usize,
      vsize,
      lowerLeftU,
      lowerLeftV
    };
  };
  publicAPI.getPropFromID = (id) => {
    for (let i = 0; i < model.children.length; i++) {
      const res = model.children[i].getPropID ? model.children[i].getPropID() : -1;
      if (res === id) {
        return model.children[i];
      }
    }
    return null;
  };
  publicAPI.getStabilizedTime = () => model.stabilizedTime.getMTime();
  publicAPI.releaseGraphicsResources = () => {
    if (model.selector !== null) {
      model.selector.releaseGraphicsResources();
    }
  };
}
var DEFAULT_VALUES74 = {
  bindGroup: null,
  selector: null,
  renderEncoder: null,
  recenterThreshold: 20,
  suppressClear: false,
  stabilizedCenter: [0, 0, 0]
};
function extend80(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES74, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.UBO = vtkWebGPUUniformBuffer$1.newInstance({
    label: "rendererUBO"
  });
  model.UBO.addEntry("WCVCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("SCPCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("PCSCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("SCVCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("VCPCMatrix", "mat4x4<f32>");
  model.UBO.addEntry("WCVCNormals", "mat4x4<f32>");
  model.UBO.addEntry("viewportSize", "vec2<f32>");
  model.UBO.addEntry("LightCount", "i32");
  model.UBO.addEntry("MaxEnvironmentMipLevel", "f32");
  model.UBO.addEntry("BackgroundDiffuseStrength", "f32");
  model.UBO.addEntry("BackgroundSpecularStrength", "f32");
  model.UBO.addEntry("cameraParallel", "u32");
  model.SSBO = vtkWebGPUStorageBuffer$1.newInstance({
    label: "rendererLightSSBO"
  });
  model.lightTimeString = "";
  model.bindGroup = vtkWebGPUBindGroup$1.newInstance({
    label: "rendererBG"
  });
  model.bindGroup.setBindables([model.UBO, model.SSBO]);
  model.tmpMat4 = mat4_exports.identity(new Float64Array(16));
  model.stabilizedTime = {};
  obj(model.stabilizedTime, {
    mtime: 0
  });
  get(publicAPI, model, ["bindGroup", "stabilizedTime"]);
  getArray(publicAPI, model, ["stabilizedCenter"]);
  setGet(publicAPI, model, ["renderEncoder", "selector", "suppressClear", "UBO"]);
  vtkWebGPURenderer(publicAPI, model);
}
var newInstance79 = newInstance(extend80, "vtkWebGPURenderer");
registerOverride2("vtkRenderer", newInstance79);

// node_modules/@kitware/vtk.js/Rendering/WebGPU/ScalarBarActor.js
function vtkWebGPUScalarBarActor(publicAPI, model) {
  model.classHierarchy.push("vtkWebGPUScalarBarActor");
  publicAPI.buildPass = (prepass) => {
    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType("vtkWebGPURenderer");
      model.WebGPURenderWindow = model.WebGPURenderer.getParent();
      if (!model.scalarBarActorHelper.getRenderable()) {
        model.scalarBarActorHelper.setRenderable(model.renderable);
      }
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.scalarBarActorHelper.getBarActor());
      publicAPI.addMissingNode(model.scalarBarActorHelper.getTmActor());
      publicAPI.removeUnusedNodes();
    }
  };
  publicAPI.opaquePass = (prepass, renderPass) => {
    if (prepass) {
      const camera = model.WebGPURenderer ? model.WebGPURenderer.getRenderable().getActiveCamera() : null;
      const tsize = model.WebGPURenderer.getTiledSizeAndOrigin();
      model.scalarBarActorHelper.updateAPISpecificData([tsize.usize, tsize.vsize], camera, model.WebGPURenderWindow.getRenderable());
    }
  };
}
var DEFAULT_VALUES75 = {};
function extend81(publicAPI, model) {
  let initialValues = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES75, initialValues);
  vtkViewNode$1.extend(publicAPI, model, initialValues);
  model.scalarBarActorHelper = vtkScalarBarActor$1.newScalarBarActorHelper();
  vtkWebGPUScalarBarActor(publicAPI, model);
}
var newInstance80 = newInstance(extend81, "vtkWebGPUScalarBarActor");
registerOverride2("vtkScalarBarActor", newInstance80);

export {
  vtkCellArray$1,
  HalfFloat,
  common_exports,
  mat3_exports,
  mat4_exports,
  vec3_exports,
  vec4_exports,
  quat_exports,
  vtkImplicitFunction$1,
  vtkPlane$1,
  STATIC3 as STATIC,
  vtkBoundingBox,
  AttributeTypes,
  DesiredOutputPrecision,
  vtkDataSetAttributes$1,
  FieldDataTypes,
  FieldAssociations,
  vtkDataSet$1,
  vtkStructuredData,
  vtkImageData$1,
  vtkScalarsToColors,
  ScalarMode,
  Constants6 as Constants,
  vtkScalarsToColors$1,
  vtkLookupTable$1,
  vtkPoints$1,
  vtkCell$1,
  CellType,
  vtkCellTypes$1,
  vtkLine$1,
  vtkPointSet$1,
  vtkPolyLine$1,
  PolygonWithPointIntersectionState,
  vtkPolygon$1,
  vtkTriangle$1,
  vtkQuad$1,
  vtkTriangleStrip$1,
  POLYDATA_FIELDS,
  vtkPolyData$1,
  vtkProp$1,
  vtkProp3D$1,
  Representation,
  PropertyConst,
  vtkProperty$1,
  vtkActor$1,
  vtkAbstractMapper$1,
  vtkAbstractMapper3D$1,
  Resolve,
  CATEGORIES,
  CoincidentTopologyHelper,
  Constants7 as Constants2,
  vtkMapper$1,
  vtkTexture$1,
  vtkProperty2D$1,
  vtkCubeAxesActor$1,
  vtkScalarBarActor$1,
  Wrap,
  Filter,
  vtkViewNode$1,
  vtkViewNodeFactory$1,
  registerOverride,
  vtkViewNodeFactory2 as vtkViewNodeFactory,
  vtkOpenGLTexture$1,
  ObjectType,
  vtkBufferObject,
  computeCoordShiftAndScale,
  vtkCellArrayBufferObject,
  vtkShader$1,
  vtkShaderProgram$1,
  vtkVertexArrayObject,
  primTypes,
  vtkHelper,
  vtkWebGPUShaderCache$1,
  vtkWebGPUTypes,
  vtkWebGPUSimpleMapper$1,
  vtkWebGPUFullScreenQuad$1,
  vtkWebGPUSampler$1,
  vtkWebGPUTextureView$1,
  vtkWebGPUTexture$1,
  vtkWebGPUBuffer$1,
  vtkWebGPUBufferManager$1,
  vtkWebGPUUniformBuffer$1,
  vtkWebGPUStorageBuffer$1,
  registerOverride2,
  vtkWebGPUViewNodeFactory$1,
  vtkActor,
  vtkActor2D,
  vtkCamera,
  vtkPolyDataVS,
  vtkPolyDataFS,
  vtkReplacementShaderMapper,
  vtkOpenGLPolyDataMapper$1,
  vtkPixelSpaceCallbackMapper,
  vtkPolyDataMapper2D,
  vtkRenderer,
  vtkSkybox,
  vtkWebGPUCellArrayMapper$1,
  vtkWebGPUPolyDataMapper$1
};
//# sourceMappingURL=chunk-2B3YMPK4.js.map
